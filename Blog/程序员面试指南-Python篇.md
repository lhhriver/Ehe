# 基础问题

**问题**：如何在Python中管理内存？

**解答**：Python中的内存管理由Python私有堆空间管理。对象和数据结构位于私有堆中，开发者无权访问此私有堆，是Python解释器负责处理的。Python对象的堆空间分配由内存管理器完成。核心API提供了一些开发者编写代码的工具。Python内置的垃圾回收器会回收使用所有的未使用内存，使其适用于堆空间。

***

**问题**：当Python退出时，是否会清除所有分配的内存？

**解答**：

答案是否。当Python退出时，对其他对象具有循环引用的Python模块，以及从全局名称空间引用的对象不会被解除分配或释放。无法解除分配C库保留的那些内存部分。退出时，由于拥有自己的高效清理机制，Python会尝试取消分配/销毁其他所有对象。

***

**问题**：为什么不建议以下划线作为标识符的开头？

**解答**：Python没有私有变量的概念，所以约定速成以下划线为开头来声明一个变量为私有。如果不想让变量私有，则不要使用下划线开头。

***

# 数据类型

**问题：**python内置的数据类型有哪些？

**解答：**

1. list: 链表, 有序的项目, 通过索引进行查找, 使用方括号"[]"
2. dict: 字典, 字典是一组键(key)和值(value)的组合, 通过键(key)进行查找, 没有顺序, 使用大括号"{}"
3. str：字符串，用单或双引号括起来表示字符串
4. tuple: 元组, 元组将多样的对象集合到一起, 不能修改, 通过索引进行查找, 使用括号"()"
5. set: 集合,无序, 元素只出现一次, 使用"set([])"，可实现列表快速去重，不过注意返回的是一个集合
6. int: 整数，如3
7. float：浮点数，如2.3
8. complex：复数，如complex(1,2) => 1+2j
9. 可迭代（遍历）对象：list、dict、tuple、set、str
10. 可变类型：list、dict、set，其余为不可变类型
11. list、tuple、str可通过索引获取当中的元素
12. set不支持索引查找，因为数据只出现一次, 它只关心数据是否出现, 不关心其位置。

# 生成器、迭代器

**问题：**简要概述一下python中生成器和迭代器？

**解答：**

`（1）迭代器：`

1. 迭代器协议：对象需要提供next()方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代。
2. 可迭代对象：实现了迭代器协议对象。list、tuple、dict都是Iterable（可迭代对象），但不是Iterator（迭代器对象）。但可以使用内建函数iter()，把这些都变成Iterable（可迭代器对象）。
3. for item in Iterable 循环的本质就是先通过iter()函数获取可迭代对象Iterable的迭代器，然后对获取到的迭代器不断调用next()方法来获取下一个值并将其赋值给item，遇到StopIteration的异常后循环结束。

`（2）生成器：`

1. 将列表生成式中[]改变为（）数据结构会改变，从列表变为生成器；
2. 列表受内存限制，所以没有必要创建完整的列表（节省大量内存空间），在python中我们可以采用生成器：边循环边计算的机制；
3. 生成器是只能遍历一次的。生成器是一类特殊的迭代器。还能使用 def 定义函数，但是，使用yield而不是return语句返回结果。yield语句一次返回一个结果，在每个结果中间，挂起函数的状态，以便下次从它离开的地方继续执行。

# 装饰器

**问题：**Python中的装饰器是什么？

**解答：**

1. 装饰器(Decorator)是Python中一个有趣的功能。
2. 它用于向现有代码添加功能。这也称为元编程，因为程序的一部分在编译时会尝试修改程序的另一部分。

```python
def addition(func):
    def inner(a,b):
        print("numbers are",a,"and",b)
        return func(a,b)
    return inner

@addition
def add(a,b):
    print(a+b)

add(5,6)
---------------------------------
numbers are 5 and 6
sum: 11
```

***

**问题：**函数装饰器的作用？

**解答：**

1. 装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。
2. 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

***

# 函数

**问题：**函数的闭包

闭包就是函数式编程的重要语法结构，提高了代码可重复实用性。使用特定或特殊的方式，将局部变量(内部函数)引入到全局环境中使用，这就是闭包操作。

# 进程、线程

**问题：**进程、线程的区别？

`（1）定义的不同`

1. 进程是系统进行资源分配和调度的一个独立单位。
2. 线程是进程的一个实体,是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。

`（2）区别`

1. 一个程序至少有一个进程，一个进程至少有一个线程。
2. 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。
3. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
4. 线线程不能够独立执行，必须依存在进程中。

`（3）优缺点`

1. 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。



# 数据库

**问题：**主键和外键的区别？

**解答：**

1. 主键在本表中是唯一的、不可唯空的，外键可以重复可以唯空；
2. 外键和另一张表的主键关联，不能创建对应表中不存在的外键。

***

**问题：**在数据库中查询语句速度很慢，如何优化？

**解答：**

1. 建索引 ；
2. 减少表之间的关联 ；
3. 优化sql，尽量让sql很快定位数据，不要让sql做全表查询，应该走索引,把数据 量大的表排在前面 ；
4. 简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据 ；
5. 数据库做好读写分离。

***

**问题：**Oracle和Mysql的区别？

**解答：**

1. 库函数不同。
2. Oracle是用表空间来管理的，Mysql不是。
3. 显示当前所有的表、用户、改变连接用户、显示当前连接用户、执行外部脚本的语句的不同。
4. 分页查询时候时候不同 。
5. sql的语法的不同。

***

**问题：**什么样的字段适合建立索引？

**解答：**唯一、不为空、经常被查询的字段。

***



# 网络协议

**问题：**tcp和udp的区别？

**解答：**

1. tcp是一种面向连接的、可靠的、基于字节流的传输层通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的，面向字节流。
2. udp（用户数据报协议）是iso参考模型中一种无连接的传输层协议，提供面向操作的简单不可靠的非连接传输层服务，面向报文。
3. 它们之间的区别：
    - tcp是基于连接的，安全性高；udp是基于无连接的，安全性较低；
    - 由于tcp是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差；同时过程复杂，也使其易于被攻击；而udp无连接，无建立连接的过程，因而实时性较强，也稍安全；
    - tcp连接是点到点的电话接通通信；udp支持一对一、一对多、多对一、多对多的广播通信。

***

**问题：**http协议与https协议的区别？

**解答：**

1. http是超文本传输协议在互联网上应用最为广泛的一种网络协议，所有www文件都必须遵守这个标准，基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）连接。
2. https是超文本传输安全协议，是一种网络安全传输协议。http协议传输的数据都没有加密，一些私密的信息不安全，https经由超文本传输协议（http）进行通信，利用SSL/TLS来加密数据包，https开发的主要目的就是为了保护数据传输的安全性。
3. HTTPS和HTTP的区别：
    -  https协议要申请证书到ca，需要一定经济成本
    -  http是明文传输，https是加密的安全传输
    -  连接的端口不一样，http是80，https是443
    - http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全。

# 并发编程

**问题：**进程和线程区别

**解答：**

***

**问题：**进程间内存是否共享？如何实现通讯？

**解答：**

1. 进程间内存不共享，可以通过Manage模块加锁、通过队列或、通过管道加锁、socket实现通讯

***

**问题：**从你的角度说说进程在计算机中扮演什么角色？

**解答：**

1. 进程在计算机中扮演数据集的调用调配角色。
2. 负责回收和控制子线程的运行，是一个数据集。

***

**问题：**GIL锁是怎么回事?

**解答：**GIL锁是全局解释器锁，只有CPython中使用，同一时间只能有一个线程调度CPU

***

**问题：**在python中是否线程安全？

**解答：**不安全，需要加锁才安全

***

**问题：**什么叫死锁？

**解答：**同时满足两个条件锁才能解开，分别有两把或以上的锁，有多个线程分别抢占了两个条件中的锁，互不释放造成阻塞，死锁现象。

***

**问题：**进程和线程的区别？

**解答：**进程是计算机资源分配的最小单位，线程是cpu调度的最小单位，线程较进程来说较轻量，启动更迅速。调用更方便

***

**问题：**进程池、线程池的优势和特点

**解答：**进程池一般在高计算的条件下使用，资源消耗更多。线程池可以运行在一个进程中，执行效率更高，可控cpu使用率。节约资源。

***

**问题：**线程和协程的异同?

**解答：**协程，即协作式程序，其思想是，一系列互相依赖的协程间依次使用CPU，每次只有一个协程工作，而其他协程处于休眠状态。协程实际上是在一个线程中，只不过每个协程对CUP进行分时，协程可以访问和使用unity的所有方法和component线程，多线程是阻塞式的，每个IO都必须开启一个新的线程，但是对于多CPU的系统应该使用thread，尤其是有大量数据运算的时刻，但是IO密集型就不适合；而且thread中不能操作unity的很多方法和component

***

**问题：**请简述一下互斥锁和递归锁的异同？

**解答：**两者在在单锁的情况下都可以保证数据的可靠性。二者唯一的区别是，同一个线程可以多次获取同一个递归锁，不会产生死锁。而如果一个线程多次获取同一个非递归锁，则会产生死锁。

***

**问题：**简述进程、线程、协程的区别

**解答：**

1. 进程是：一个CPU情况下，多个程序分别使用机器资源（CPU或硬盘等）的概念；
2. 线程是：一个进程情况下，多个执行流程（即线程）分别使用分配给该进程的机器资源的概念；
3. 协程是：一个线程情况下，多个执行流程（即协程）由线程控制，分别使用分配给该线程的机器资源的概念；
    以及应用场景？
4. 多进程：密集CPU任务，需要充分使用多核CPU资源（服务器，大量的并行计算）的时候，用多进程。 multiprocessing
    缺陷：多个进程之间通信成本高，切换开销大。
5. 多线程：密集I/O任务（网络I/O，磁盘I/O，数据库I/O）使用多线程合适。threading.Thread、multiprocessing.dummy。缺陷：同一个时间切片只能运行一个线程，不能做到高并行，但是可以做到高并发。
6. 多线程请求返回是无序的，那个线程有数据返回就处理那个线程，而协程返回的数据是有序的。缺陷：单线程执行，处理密集CPU和本地磁盘IO的时候，性能较低。处理网络I/O性能还是比较高

***

**问题：**什么是并行，什么是并发？

**解答：**

1. 并行是同一时间在多个cpu上同时执行多个程序
2. 并发是同一时间在同一个cpu上在不同程序之间切换运行

***

**问题：**请解释同步和异步这两个概念？

**解答：**

1. 同步执行程序需要等待结果
2. 异步执行程序不需要等待结果

***

**问题：**请谈谈对异步非阻塞的了解？

**解答：**执行效率高，可以实现高并发的应用场景

***

**问题：**简述信号量的实现原理

**解答：**

1. 信号量机制即利用pv操作来对信号量进行处理。什么是信号量？信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；
2. 当它的值小于0时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由PV操作来改变。一般来说，信号量S³0时，
3. S表示可用资源的数量。执行一次P操作意味着请求分配一个单位资源，因此S的值减1；当S<0时，表示已经没有可用资源，
4. 请求者必须等待别的进程释放该类资源，它才能运行下去。而执行一个V操作意味着释放一个单位资源，因此S的值加1；若S£0，
5. 表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。

***

**问题：**程序中的阻塞有哪些？给程序带来了哪些影响？

**解答：**input,sleep,io 程序会等待阻塞完成才会进入就绪队列，影响程序运行效率

***

**问题：**请分别用多进程、多线程、协程实现生产者消费者模型？

**解答：**

***

# Django

**问题：**Django的简介和设计思想？

**解答：**

1. Django是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来了这个框架，于2005年7月在BSD许可证下发布。Django的主要目的是简便、快速的开发数据库驱动的网站，它强调代码复用，多个组件可以很方便的以“插件”形式服务于整个框架。
2. Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发原则。

***

**问题：**MVC简介

**解答：**

1. MVC的全拼为Model-View-Controller，最早在20世纪80年代为程序语言Smalltalk发明的一种软件设计模式，是为了将传统的输入（input）、处理（processing）、输出（output）任务运用到图形化用户交互模型中而设计的。
2. 现MVC是一种架构设计模式，是一种设计理念。是为了达到分层设计的目的，从而使代码解耦，便于维护和代码的复用。MVC是3个单词的缩写，全称：Model-View-Controller（模型-视图-控制器）。
3. MVC就是提供一种规则，让你把相同类型的代码放在一起，这样就形成了层次，从而达到分层解耦、复用、便于测试和维护的目的。
4. Ｗeb MVC各部分的功能：
    - M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。
    - V全拼为View，用于封装结果，生成页面展示的html内容。
    - C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。

***

**问题：**Django框架遵循MVC设计，并且有一个专有名词：MVT

**解答：**

1. MVT各部分的功能：
    - M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。
    - V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。
    - T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。

---

**问题：**Django请求的生命周期

**解答：**

1. wsgi, 创建socket服务端，用于接收用户请求并对请求进行初次封装。
2. 中间件，对所有请求到来之前，响应之前定制一些操作。
3. 路由匹配，在url和视图函数对应关系中，根据当前请求url找到相应的函数。
4. 执行视图函数，业务处理【通过ORM去数据库中获取数据，再去拿到模板，然后将数据和模板进行渲染】
5. 再经过所有中间件。
6.  通过wsgi将响应返回给用户。

***

**问题：**简述django对http请求的执行流程

**解答：**

1.  一个 HTTP 请求，首先被转化成一个 HttpRequest 对象，然后该对象被传递给Request 中间件处理，如果该中间件返回了Response，则直接传递给 Response 中间件做收尾处理。否则的话 Request 中间件将访问 URL 配置，确定哪个 view 来处理，在确定了哪个 view 要执行，但是还没有执行该 view 的时候，系统会把 request 传递给 View 中间件处理器进行处理，如果该中间件返回了Response，那么该Response 直接被传递给 Response 中间件进行后续处理，否则将执行确定的 View 函数处理并返回 Response，在这个过程中如果引发了异常并抛出，会被 Exception 中间件处理器进行处理。

***

**问题：**简述Django的orm

**解答：**

1. ORM，全拼Object-Relation Mapping，意为对象-关系映射实现了数据模型与数据库的解耦，通过简单的配置就可以轻松更换数据库，而不需要修改代码只需要面向对象编程,orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句,所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可。

***

**问题：**Django里QuerySet的get和filter方法的区别？

**解答：**

1. django的get方法是从数据库的取得一个匹配的结果，返回一个对象，如果记录不存在的话，它会报错。
2. django的filter方法是从数据库的取得匹配的结果，返回一个对象列表，如果记录不存在的话，它会返回[]。 
3. get：只能取出一条数据,如果满足条件的数据有多条,抛出异常，没有数据,也会抛出异常
4. filter：如果有数据,就返回QuerySet(类似于可以遍历的数组) 如果没有数据,返回empty(不会抛异常)

***

**问题：**简述Django下的(内建的)缓存机制。

**解答：**

1. 缓存是将一些常用的数据保存内存或者memcache中,在一定的时间内有人来访问这些数据时,则不再去执行数据库及渲染等操作,而是直接从内存或memcache的缓存中去取得数据,然后返回给用户.django提供了6中内存缓存机制，分别为：
    - 开发调试缓存（为开发调试使用，实际上不使用任何操作）；
    - 内存缓存（将缓存内容缓存到内存中）；
    - 文件缓存（将缓存内容写到文件 ）；
    - 数据库缓存（将缓存内容存到数据库）；
    - memcache缓存（包含两种模块，python-memcached或pylibmc.）。
    - 以上缓存均提供了三种粒度的应用。

***

**问题：**django中model的slugfeild类型字段有什么用途？

**解答：**只包含字母、数字、下划线和连接符，通常用于urls

***

**问题：**什么是socket？

**解答：**

1. socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用以实现进程在网络中通信。

***

**问题：**Web开发中，session和cookie的作用与区别。

**解答：**

1. Cookie概念：在浏览某些 网站 时,这些网站会把 一些数据存在 客户端 , 用于使用网站 等跟踪用户实现用户自定义功能。
    - 是否设置过期时间:：如果不设置过期时间,则表示这个 Cookie生命周期为浏览器会话期间 , 只要关闭浏览器,cookie就消失了。 这个生命期为浏览会话期的cookie,就是会话Cookie;    
    - 存储：一般保存在内存,不在硬盘;    如果设置了过期时间, 浏览器会把cookie保存在硬盘上,关闭再打开浏览器, 这些cookie 依然有效直到超 过的设置过期时间;
2. Session的概念：
    - 作用：实现网页之间数据传递，是一个存储在服务器端的对象集合。
    - 原理：当用户请求一个Asp.net页面时，系统将自动创建一个Session;退出应用程序或关闭服务器时，该Session撤销。系统在创建Session时将为其分配一个长长的字符串标识，以实现对Session进行管理与跟踪。
3. cookie 和session 的区别：
    - cookie数据存放在客户的浏览器上，session数据放在服务器上。简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的session_id，服务器根据当前session_id判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的session_id，用特殊的浏览器伪造该用户的请求也是能够成功的。
    - session_id是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。
    - Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。
    - cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。
    - session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。
    - 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。(Session对象没有对存储的数据量的限制，其中可以保存更为复杂的数据类型)

***

**问题：**Web开发中有哪些技术手段防止SQL注入？

**解答：**

1. 使用预编译绑定变量的SQL语句。
2. 严格加密处理用户的机密信息。
3. 不要随意开启生产环境中Webserver的错误显示。
4. 使用正则表达式过滤传入的参数。
5. 字符串过滤。
6. 检查是否包函非法字符。

***

**问题：**如何查看占用8080端口的是什么进程？

**解答：**

1. windows查看端口占用，在windows命令行窗口下执行：netstat -aon|findstr "8080"
2. linux系统，先使用 netstat命令，再用 ps命令
    - 执行命令： netstat -anp|grep 8080
    - 输出结果： tcp 0 0 :::8080 :::* LISTEN 12006/java
    - 执行命令： ps -ef | grep 12006

***

**问题：**谈谈Django中的中间件。

**解答：**

1. django.middleware.security.SecurityMiddleware：一些安全设置，比如XSS脚本过滤。
2. django.contrib.sessions.middleware.SessionMiddleware：session支持中间件，加入这个中间件，会在数据库中生成一个django_session的表。
3. django.middleware.common.CommonMiddleware：通用中间件，会处理一些URL，比如baidu.com会自动的处理成www.baidu.com。比如/blog/111会处理成/blog/111/自动加上反斜杠。
4. django.middleware.csrf.CsrfViewMiddleware：跨域请求伪造中间件。加入这个中间件，在提交表单的时候会必须加入csrf_token，cookie中也会生成一个名叫csrftoken的值，也会在header中加入一个HTTP_X_CSRFTOKEN的值来放置CSRF攻击。
5. django.contrib.auth.middleware.AuthenticationMiddleware：用户授权中间件。他会在每个HttpRequest对象到达view之前添加当前登录用户的user属性，也就是你可以在view中通过request访问user。
6. django.contrib.messages.middleware.MessageMiddleware：消息中间件。展示一些后台信息给前端页面。如果需要用到消息，还需要在INSTALLED_APPS中添加django.contrib.message才能有效。如果不需要，可以把这两个都删除。
7. django.middleware.clickjacking.XFrameOptionsMiddleware：防止通过浏览器页面跨Frame出现clickjacking（欺骗点击）攻击出现。

***

**问题：**谈谈CSRF原理

**解答：**

1. CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/sessionriding，缩写为：CSRF/XSRF。
2. 你这可以这么理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。
3. 要完成一次CSRF攻击，受害者必须依次完成两个步骤：
    - 登录受信任网站A，并在本地生成Cookie。
    - 在不登出A的情况下，访问危险网站B。

***

**问题：**谈谈RESTful规范

**解答：**

1. Representational State Transfer "表现层状态转化"，restful其实就是一套编写接口的协议，协议规定如何编写以及如何设置返回值、状态码等信息。restful: 给用户一个url，根据method不同在后端做不同的处理，比如：post 创建数据、get获取数据、put和patch修改数据、delete删除数据。
    - 每一个URI代表一种资源；
    - 客户端和服务器之间，传递这种资源的某种表现层；
    - 客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。
2. 我们常用的状态码： 
    - 200   请求成功 
    - 301   永久重定向
    - 302   临时重定向   
    - 403   权限问题
    - 404   找不到页面
    - 500   服务器问题

***

**问题：**对Django的认识？

**解答：**

1. Django是走大而全的方向，它最出名的是其全自动化的管理后台：只需要使用起ORM，做简单的对象定义，它就能自动生成数据库结构、以及全功能的管理后台。
2. Django内置的ORM跟框架内的其他模块耦合程度高。应用程序必须使用Django内置的ORM，否则就不能享受到框架内提供的种种基于其ORM的便利；理论上可以切换掉其ORM模块，但这就相当于要把装修完毕的房子拆除重新装修，倒不如一开始就去毛胚房做全新的装修。
3. Django的卖点是超高的开发效率，其性能扩展有限；采用Django的项目，在流量达到一定规模后，都需要对其进行重构，才能满足性能的要求。
4. Django适用的是中小型的网站，或者是作为大型网站快速实现产品雏形的工具。
5. Django模板的设计哲学是彻底的将代码、样式分离； Django从根本上杜绝在模板中进行编码、处理数据的可能。

***

**问题：**Django 、Flask、Tornado的对比？

**解答：**

1. Django走的是大而全的方向,开发效率高。它的MTV框架,自带的ORM,admin后台管理,自带的sqlite数据库和开发测试用的服务器，给开发者提高了超高的开发效率。
2. Flask是轻量级的框架,自由,灵活,可扩展性很强,核心基于Werkzeug WSGI工具和jinja2模板引擎。
3. Tornado走的是少而精的方向,性能优越。它最出名的是异步非阻塞的设计方式，Tornado的两大核心模块：
    - iostraem：对非阻塞式的socket进行简单的封装
    - ioloop：对I/O多路复用的封装，它实现了一个单例

***

**问题：**什么是wsgi,uwsgi,uWSGI？

**解答：**

1. WSGI:web服务器网关接口,是一套协议。用于接收用户请求并将请求进行初次封装，然后将请求交给web框架，实现wsgi协议的模块：
    - wsgiref,本质上就是编写一个socket服务端，用于接收用户请求(django)
    - werkzeug,本质上就是编写一个socket服务端，用于接收用户请求(flask)
2. uwsgi:与WSGI一样是一种通信协议，它是uWSGI服务器的独占协议,用于定义传输信息的类型。
3. uWSGI:是一个web服务器,实现了WSGI协议,uWSGI协议,http协议。

***

**问题：**django请求的生命周期？

**解答：**

1. wsgi,请求封装后交给web框架 （Flask、Django）     
2. 中间件，对请求进行校验或在请求对象中添加其他相关数据，例如：csrf、request.session
3. 路由匹配 根据浏览器发送的不同url去匹配不同的视图函数    
4. 视图函数，在视图函数中进行业务逻辑的处理，可能涉及到：orm、templates => 渲染 
5. 中间件，对响应的数据进行处理。 
6. wsgi,将响应的内容发送给浏览器。

***

**问题：**简述什么是FBV和CBV？

**解答：**

1. FBV和CBV本质是一样的：基于函数的视图叫做FBV，基于类的视图叫做CBV
2. 在python中使用CBV的优点：
    - 提高了代码的复用性，可以使用面向对象的技术，比如Mixin（多继承）
    - 可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高代码可读性

***

**问题：**简述MVC和MTV

**解答：**

1. MVC软件系统分为三个基本部分：模型(Model)、视图(View)和控制器(Controller)
    - Model：负责业务对象与数据库的映射(ORM)
    - View：负责与用户的交互
    - Control：接受用户的输入调用模型和视图完成用户的请求
2. Django框架的MTV设计模式借鉴了MVC框架的思想,三部分为：Model、Template和View
    - Model(模型)：负责业务对象与数据库的对象(ORM)
    - Template(模版)：负责如何把页面展示给用户
    - View(视图)：负责业务逻辑，并在适当的时候调用Model和Template
3. 此外,Django还有一个urls分发器,它将一个个URL的页面请求分发给不同的view处理,view再调用相应的Model和Template

***

**问题：**django路由系统中name的作用？

**解答：**

1. 用于反向解析路由,相当于给url取个别名，只要这个名字不变,即使对应的url改变，通过该名字也能找到该条url

***

**问题：**列举django的内置组件？

**解答：**

1. Admin是对model中对应的数据表进行增删改查提供的组件
2. model组件：负责操作数据库
3. form组件：1.生成HTML代码2.数据有效性校验3校验信息返回并展示
4. ModelForm组件即用于数据库操作,也可用于用户请求的验证

***

**问题：**说一下Django，MIDDLEWARES中间件的作用和应用场景？

**解答：**

1. 中间件是介于request与response处理之间的一道处理过程,用于在全局范围内改变Django的输入和输出。
2. 简单的来说中间件是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作
3. 例如：
    - Django项目中默认启用了csrf保护,每次请求时通过CSRF中间件检查请求中是否有正确#token值
    - 当用户在页面上发送请求时，通过自定义的认证中间件，判断用户是否已经登陆，未登陆就去登陆。
    - 当有用户请求过来时，判断用户是否在白名单或者在黑名单里

***

**问题：**列举django中间件的5个方法？

**解答：**

1. process_request : 请求进来时,权限认证
2. process_view : 路由匹配之后,能够得到视图函数
3. process_exception : 异常时执行
4. process_template_responseprocess : 模板渲染时执行
5. process_response : 请求有响应时执行

***

**问题：**Django重定向是如何实现的？用的什么状态码？

**解答：**

1. 使用HttpResponseRedirect：from django.http import HttpResponseRedirect 
2. 使用redirect和reverse
3. 状态码：301和302，301和302的区别：
    - 相同点：都表示重定向，浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址
    - 不同点：301比较常用的场景是使用域名跳转。比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，表示旧地址A的资源已经被永久地移除了
    - 302用来做临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B

***

**问题：**31、 django中csrf的实现机制

**解答：**

1. 第一步：django第一次响应来自某个客户端的请求时,后端随机产生一个token值，把这个token保存在SESSION状态中;同时,后端把这个token放到cookie中交给前端页面；
2. 第二步：下次前端需要发起请求（比如发帖）的时候把这个token值加入到请求数据或者头信息中,一起传给后端；Cookies:{csrftoken:xxxxx}
3. 第三步：后端校验前端请求带过来的token和SESSION里的token是否一致；

***

**问题：**Django本身提供了runserver，为什么不能用来部署？(runserver与uWSGI的区别)

**解答：**

1. runserver方法是调试 Django 时经常用到的运行方式，它使用Django自带的WSGI Server 运行，主要在测试和开发中使用，并且 runserver 开启的方式也是单进程 。
2. uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http 等协议。注意uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的 Web 服务器。
3. uWSGI具有超快的性能、低内存占用和多app管理等优点，并且搭配着Nginx就是一个生产环境了，能够将用户访问请求与应用 app 隔离开，实现真正的部署 。
4. 相比来讲，支持的并发量更高，方便管理多进程，发挥多核的优势，提升性能。

***

**问题：**cookie和session的区别

**解答：**

1. cookie：cookie是保存在浏览器端的键值对,可以用来做用户认证
2. session：将用户的会话信息保存在服务端,key值是随机产生的自符串,value值时session的内容，依赖于cookie将每个用户的随机字符串保存到用户浏览器上
3. Django中session默认保存在数据库中：django_session表
4. flask,session默认将加密的数据写在用户的cookie中

***

# Flask



# Redis

**问题：**redis中常用的5种数据类型？

**解答：**

1. Redis支持5种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。

***

# 其它问题

**问题**：Python中__new__与__init__方法的区别

**解答**：

`① __new__`:

1. 触发时机： 在实例化对时触发
2. 参数：至少一个cls 接收当前类
3. 返回值：必须返回一个对象实例
4. 作用：实例化对象
5. 注意：实例化对象是Object类底层实现，其他类继承了Object的__new__才能够实现实例化对象。

`② __init__`:

1. 触发时机：初始化对象时触发（不是实例化触发，但是和实例化在一个操作中）
2. 参数：至少有一个self，接收对象
3. 返回值：无
4. 作用：初始化对象的成员
5. 注意：使用该方式初始化的成员都是直接写入对象当中，类中无法具有。

***

**问题**：什么是匿名函数？

**解答**：

Lambda函数，不用担心函数名冲突，不过python对匿名函数支持有限，只有一些简单的情况下可以用

```python
# 声明一个简单的lambda表达式
mylamb = lambda x,y:x+y

# 调用函数
result = mylamb(8,9)
print(result)
```

***

**问题：**Python的垃圾回收机制（garbage collection）

**解答：**

1. 当gc模块的计数器达到阈值，垃圾自动回收。
2. 当调用gc.collect()，垃圾收到回收。
3. 程序退出的时候，python解释器来回收垃圾。

***

**问题：**Python里面浅拷贝和深拷贝的区别？

**解答：**

***

**问题：**apache和nginx的区别？

**解答：**

`（1）nginx 相对 apache 的优点：`

1. 轻量级，同样起web 服务，比apache 占用更少的内存及资源
2. 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能
3. 配置简洁
4. 高度模块化的设计，编写模块相对简单
5. 社区活跃

`（2）apache 相对nginx 的优点：`

1. rewrite ，比nginx 的rewrite 强大；
2. 模块超多，基本想到的都可以找到；
3. 少bug ，nginx 的bug 相对较多；
4. 超稳定。

***

**问题：**什么是事务？

**解答：**

1. 事务(Transaction)是并发控制的基本单位。所谓事务,它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银行转帐工作：从一个帐号扣款并使另一个帐号增款，这两个操作要么都执行，要么都不执行。所以，应该把他们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。
2. 事务四大特性：
    - 原子性：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行；
    - 一致性：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致；
    - 隔离性：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的；
    - 持久性：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。

***

**问题：**对if \_\_name\_\_ == '\_\_main\_\_'的理解？

**解答：**

1. 在Python中分为两类：一种是直接执行，另外一种是作为模块时才被调用。
2. \_\_name\_\_ 作为模块的内置属性，即".py"文件的调用方式。如果等于“\_\_main\_\_"就直接执行本文件，如果是别的就是作为模块被调用。

***

**问题：**python中search（）和match（）的区别

**解答：**

1. match从起始位置开始往后查找，返回第一个符合规则的
2. search任何位置开始往后查找，返回第一个符合规则的

***

**问题：**Python中@staticmethod和@classmethod的区别。

**解答：**

在类中总共有三种方法：

1. 普通方法（需要参数，使用时默认将类的实例对象传进去，类调用的时候需要传递实例对象）
2. @staticmethod装饰的静态方法与普通函数相同（实例和类均可调用，没有默认的参数传递进去）
3. @classmethod装饰的类方法（需要参数，使用时将调用的类传进去，或者实例对象调用时是将实例对应的类传进去。