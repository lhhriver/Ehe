# 第1章  C++概述

# 第2章 处理数据

# 第3章 分支结构

# 第4章 循环结构

# 第5章 数组

# 第6章 指针

# 第7章 函数初识

# 第8章 函数进阶

# 第9章 位运算符、构造类型与名称空间

# 第10章 面向对象与类

# 第11章 类的高级主题

# 第12章 类的继承

# 第13章 多态

## 运算符重载

### 问题的提出

#### **【例13-1】用运算符实现复教的加减运算**

```c++
//文件:ex13_1.cpp
#include <iostream>
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0); //有默认参数值的构造函数
    void print();
    Complex operator+(const Complex &c); //重载运算符+
    Complex operator-(const Complex &c); //重载运算符-
};

Complex::Complex(double r, double i)
{
    real = r;
    imag = i;
}

void Complex::print()
{
    cout << real << "+" << imag << "i" << endl;
}

Complex Complex::operator+(const Complex &c) //重载运算符+
{
    Complex temp;
    temp.real = real + c.real;
    temp.imag = imag + c.imag;
    return temp;
}

Complex Complex::operator-(const Complex &c) ///重载运算符-
{
    Complex temp;
    temp.real = real - c.real;
    temp.imag = imag - c.imag;
    return temp;
}

int main()
{
    Complex a(5, 10), b(3.0, 4.0), c, d;
    c = a + b; //复数a加复数b
    // c=a.operator +(b);
    d = a - b; //复数a减复数b
    cout << "c = ";
    c.print();
    cout << "d = ";
    d.print();
    return 0;
}

```

输出：

```
c = 8+14i
d = 2+6i
```

### 运算符重载的格式与规则



## 运算符重载为类的成员函数

### 双目运算符重载

#### **【例13-2】复数的乘法运算与关系运算**

```c++
//文件:ex13_2.cpp
#include <iostream>
#include <cmath>
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0); //有默认参数值的构造函数
    void print();
    Complex operator+(const Complex &c); //重载运算符+
    Complex operator-(const Complex &c); //重载运算符-
    Complex operator*(const Complex &c); //重载运算符*
    bool operator>(const Complex &c);    //重载运算符>
};

Complex::Complex(double r, double i)
{
    real = r;
    imag = i;
}

void Complex::print()
{
    cout << real << "+" << imag << "i" << endl;
}

Complex Complex::operator+(const Complex &c) //重载运算符+
{
    Complex temp;
    temp.real = real + c.real;
    temp.imag = imag + c.imag;
    return temp;
}

Complex Complex::operator-(const Complex &c) ///重载运算符-
{
    Complex temp;
    temp.real = real - c.real;
    temp.imag = imag - c.imag;
    return temp;
}

Complex Complex::operator*(const Complex &c) //重载运算符*
{
    Complex temp;
    temp.real = real * c.real - imag * c.imag;
    temp.imag = real * c.imag + imag * c.real;
    return temp;
}

bool Complex::operator>(const Complex &c) //重载运算符>
{
    double z1, z2;
    z1 = sqrt(real * real + imag * imag);
    z2 = sqrt(c.real * c.real + c.imag * c.imag);
    
    if (z1 > z2)
        return true;
    else
        return false;
}

int main()
{
    Complex a(5, 10), b(3.0, 4.0), c, d;
    c = a * b; //复数乘复数b
    d = a + 10;
    a.print();
    b.print();
    c.print();
    d.print();
    cout << "a>b? " << (a > b) << endl;
    cout << "b>a? " << (b > a) << endl;
    return 0;
}

```

输出：

```
5+10i
3+4i
-25+50i
15+10i
a>b? 1
b>a? 0
```



### 单目运算符重载

#### **【例13-3】重载自增运算符+**

```c++
//文件:ex13_3.cpp
#include <iostream>
using namespace std;
class Int
{
private:
    int i;

public:
    Int(int a = 0);
    void print();
    Int operator++();
    Int operator++(int);
};
Int::Int(int a)
{
    i = a;
}
void Int::print()
{
    cout << "i=" << i << endl;
}
Int Int::operator++()
{
    Int temp;
    temp.i = ++i; // i=10, -->11, temp.i=11;
    return temp;
}
Int Int::operator++(int)
{
    Int temp;
    temp.i = i++; // i=10; temp.i=10, i--->11
    return temp;
}
int main()
{
    Int a(5), b(5), c, d;
    c = a++; // c.i=5; a.i=6
    d = ++b; // b.i=6; d.i=6
    cout << "a: ";
    a.print();
    cout << "b: ";
    b.print();
    cout << "c: ";
    c.print();
    cout << "d: ";
    d.print();
    return 0;
}

```

输出：

```
a: i=6
b: i=6
c: i=5
d: i=6
```



### 赋值运算符重载

#### **【例13-4】默认赋值运算符的缺陷**

```c++
//文件:ex13_4.cpp
#include <iostream>
#include <cstring>
using namespace std;

class A
{
private:
    char *str;

public:
    A(char *s = "no data");
    ~A();
    void print();
};

A::A(char *s)
{
    int len = strlen(s);
    str = new char[len + 1];
    strcpy(str, s);
}

A::~A()
{
    if (str != NULL)
        delete[] str;
}

void A::print()
{
    cout << str << endl;
}

int main()
{
    A *p = new A("A String");
    A a1;
    a1 = *p;
    a1.print();
    delete p;
    a1.print();
    return 0;
}

```

输出：

```
A String
0)\
```



#### **【例13-5】赋值运算符的重载**

```c++
//文件:ex13_5.cpp
#include <iostream>
#include <cstring>
using namespace std;

class A
{
private:
    char *str;

public:
    A(char *s = "no data");
    ~A();
    void print();
    A &operator=(const A &a);
};

A::A(char *s)
{
    int len = strlen(s);
    str = new char[len + 1];
    strcpy(str, s);
}

A::~A()
{
    if (str != NULL)
        delete[] str;
}

void A::print()
{
    cout << str << endl;
}

A &A::operator=(const A &a)
{
    int len = strlen(a.str);
    
    if (str)
        delete[] str; //先释放，再根据实际需要重新申请
    
    str = new char[len + 1];
    strcpy(str, a.str);
    return *this;
}

int main()
{
    A *p = new A("A String");
    A a1, a2;
    a1 = a2 = *p;
    a1.print();
    delete p;
    a1.print();
    a2.print();
    return 0;
}

```

输出：

```
A String
A String
A String
```



## 运算符重载为类的友元函数

### 运算符重载为成员函数的局限性

### 运算符重载为友元函数

#### **【例13-6】复数类加减运算符重载为类的友元函数**

```c++
//文件:ex13_6.cpp
#include <iostream>
using namespace std;

class Complex
{
private:
    double real;
    double imag;

public:
    Complex(double r = 0, double i = 0); //有默认参数值的构造函数
    void print();
    friend Complex operator+(const Complex &c1, const Complex &c2);
    friend Complex operator-(const Complex &c1, const Complex &c2);
};

Complex::Complex(double r, double i)
{
    real = r;
    imag = i;
}

void Complex::print()
{
    cout << real << "+" << imag << "i" << endl;
}

Complex operator+(const Complex &c1, const Complex &c2)
{
    Complex temp;
    temp.real = c1.real + c2.real;
    temp.imag = c1.imag + c2.imag;
    return temp;
}

Complex operator-(const Complex &c1, const Complex &c2)
{
    Complex temp;
    temp.real = c1.real - c2.real;
    temp.imag = c1.imag - c2.imag;
    return temp;
}

int main()
{
    Complex a(1, 2), b(3.0, 4.0), c, d, e;
    c = a + b;
    d = b - 10;
    e = 20 + a;
    cout << "c = ";
    c.print();
    cout << "d = ";
    d.print();
    cout << "e = ";
    e.print();
    return 0;
}

```

输出：

```
c = 4+6i
d = -7+4i
e = 21+2i
```



## 虚函数

### 用虚函数实现动态多态

#### **【例13-7】使用虚函数实现动态多态**

##### Point.h

```c++
//文件:ex13_7\Point.h
#ifndef POINT_H
#define POINT_H
class Point
{
    int x;
    int y;

public:
    Point(int x = 0, int y = 0);
    Point(const Point &p);
    int getX();
    int getY();
};
#endif

```

##### Point.cpp

```c++
//文件:ex13_7\Point.cpp
#include "Point.h"
Point::Point(int x, int y)
{
    this->x = x;
    this->y = y;
}
Point::Point(const Point &p)
{
    x = p.x;
    y = p.y;
}
int Point::getX()
{
    return x;
}
int Point::getY()
{
    return y;
}

```

##### Shape.h

```c++
//文件:ex13_7\Shape.h
#ifndef SHAPE_H
#define SHAPE_H
class Shape
{
private:
    char Color[10];

public:
    Shape(char *c);
    virtual void draw();
    void outputColor();
};
#endif

```

##### Shape.cpp

```c++
//文件:ex13_7\Shape.cpp
#include <iostream>
#include "Shape.h"
#include <cstring>
using namespace std;
Shape::Shape(char *c)
{
    strcpy(Color, c);
}
void Shape::draw()
{
    cout << "Draw a shape. The color is " << Color << endl;
}
void Shape::outputColor()
{
    cout << Color << endl;
}

```

##### Line.h

```c++
//文件:ex13_7\Line.h
#ifndef LINE_H
#define LINE_H
#include "Shape.h"
#include "Point.h"
class Line : public Shape
{
private:
    Point start;
    Point end;

public:
    Line(const Point &s, const Point &e, char *c);
    virtual void draw();
};
#endif

```

##### Line.cpp

```c++
//文件:ex13_7\Line.cpp
#include <iostream>
#include "Line.h"
using namespace std;
Line::Line(const Point &s, const Point &e, char *c) : Shape(c), start(s), end(e)
{
}
void Line::draw()
{
    cout << "Draw a Line from (" << start.getX() << "," << start.getY();
    cout << ") to (" << end.getX() << "," << end.getY() << "), with color ";
    outputColor();
}

```

##### Circle.h

```c++
//文件:ex13_7\Circle.h
#ifndef CIRCLE_H
#define CIRCLE_H
#include "Shape.h"
#include "Point.h"
class Circle : public Shape
{
private:
    Point center;
    int radius;

public:
    Circle(const Point &ct, int radius, char *color);
    virtual void draw();
};
#endif

```

##### Circle.cpp

```c++
//文件:ex13_7\Circle.cpp
#include <iostream>
#include "Circle.h"
using namespace std;
Circle::Circle(const Point &ct, int radius, char *color) : Shape(color), center(ct)
{
    this->radius = radius;
}
void Circle::draw()
{
    cout << "Draw a circle at center (" << center.getX() << ",";
    cout << center.getY() << ") with radius " << radius << " and color ";
    outputColor();
}

```

##### main.cpp

```c++
//文件:ex13_7\main.cpp
#include "Line.h"
#include "Circle.h"
int main()
{
    Shape *ps[3];
    Shape s("Red");
    Point p1(10, 10), p2(100, 100), p3(50, 50);
    Line l(p1, p2, "Green");
    Circle c(p3, 20, "Black");
    ps[0] = &s;
    ps[1] = &l;
    ps[2] = &c;
    for (int i = 0; i < 3; i++)
        ps[i]->draw();
    return 0;
}

```

编译：

```shell
g++ -g -o out main.cpp Circle.cpp Line.cpp Shape.cpp Point.cpp
```

执行：

```shell
.\out.exe
```

输出：

```
Draw a shape. The color is Red
Draw a Line from (10,10) to (100,100), with color Green
Draw a circle at center (50,50) with radius 20 and color Black
```



### 虚函数实现动态多态的机制

#### **【例13-8】含有虚函数类的对象所占用的存储空间**

```c++
//文件:ex13_8.cpp
#include <iostream>
using namespace std;
class A
{
private:
    int a;

public:
    void func() {}
};
class B : public A
{
private:
    int b;

public:
    void func() {}
    void func1() {}
};
int main()
{
    cout << "sizeof(A)=" << sizeof(A) << endl;
    cout << "sizeof(B)=" << sizeof(B) << endl;
}

```

输出：

```
sizeof(A)=4
sizeof(B)=8
```



### 虚析构函数

#### **【例13-9】应用虚析构函数**

```c++
//文件:ex13_9.cpp
#include <iostream>
#include <cstring>
using namespace std;
class Employee
{
private:
    char *name;
    int age;

public:
    Employee(char *n, int a);
    virtual ~Employee();
};
Employee::Employee(char *n, int a)
{
    name = new char[strlen(n) + 1];
    strcpy(name, n);
    age = a;
}
Employee::~Employee()
{
    cout << "Destruct Employee: " << name << endl;
    if (name)
    {
        delete[] name;
    }
}
class Teacher : public Employee
{
private:
    char *mainCourse;

public:
    Teacher(char *n, char *course, int a);
    ~Teacher();
};
Teacher::Teacher(char *n, char *course, int a) : Employee(n, a)
{
    mainCourse = new char[strlen(course) + 1];
    strcpy(mainCourse, course);
}
Teacher::~Teacher()
{
    cout << "Destruct Teacher " << mainCourse << endl;
    if (mainCourse)
        delete[] mainCourse;
}
int main()
{
    Employee *p[3];
    p[0] = new Employee("Zhangsan", 20);
    p[1] = new Teacher("Lisi", "C for 2 years,C++ 3 years", 26);
    p[2] = new Teacher("Wangwu", "Data structure for 2 years,C++ 3 years", 30);
    for (int i = 0; i < 3; i++)
        delete p[i];
    return 0;
}

```

输出：

```
Destruct Employee: Zhangsan
Destruct Teacher C for 2 years,C++ 3 years
Destruct Employee: Lisi
Destruct Teacher Data structure for 2 years,C++ 3 years
Destruct Employee: Wangwu
```



### 纯虚函数与抽象类

#### **【例13-10】纯虚函教**

##### Point.h

```c++
//文件:ex13_10\Point.h
#ifndef POINT_H
#define POINT_H
class Point
{
    int x;
    int y;

public:
    Point(int x = 0, int y = 0);
    Point(const Point &p);
    int getX();
    int getY();
};
#endif

```

##### Point.cpp

```c++
//文件:ex13_10\Point.cpp
#include "Point.h"
Point::Point(int x, int y)
{
    this->x = x;
    this->y = y;
}
Point::Point(const Point &p)
{
    x = p.x;
    y = p.y;
}
int Point::getX()
{
    return x;
}
int Point::getY()
{
    return y;
}

```

##### Shape.h

```c++
//文件:ex13_10\Shape.h
#ifndef SHAPE_H
#define SHAPE_H
class Shape
{
private:
    char Color[10];

public:
    Shape(char *c);
    virtual void draw() = 0;
    void outputColor();
};
#endif

```

##### Shape.cpp

```c++
//文件:ex13_10\Shape.cpp
#include <iostream>
#include "Shape.h"
#include <cstring>
using namespace std;
Shape::Shape(char *c)
{
    strcpy(Color, c);
}

void Shape::outputColor()
{
    cout << Color << endl;
}

```

##### Line.h

```c++
//文件:ex13_10\Line.h
#ifndef LINE_H
#define LINE_H
#include "Shape.h"
#include "Point.h"
class Line : public Shape
{
private:
    Point start;
    Point end;

public:
    Line(const Point &s, const Point &e, char *c);
    virtual void draw();
};
#endif

```

##### Line.cpp

```c++
//文件:ex13_10\Line.cpp
#include <iostream>
#include "Line.h"
using namespace std;
Line::Line(const Point &s, const Point &e, char *c) : Shape(c), start(s), end(e)
{
}
void Line::draw()
{
    cout << "Draw a Line from (" << start.getX() << "," << start.getY();
    cout << ") to (" << end.getX() << "," << end.getY() << "), with color ";
    outputColor();
}

```

##### Circle.h

```c++
//文件:ex13_10\Circle.h
#ifndef CIRCLE_H
#define CIRCLE_H
#include "Shape.h"
#include "Point.h"
class Circle : public Shape
{
private:
    Point center;
    int radius;

public:
    Circle(const Point &ct, int radius, char *color);
    virtual void draw();
};
#endif

```

##### Circle.cpp

```c++
//文件:ex13_10\Circle.cpp
#include <iostream>
#include "Circle.h"
using namespace std;
Circle::Circle(const Point &ct, int radius, char *color) : Shape(color), center(ct)
{
    this->radius = radius;
}
void Circle::draw()
{
    cout << "Draw a circle at center (" << center.getX() << ",";
    cout << center.getY() << ") with radius " << radius << " and color ";
    outputColor();
}

```

##### main.cpp

```c++
//文件:ex13_10\main.cpp
#include <iostream>
using namespace std;
#include "Line.h"
#include "Circle.h"
int main()
{
    Shape *ps[3];
    Point p1(10, 10), p2(100, 100), p3(50, 50);
    Line l(p1, p2, "Green");
    Circle c(p3, 20, "Black");
    ps[1] = &l;
    ps[2] = &c;
    for (int i = 1; i < 3; i++)
        ps[i]->draw();

    cout.put('A').put('B').put('\n');
    cout.write("ABCDEFG", 4).put('\n');
    return 0;
}

```

编译：

```shell
g++ -g -o out main.cpp Circle.cpp Line.cpp Shape.cpp Point.cpp
```

执行：

```shell
.\out.exe
```

输出：

```
Draw a Line from (10,10) to (100,100), with color Green
Draw a circle at center (50,50) with radius 20 and color Black
AB
ABCD
```



## 小结

## 习题十









