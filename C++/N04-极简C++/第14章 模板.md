# 第1章  C++概述

# 第2章 处理数据

# 第3章 分支结构

# 第4章 循环结构

# 第5章 数组

# 第6章 指针

# 第7章 函数初识

# 第8章 函数进阶

# 第9章 位运算符、构造类型与名称空间

# 第10章 面向对象与类

# 第11章 类的高级主题

# 第12章 类的继承

# 第13章 多态

# 第14章 模板

## 函数模板

### 函数模板的定义

#### **【例14-1】定义用于变量交换的数模朴**

```c++
//文件:ex14_1.cpp
#include <iostream>
using namespace std;
template <typename T>
void swap1(T &x, T &y);
int main()
{
    char a = 'A', b = 'B';
    int c = 123, d = 456;
    double x = 12.3, y = 45.6;
    swap1(a, b);
    swap1(c, d);
    swap1(x, y);
    cout << a << "," << b << endl;
    cout << c << "," << d << endl;
    cout << x << "," << y << endl;
    return 0;
}
template <typename T>
void swap1(T &x, T &y)
{
    T temp = x;
    x = y;
    y = temp;
}

```

输出：

```
B,A
456,123
45.6,12.3
```



#### **【例14-2】插入排序函数模板**

```c++
//文件:ex14_2.cpp
#include <iostream>
using namespace std;
template <typename T>
void insertionSort(T A[], int n)
{
    int i, j;
    T temp;
    for (i = 1; i < n; i++)
    {
        //从A[i-1]开始向A[0]方向扫描各元素，寻找适当位置插入A[i]
        j = i;
        temp = A[i];
        while (j > 0 && temp < A[j - 1])
        {
            //当遇到temp>=A[j-1]结束循环时，j便是应插入的位置
            //当遇到j==0结束循环时，则0是应插入的位置
            A[j] = A[j - 1]; //将元素逐个后移，以便找到插入位置时可以立即插入
            j--;
        }
        A[j] = temp;
    }
}
int main()
{
    int a[10] = {2, 4, 1, 8, 7, 9, 0, 3, 5, 6};
    double b[10] = {12.1, 24.2, 15.5, 81, 2.7, 5.9, 40, 33.3, 25.6, 4.6};
    for (int i = 0; i < 10; i++)
        cout << a[i] << "  ";
    cout << endl;
    for (int i = 0; i < 10; i++)
        cout << b[i] << "  ";
    cout << endl;
    cout << "====================================\n";
    insertionSort(a, 10);
    insertionSort(b, 10);
    for (int i = 0; i < 10; i++)
        cout << a[i] << "  ";
    cout << endl;
    for (int i = 0; i < 10; i++)
        cout << b[i] << "  ";
    cout << endl;
    return 0;
}

```

输出：

```
2  4  1  8  7  9  0  3  5  6  
12.1  24.2  15.5  81  2.7  5.9  40  33.3  25.6  4.6  
====================================
0  1  2  3  4  5  6  7  8  9  
2.7  4.6  5.9  12.1  15.5  24.2  25.6  33.3  40  81 
```



### 使用函数模板产生的歧义

#### **【例14-3】函数模板产生的歧义**

```c++
//文件:ex14_3.cpp
#include <iostream>
// sing namespace std;
template <typename T>
T max(T a, T b)
{
    return a > b ? a : b;
}
int main()
{
    //	int a =max(10.5, 20);				//错误，参数类型产生歧义
    //	double  b =max(30, 20.6);			//错误，参数类型产生歧义
    int a = max<int>(40.5, 20);       //警告，double-->int
    double b = max<double>(30, 20.6); //正确
    std::cout << a << std::endl;
    std::cout << b << std::endl;
    return 0;
}

```

输出：

```
40
30
```



## 函数模板的重载

### **【例14-4】使用函数模板重**

```c++
//文件:ex14_4.cpp
#include <iostream>
using namespace std;
template <typename T>
T add(T a, T b)
{
    return a + b;
}
template <typename T>
void add(T a[], T b[], T sum[], int n)
{
    for (int i = 0; i < n; i++)
        sum[i] = a[i] + b[i];
}
int main()
{
    int a[5] = {2, 4, 1, 8, 7};
    int b[5] = {12, 2, 15, 1, 2};
    int sum1[5];
    double c[5] = {5.3, 4.5, 3.3, 6.3, 13};
    double d[5] = {9.4, 10.5, 3.4, 5.7, 6.1};
    double sum2[5];
    cout << "10 + 20:\t" << add(10, 20) << endl;
    cout << "3.4+2.8:\t" << add(3.4, 2.8) << endl;
    add(a, b, sum1, 5);
    add(c, d, sum2, 5);
    for (int i = 0; i < 5; i++)
        cout << sum1[i] << "\t";
    cout << endl;
    for (int i = 0; i < 5; i++)
        cout << sum2[i] << "\t";
    cout << endl;
    return 0;
}

```

输出：

```
10 + 20:        30
3.4+2.8:        6.2
14      6       16      9       9
14.7    15      6.7     12      19.1
```

### **【例14-5】函数模板max函数m**

```c++
//文件:ex14_5.cpp
#include <iostream>
#include <cstring>
template <typename T>
T max(T a, T b)
{
    return a > b ? a : b;
}

char *max(char *x, char *y)
{
    return strcmp(x, y) > 0 ? x : y;
}
int main()
{
    char *p = "ABCD", *q = "EFGH";
    char *m = max(p, q);       //优先调用单独的函数，
    int a = max(10, 20);       //调用模板函数
    float b = max(10.5, 20.6); //调用模板函数
    std::cout << m << std::endl;
    std::cout << a << std::endl;
    std::cout << b << std::endl;
    return 0;
}

```

输出：

```
EFGH
20
20.6
```



## 类模板

### 类模板的定义

#### **【例14-6】定义数组类的类模板**

```c++
//文件:ex14_6.cpp
#include <iostream>
using namespace std;
template <typename T>
class MyArray
{
public:
    MyArray(int size, T initValue); //指定数组的大小和初值
    ~MyArray()
    {
        delete[] p;
    }
    T &operator[](int index) //重载运算符[]，返访问指定索引的元素
    {
        return p[index];
    }
    void show(); //显示数组中的所有元素
    void sort(); //排序
private:
    T *p;     //保存数组的其实地址
    int size; //数组的长度
};
template <class T>
MyArray<T>::MyArray(int size, T initValue)
{
    this->size = (size > 1) ? size : 1; //如果指定的size不大于1，将size值为1
    p = new T[size];                    //分配内存
    for (int i = 0; i < size; i++)      //为元素赋初值
        p[i] = initValue;
}
template <class T>
void MyArray<T>::show() //显示所有元素
{
    for (int i = 0; i < size; i++)
        cout << p[i] << " ";
    cout << endl;
}
template <class T>
void MyArray<T>::sort() //插入排序法升序排序
{
    int i, j;
    T temp;
    for (i = 1; i < size; i++)
    {
        j = i;
        temp = p[i];
        while (j > 0 && temp < p[j - 1])
        {
            p[j] = p[j - 1];
            j--;
        }
        p[j] = temp;
    }
}
int main()
{
    int nArr[10] = {89, 34, 32, 47, 15, 81, 78, 36, 63, 83};
    char cArr[10] = {'C', 'W', 'r', 'Y', 'k', 'J', 'X', 'Z', 'y', 's'};
    MyArray<int> intArray(10, 0);
    MyArray<char> charArray(10, ' ');
    intArray.show();
    charArray.show();
    for (int i = 0; i < 10; i++)
        intArray[i] = nArr[i]; //使用重载运算符[]
    for (int i = 0; i < 10; i++)
        charArray[i] = cArr[i]; //使用重载运算符[]
    intArray.show();
    intArray.sort();
    intArray.show();
    charArray.show();
    charArray.sort();
    charArray.show();
    cout << endl;
    return 0;
}

```

输出：

```
0 0 0 0 0 0 0 0 0 0 

89 34 32 47 15 81 78 36 63 83 
15 32 34 36 47 63 78 81 83 89 
C W r Y k J X Z y s 
C J W X Y Z k r s y 
```

### 类模板的默认参数值

#### **【例14-7】使用默认参数定义数组的类模板**

```c++
//文件:ex14_7.cpp
#include <iostream>
using namespace std;
template <typename T = int> //参数类型T的默认值为int
class Array
{
    T *data;
    int size;

public:
    Array(int);
    ~Array();
    T &operator[](int);
};
template <class T>
Array<T>::Array(int n)
{
    data = new T[size = n];
}
template <class T>
Array<T>::~Array()
{
    delete[] data;
}
template <class T>
T &Array<T>::operator[](int i)
{
    return data[i];
}
int main()
{
    int i;
    Array<> L1(10); //等价于Array <int> L1(10)
    Array<char> L2(20);
    for (i = 0; i < 10; i++)
        L1[i] = i;
    for (i = 0; i < 20; i++)
        L2[i] = 'A' + i;
    for (i = 0; i < 10; i++)
        cout << L1[i] << "  ";
    cout << endl;
    for (i = 0; i < 20; i++)
        cout << L2[i] << "  ";
    cout << endl;
    return 0;
}

```

输出：

```
0  1  2  3  4  5  6  7  8  9  
A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T
```



## 综合实例

### **【例14-8】折半查找函数相例14集合类模板**

```c++
//文件:ex14_8.cpp
#include <iostream>
using namespace std;
template <typename T>
int binSearch(T list[], int n, T key)
{
    int mid, low, high;
    T midvalue;
    low = 0;
    high = n - 1;
    while (low <= high) // low <= high表示整个数组尚未查找完
    {
        mid = (low + high) / 2; // 求中间元素的下标
        midvalue = list[mid];   // 取出中间元素的值
        if (key == midvalue)
            return mid; // 若找到，返回下标
        else if (key < midvalue)
            high = mid - 1; // 若key<midvalue将查找范围缩小到数组的前一半
        else
            low = mid + 1; // 否则将查找范围缩小到数组的后一半
    }
    return -1; // 没有找到返回-1
}
int main()
{
    int a[10] = {2, 3, 7, 12, 16, 35, 67, 68, 90, 98};
    char c[11] = "abcdhijklm";
    char c1 = 'h';
    int i = binSearch(a, 10, 35);
    int j = binSearch(a, 10, 36);
    int k = binSearch(c, 10, c1);
    int l = binSearch(c, 10, 'k');
    cout << i << "," << j << "," << k << "," << l << endl;
    return 0;
}

```

输出：

```
5,-1,4,7
```



```c++
//文件:ex14_9.cpp
#include <iostream>
using namespace std;
template <typename T>
class Set
{
public:
    Set();
    Set(const Set &);                 //拷贝函数
    bool find(T val) const;           //找到值为val元素返回true，否则返回false
    bool full() const;                //集合满时返回true，否则返回false
    bool empty() const;               //集合空时返回true，否则返回false
    void create(T a[], int n);        //创建集合，n是元素个数，a为各元素的值
    void display() const;             //输出集合
    int getlen() const;               //获取集合中元素个数
    void increase();                  //扩大元素中的最大个数
    Set operator+(const Set &) const; //集合的并集
    Set operator-(const Set &) const; //集合的差集
    Set operator*(const Set &) const; //集合的交集
    Set operator+(T value);           //增加一个元素
    Set operator-(T value);           //删除一个元素
    Set &operator=(const Set &);      //对集合赋值
    ~Set();

private:
    T *data;    //存放集合元素的动态内存
    int count;  //目前元素个数
    int maxlen; //元素最大个数
};
template <typename T>
Set<T>::Set() //无参构造方法初始化属性
{
    data = NULL;
    count = 0;
    maxlen = 0;
}
template <typename T>
Set<T>::Set(const Set &s) //拷贝构造方法，用s初始化新对象
{
    maxlen = s.maxlen;
    count = s.count;
    data = new T[maxlen];
    for (int i = 0; i < count; i++)
        data[i] = s.data[i];
}
template <typename T>
Set<T>::~Set()
{
    if (data != NULL)
        delete[] data;
}
template <typename T>
bool Set<T>::find(T val) const //在集合中查找值为val的元素
{
    for (int i = 0; i < count; i++)
        if (val == data[i])
            return true;
    return false;
}
template <typename T>
bool Set<T>::full() const //元素个数达到集合的最大元素数？
{
    return (maxlen == count);
}
template <typename T>
bool Set<T>::empty() const //集合中没有元素了？
{
    return (0 == count);
}
template <typename T>
void Set<T>::create(T a[], int n) //创建指定元素个数的集合，并提供初值
{
    count = n;           //初始元素个数
    maxlen = count + 20; //初始大小为元素个数加20
    data = new T[maxlen];
    for (int i = 0; i < count; i++) // 输入各元素的值
        data[i] = a[i];
}
template <typename T> //输出个元素的值
void Set<T>::display() const
{
    for (int i = 0; i < count; i++)
        cout << data[i] << " ";
    cout << endl;
}
template <typename T>
void Set<T>::increase() //增加集合最大的元素个数
{
    T *temp = new T[count]; //先将集合中个元素保存在temp中
    int i;
    for (i = 0; i < count; i++)
        temp[i] = data[i];
    delete[] data; //重新分配内存，最大元素数增加10
    maxlen += 10;
    data = new T[maxlen];
    for (i = 0; i < count; ++i) //将temp中的数据复制回来
        data[i] = temp[i];
    delete[] temp;
}
template <typename T>
Set<T> Set<T>::operator+(T value) //增加一个元素，*this本身无变化
{
    Set temp(*this);
    if (!find(value)) //如果集合里没有这个元素
    {
        if (temp.maxlen == temp.count) // 如果元素已满，先增加最大元素数
            temp.increase();
        temp.data[count] = value;
        temp.count++;
    }
    return temp;
}
template <typename T>
Set<T> Set<T>::operator-(T value) //减少一个元素，*this本身无变化
{
    Set temp(*this);
    if (!temp.empty())
    {
        for (int i = 0; i < temp.count; ++i)
            if (temp.data[i] == value) //找到要删除的元素
            {
                for (int j = i; j < count - 1; ++j) //将后面的元素前移一位
                    temp.data[j] = temp.data[j + 1];
                temp.count--;
                break;
            }
    }
    return temp;
}
template <typename T>
int Set<T>::getlen() const //返回集合中的元素个数
{
    return count;
}
template <typename T>
Set<T> Set<T>::operator+(const Set &s) const //两个集合的并集
{
    Set temp(*this);
    for (int i = 0; i < s.count; i++) //将参数s中的每个元素加到temp中
        temp = temp + s.data[i];
    return temp;
}
template <typename T>
Set<T> Set<T>::operator-(const Set &s) const //两个集合的差集
{
    Set temp(*this);
    for (int i = 0; i < s.count; i++)
        temp = temp - s.data[i];
    return temp;
}
template <typename T>
Set<T> Set<T>::operator*(const Set &s) const //两个集合的交集
{
    Set temp;
    for (int i = 0; i < count; i++)
        if (find(s.data[i])) //两个集合都有的元素
            temp = temp + s.data[i];
    return temp;
}
template <typename T>
Set<T> &Set<T>::operator=(const Set &s)
{
    delete[] data;
    maxlen = s.maxlen;
    count = s.count;
    data = new T[maxlen];
    for (int i = 0; i < count; i++)
        data[i] = s.data[i];
    return *this;
}
int main()
{
    int a1[] = {1, 2, 3, 4};
    int a2[] = {3, 4, 5, 6, 7, 8};
    Set<int> s1, s2, s3, s4, s5, s6, s7;
    s1.create(a1, 4);
    s2.create(a2, 6);
    s3 = s1 + s2;
    s4 = s1 + 10;
    s5 = s1 * s2;
    s6 = s2 - 3;
    s7 = s2 - s1;
    cout << "s1:    ";
    s1.display();
    cout << "s2:    ";
    s2.display();
    cout << "s1+s2: ";
    s3.display();
    cout << "s1+10: ";
    s4.display();
    cout << "s1*s2: ";
    s5.display();
    cout << "s2-3:  ";
    s6.display();
    cout << "s2-s1: ";
    s7.display();
    return 0;
}

```

输出：

```
s1:    1 2 3 4 
s2:    3 4 5 6 7 8 
s1+s2: 1 2 3 4 5 6 7 8 
s1+10: 1 2 3 4 10 
s1*s2: 3 4 
s2-3:  4 5 6 7 8 
s2-s1: 5 6 7 8
```



## 小结

## 习题十四



