# 第1章  C++概述

# 第2章 处理数据

# 第3章 分支结构

# 第4章 循环结构

# 第5章 数组

# 第6章 指针

# 第7章 函数初识

# 第8章 函数进阶

# 第9章 位运算符、构造类型与名称空间

# 第10章 面向对象与类

# 第11章 类的高级主题

# 第12章 类的继承

# 第13章 多态

# 第14章 模板

# 第15章 输入/输出

# 第16章 标准模板库

# 第17章 打電跡双的没計与実現

## 扫雷程序的功能

### 主要功能

### 类的设计



## 创建对话框程序并添加资源

### 安装支持 MFC的内容

### 创建基于对话框的程序

### 编辑资源



## 设计 CBlock类

### 添加CBlock类

### 为CBlock类添加属性和方法

#### Block.h

```c++
#pragma once
const int blockWidth = 16;			// 小方块的宽度
const int blockHeight = 16;		// 小方块的高宽度
//枚举BlockType为小方块的类型，也就是小方块周围的雷数; BlockState是方块的状态
enum BlockType { zero, one, two, three, four, five, six, seven, eight, ismine = 10 };
enum BlockState { original, opened, mineflag, questionflag, explod, mistakeflag };
class CSaoleiDlg;				//要用到CSaoleiDlg，加入声明
class CBlock
{
private:
	CSaoleiDlg* pSaoleiDlg;	//指定小方块是在哪个对话框中
	int row;					//在雷区的行号
	int col;					//在雷区的列号
	BlockType type;			//小方块的类型，取值在枚举BlockType中
	BlockState state;			//小方块的状态，取值在枚举BlockState中
public:
	CBlock(CSaoleiDlg* pSaoleiDlg, int row, int col);
	~CBlock();
	BlockType getType() { return type; }
	void setType(BlockType type) { this->type = type; }
	BlockState getState() { return state; }
	void setState(BlockState state) { this->state = state; }
	boolean open();		//翻开小方块
	void draw();		//显示小方块
};

```



### 定义 CBlock类的方法

#### Block.cpp

```c++
#include "pch.h"
#include "Block.h"
#include "SaoleiDlg.h"
CBlock::CBlock(CSaoleiDlg *pSaoleiDlg, int row, int col)
{
    this->pSaoleiDlg = pSaoleiDlg;
    this->row = row;
    this->col = col;
    this->type = zero;      //将周围雷数都初始化为0
    this->state = original; //刚创建的小方块都是原始状态
}
CBlock::~CBlock()
{
}
//翻开小方块，成功返回true，失败返回false
boolean CBlock::open()
{
    if (type != ismine)
    {                   //如果不是雷
        state = opened; //就翻开小方块，将状态设置为opened
        draw();         //重新显示
        return true;
    }
    else
    {                   //如果是雷
        state = explod; //将状态设置为爆炸状态explod
        draw();         //重新显示
        return false;
    }
}
//显示下方块，根基小方块的类型和状态显示不同的图标
void CBlock::draw()
{
    int x = pSaoleiDlg->getMineLeft() + col * blockWidth; //获取方块的左上角
    int y = pSaoleiDlg->getMineTop() + row * blockHeight;
    int index;
    CDC *pBackDC = pSaoleiDlg->getMemBackDC();
    CDC *pMemDC = pSaoleiDlg->getMemDC();
    CClientDC *pClientDC = pSaoleiDlg->getClientDC();
    pMemDC->SelectObject(pSaoleiDlg->getBmpBasic());
    switch (state)
    {
    case original:
        index = 15;
        break;
    case opened:
        index = type;
        break;
    case mineflag:
        index = 14;
        break;
    case questionflag:
        index = 13;
        break;
    case explod:
        index = 12;
        break;
    case mistakeflag:
        index = 11;
        break;
    }
    pBackDC->BitBlt(x, y, 16, 16, pMemDC, 0, (15 - index) * 16, SRCCOPY);
    pClientDC->BitBlt(x, y, 16, 16, pMemDC, 0, (15 - index) * 16, SRCCOPY);
}

```



## 完成扫雷对话框的初始化

### 为 CSaoleiDlg添加属性和方法

#### SaoleiDlg.h

```c++

// SaoleiDlg.h: 头文件
//

#pragma once

#include "Block.h"
const int menuHeight = 45;    //菜单与标题栏的高度
const int messageHeight = 50; //显示剩余雷数和游戏用时区域的高度
const int frameWidth = 10;    //界面边框的宽度
const int mineBorder = 4;     //雷区与边框的间隙

// CSaoleiDlg 对话框
class CSaoleiDlg : public CDialogEx
{
private:
    //在选择游戏级别后，以下属性要重新赋值，在方法initData2中初始换
    int m_nRows;      //雷区的行数
    int m_nCols;      //雷区列数
    int m_nMines;     //雷数
    int m_nLevel;     // 0:初级， 1：中级，2：高级，3自定义
    int m_nWinWid;    //窗口宽度，通过计算得到
    int m_nWinHigh;   //窗口高度，通过计算得到
    int m_nMinesLeft; //雷区左上角像素坐标，通过计算得到
    int m_nMinesTop;  //雷区左上角像素坐标，通过计算得到
    //在重新开始时，以下属性要重新赋值，在方法initData1中初始换
    int m_nMineRemained;    //还未找到的雷数	以下三个是扫雷过程参数
    int m_nFinished;        //已经翻开的格数
    int m_nTimeUsed;        //已用时间
    CBlock *blocks[50][50]; //小方块指针数组，方块最多50*50
    //以下属性会一直保持不变，在initDialog中初始化
    CBitmap m_bmpBasic;  //包含基本图标的位图
    CBitmap m_bmpFace;   //包含表情图标的位图
    CBitmap m_bmpNumber; //包含数字图标的位图
    CDC m_memDC;         //用于保存BASIC、NUMBER或FACE位图，用于复制到其他DC中
    CDC m_memBackDC;     //显示的图像在内现存保留一份，以备界面失效时重新刷新
    CClientDC *clientDC; //用于在界面显示
    bool m_bGameStart;   // false：未开始，true：开始
    bool m_bGameStoped;  // false：未结束，true：结束（成功或失败均结束）
    // 构造
public:
    CSaoleiDlg(CWnd *pParent = nullptr); // 标准构造函数
    CBitmap *getBmpBasic() { return &m_bmpBasic; }
    CDC *getMemDC() { return &m_memDC; }
    CDC *getMemBackDC() { return &m_memBackDC; }
    CClientDC *getClientDC() { return clientDC; }
    int getMineLeft() { return m_nMinesLeft; }
    int getMineTop() { return m_nMinesTop; }
    void initData1(int mines, int rows, int cols, int level); //初始化基本参数
    void initData2();                                         //初始化游戏过程属性
    void init3();                                             //与设置对话框大小，显示有关的
    void DrawMineField();                                     //画出雷区
    void DrawMessage();                                       //画出剩余雷数、用时区
    void DrawFace(int Type);                                  //显示表情图标
    void DrawMineRemained();                                  //显示剩余雷数
    void DrawTimeUsed();                                      //显示用时
    void Win();
    void Lose(int row, int col);
    void Search(int row, int col);

// 对话框数据
#ifdef AFX_DESIGN_TIME
    enum
    {
        IDD = IDD_SAOLEI_DIALOG
    };
#endif

protected:
    virtual void DoDataExchange(CDataExchange *pDX); // DDX/DDV 支持

    // 实现
protected:
    HICON m_hIcon;

    // 生成的消息映射函数
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    DECLARE_MESSAGE_MAP()
public:
    //    afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    //    afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
    afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnTimer(UINT_PTR nIDEvent);
    afx_msg void OnBasic();
    afx_msg void OnCustomize();
    afx_msg void OnEnhanced();
    afx_msg void OnExit();
    afx_msg void OnIntermediate();
};

```



### 定义 CSaoleiDlg的方法

#### SaoleiDlg.cpp

```c++

// SaoleiDlg.cpp: 实现文件
//
#include "pch.h"
#include "framework.h"
#include "Saolei.h"
#include "SaoleiDlg.h"
#include "afxdialogex.h"
#include <mmSystem.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

// CSaoleiDlg 对话框

CSaoleiDlg::CSaoleiDlg(CWnd *pParent /*=nullptr*/)
    : CDialogEx(IDD_SAOLEI_DIALOG, pParent)
{
    m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CSaoleiDlg::DoDataExchange(CDataExchange *pDX)
{
    CDialogEx::DoDataExchange(pDX);
}

BEGIN_MESSAGE_MAP(CSaoleiDlg, CDialogEx)
ON_WM_PAINT()
ON_WM_QUERYDRAGICON()
//    ON_WM_NCLBUTTONUP()
// ON_WM_NCLBUTTONUP()
ON_WM_LBUTTONUP()
ON_WM_RBUTTONDOWN()
ON_WM_TIMER()
ON_COMMAND(ID_BASIC, &CSaoleiDlg::OnBasic)
ON_COMMAND(ID_CUSTOMIZE, &CSaoleiDlg::OnCustomize)
ON_COMMAND(ID_ENHANCED, &CSaoleiDlg::OnEnhanced)
ON_COMMAND(ID_EXIT, &CSaoleiDlg::OnExit)
ON_COMMAND(ID_INTERMEDIATE, &CSaoleiDlg::OnIntermediate)
END_MESSAGE_MAP()

// CSaoleiDlg 消息处理程序

BOOL CSaoleiDlg::OnInitDialog()
{
    CDialogEx::OnInitDialog();

    // 设置此对话框的图标。  当应用程序主窗口不是对话框时，框架将自动
    //  执行此操作
    SetIcon(m_hIcon, TRUE);  // 设置大图标
    SetIcon(m_hIcon, FALSE); // 设置小图标

    // TODO: 在此添加额外的初始化代码
    m_bmpBasic.LoadBitmap(IDB_BASIC);
    m_bmpFace.LoadBitmap(IDB_FACE);
    m_bmpNumber.LoadBitmap(IDB_NUMBER);
    CDC *pDC = GetDC();
    m_memDC.CreateCompatibleDC(pDC);
    m_memBackDC.CreateCompatibleDC(pDC);
    clientDC = new CClientDC(this);
    initData1(10, 10, 10, 0);
    initData2();

    return TRUE; // 除非将焦点设置到控件，否则返回 TRUE
}

// 如果向对话框添加最小化按钮，则需要下面的代码
//  来绘制该图标。  对于使用文档/视图模型的 MFC 应用程序，
//  这将由框架自动完成。

void CSaoleiDlg::OnPaint()
{
    static int f = 0;
    if (IsIconic())
    {
        CPaintDC dc(this); // 用于绘制的设备上下文

        SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

        // 使图标在工作区矩形中居中
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // 绘制图标
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        if (f == 0)
        {
            f = 1;
            init3();
        }
        else
        {
            clientDC->BitBlt(0, 0, m_nWinWid, m_nWinHigh, &m_memBackDC, 0, 0, SRCCOPY);
        }
        CDialogEx::OnPaint();
    }
}

//当用户拖动最小化窗口时系统调用此函数取得光标
//显示。
HCURSOR CSaoleiDlg::OnQueryDragIcon()
{
    return static_cast<HCURSOR>(m_hIcon);
}

void CSaoleiDlg::initData1(int mines, int rows, int cols, int level)
{
    m_nMines = mines;
    m_nRows = rows;
    m_nCols = cols;
    m_nLevel = level;
    m_nMinesTop = 2 * frameWidth + messageHeight + mineBorder;
    m_nMinesLeft = frameWidth + mineBorder;
    m_nWinHigh = menuHeight + messageHeight + m_nRows * blockHeight + 3 * frameWidth + 2 * mineBorder + 14;
    m_nWinWid = m_nCols * blockWidth + 2 * frameWidth + 2 * mineBorder + 14;
}
//重新开始需要改变的属性，如m_nTimeUsed，创建方块，布雷
void CSaoleiDlg::initData2()
{
    int i, j, k, l;
    for (i = 0; i < m_nRows; i++) // 创建多有的block
        for (int j = 0; j < m_nCols; j++)
            blocks[i][j] = new CBlock(this, i, j);
    m_nFinished = 0;
    m_nTimeUsed = 0;
    m_nMineRemained = m_nMines;
    m_bGameStart = false;
    m_bGameStoped = false;
    srand(time(NULL));        //利用时间产生随机数种子
    int number = 0;           //已布雷数
    while (number < m_nMines) //布雷
    {
        i = rand() % m_nRows;                  //获取随机行坐标
        j = rand() % m_nCols;                  //获取随机列坐标
        if (blocks[i][j]->getType() != ismine) //如果该位置不是雷
        {
            blocks[i][j]->setType(ismine); //将该小方块设置为雷
            number++;                      //已布雷数加1
        }
    }
    //求每个单元周围的雷数
    for (i = 0; i < m_nRows; i++)
    {
        for (j = 0; j < m_nCols; j++)
        {
            if (blocks[i][j]->getType() != ismine) //不是雷的单元格才计算
            {
                number = 0;
                for (k = i - 1; k <= i + 1; k++) //在相邻的方块循环
                {
                    if ((k >= 0) && (k < m_nRows)) //判断是否越界
                    {
                        for (l = j - 1; l <= j + 1; l++)
                        {
                            if ((l >= 0) && (l < m_nCols)) //判断是否越界
                            {
                                if (blocks[k][l]->getType() == ismine) //是雷
                                    number++;
                            }
                        }
                    }
                }
                blocks[i][j]->setType((BlockType)(number));
            }
        }
    }
    if (m_bGameStart)
        KillTimer(0);
}
void CSaoleiDlg::init3()
{
    this->SetWindowPos(0, 0, 0, m_nWinWid, m_nWinHigh, SWP_NOMOVE | SWP_NOZORDER);
    Invalidate(false);
    CDC *pDC = GetDC();
    CBitmap m_bmpMem;
    m_bmpMem.CreateCompatibleBitmap(pDC, m_nWinWid, m_nWinHigh);
    m_memBackDC.SelectObject(&m_bmpMem);
    m_memBackDC.SetBkColor(GetSysColor(COLOR_3DFACE));
    CBrush brush;
    brush.CreateSolidBrush(GetSysColor(COLOR_3DFACE));
    m_memBackDC.SelectObject(&brush);
    m_memBackDC.PatBlt(0, 0, m_nWinWid, m_nWinHigh, PATCOPY);
    DrawMessage();
    DrawMineField();
}

void CSaoleiDlg::DrawMineField()
{
    int i, j;
    int left = frameWidth;
    int top = 2 * frameWidth + messageHeight;
    int width = 2 * mineBorder + m_nCols * blockWidth;
    int height = 2 * mineBorder + m_nRows * blockHeight;
    clientDC->Draw3dRect(left, top, width, height, RGB(160, 160, 160), RGB(255, 255, 255));
    m_memBackDC.Draw3dRect(left, top, width, height,
                           RGB(160, 160, 160), RGB(255, 255, 255));
    for (i = 0; i < m_nRows; i++)
    {
        for (j = 0; j < m_nCols; j++)
            blocks[i][j]->draw(); //调用CBlock类的draw方法显示小方块
    }
}
void CSaoleiDlg::DrawMessage()
{
    int width = 2 * mineBorder + m_nCols * blockWidth; //信息区的宽度与雷区的宽度一致
    clientDC->Draw3dRect(frameWidth, frameWidth, width, messageHeight,
                         RGB(160, 160, 160), RGB(255, 255, 255));
    m_memBackDC.Draw3dRect(frameWidth, frameWidth, width, messageHeight,
                           RGB(160, 160, 160), RGB(255, 255, 255));
    DrawFace(4); //索引为4的图标是
    DrawMineRemained();
    DrawTimeUsed();
}
void CSaoleiDlg::DrawFace(int type)
{
    m_memDC.SelectObject(&m_bmpFace);
    m_memBackDC.BitBlt(m_nWinWid / 2 - 12, frameWidth + 10, 24, 24,
                       &m_memDC, 0, type * 24, SRCCOPY);
    clientDC->BitBlt(m_nWinWid / 2 - 12, frameWidth + 10, 24, 24,
                     &m_memDC, 0, type * 24, SRCCOPY);
}
void CSaoleiDlg::DrawMineRemained()
{
    m_memDC.SelectObject(&m_bmpNumber);
    int n1, n2, n3;
    if (m_nMineRemained >= 0) //如果标记的雷数太多，剩余雷数可能
    {
        n1 = m_nMineRemained / 100;
        n2 = m_nMineRemained / 10 - 10 * n1;
        n3 = m_nMineRemained % 10;
    }
    else if (m_nMineRemained > -100) //超高-99则不再处理
    {
        n1 = 11;
        n2 = -m_nMineRemained / 10;
        n3 = -m_nMineRemained % 10;
    }
    else
        return;
    m_memBackDC.BitBlt(frameWidth + 10, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n1) * 23, SRCCOPY);
    m_memBackDC.BitBlt(frameWidth + 10 + 12, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n2) * 23, SRCCOPY);
    m_memBackDC.BitBlt(frameWidth + 10 + 24, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n3) * 23, SRCCOPY);
    clientDC->BitBlt(frameWidth + 10, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n1) * 23, SRCCOPY);
    clientDC->BitBlt(frameWidth + 10 + 12, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n2) * 23, SRCCOPY);
    clientDC->BitBlt(frameWidth + 10 + 24, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n3) * 23, SRCCOPY);
}
void CSaoleiDlg::DrawTimeUsed()
{
    m_memDC.SelectObject(&m_bmpNumber);
    int n1, n2, n3;
    n1 = m_nTimeUsed / 100;
    n2 = m_nTimeUsed / 10 - 10 * n1;
    n3 = m_nTimeUsed % 10;
    m_memBackDC.BitBlt(m_nWinWid - frameWidth - 60, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n1) * 23, SRCCOPY);
    m_memBackDC.BitBlt(m_nWinWid - frameWidth - 48, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n2) * 23, SRCCOPY);
    m_memBackDC.BitBlt(m_nWinWid - frameWidth - 36, frameWidth + 10, 12, 23,
                       &m_memDC, 0, (11 - n3) * 23, SRCCOPY);
    clientDC->BitBlt(m_nWinWid - frameWidth - 60, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n1) * 23, SRCCOPY);
    clientDC->BitBlt(m_nWinWid - frameWidth - 48, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n2) * 23, SRCCOPY);
    clientDC->BitBlt(m_nWinWid - frameWidth - 36, frameWidth + 10, 12, 23,
                     &m_memDC, 0, (11 - n3) * 23, SRCCOPY);
}

void CSaoleiDlg::Win()
{
    DrawFace(1); //胜利的表情
    m_bGameStoped = true;
    m_bGameStart = false;
    KillTimer(0);
    PlaySound(MAKEINTRESOURCE(ID_WAVE_WIN), AfxGetResourceHandle(), SND_ASYNC | SND_RESOURCE);
}
void CSaoleiDlg::Lose(int row, int col)
{
    int i, j;
    for (i = 0; i < m_nRows; i++)
        for (j = 0; j < m_nCols; j++)
        {
            if ((blocks[i][j]->getType() == ismine) //把所有是雷，但未标记的显示出来
                && (blocks[i][j]->getState() != mineflag))
            {
                blocks[i][j]->setState(opened);
                blocks[i][j]->draw();
            }
            if ((blocks[i][j]->getType() != ismine) //把不是雷，标记错的显示出来
                && (blocks[i][j]->getState() == mineflag))
            {
                blocks[i][j]->setState(mistakeflag);
                blocks[i][j]->draw();
            }
        }
    blocks[row][col]->setState(explod);
    blocks[row][col]->draw();
    DrawFace(2); //失败的表情
    m_bGameStoped = true;
    m_bGameStart = false;
    KillTimer(0);
    PlaySound(MAKEINTRESOURCE(ID_WAVE_LOSE), AfxGetResourceHandle(), SND_ASYNC | SND_RESOURCE);
}
void CSaoleiDlg::Search(int row, int col)
{
    int i, j;
    CClientDC dc(this);
    for (i = row - 1; i <= row + 1; i++) //在前后三行内
    {
        if ((i >= 0) && (i < m_nRows)) //行没有超出雷区的范围
        {
            for (j = col - 1; j <= col + 1; j++) //在前后三列内
            {
                if ((j >= 0) && (j < m_nCols)) //列没有超出雷区的范围
                {
                    if (blocks[i][j]->getState() == original)
                    {
                        blocks[i][j]->setState(opened); //翻开
                        blocks[i][j]->draw();
                        m_nFinished++;                       //翻开雷数加1
                        if (blocks[i][j]->getType() == zero) //周围无雷，继续搜索
                            Search(i, j);
                    }
                }
            }
        }
    }
}

void CSaoleiDlg::OnLButtonUp(UINT nFlags, CPoint point)
{
    // TODO: 在此添加消息处理程序代码和/或调用默认值
    int i, j;
    //鼠标位于重新开始的表情图标上
    if ((point.x > m_nWinWid / 2 - 12) && (point.x < m_nWinWid / 2 - 12 + 24) && (point.y > frameWidth + 10) && (point.y < frameWidth + 10 + 24))
    {
        initData2();
        DrawMineField();
        DrawMessage();
    }
    if ((point.x > m_nMinesLeft) && (point.x < m_nMinesLeft + 16 * m_nCols) && (point.y > m_nMinesTop) && (point.y < m_nMinesTop + 16 * m_nRows) && (!m_bGameStoped)) // //在雷区,且没有扫雷还没结束
    {
        if (!m_bGameStart)
        {
            m_bGameStart = true;
            SetTimer(0, 1000, NULL);
        }
        i = (point.y - m_nMinesTop) / 16;
        j = (point.x - m_nMinesLeft) / 16;
        if (blocks[i][j]->getState() == original)
        {
            if (blocks[i][j]->getType() == ismine) //失败，结束
            {
                Lose(i, j);
            }
            else
            {
                blocks[i][j]->setState(opened);
                blocks[i][j]->draw();
                m_nFinished++;
                if (blocks[i][j]->getType() == zero) //如果周围无雷，翻开周围的格
                {
                    Search(i, j);
                }
                if (m_nFinished == m_nRows * m_nCols - m_nMines)
                {
                    Win();
                }
            }
        }
    }

    CDialogEx::OnLButtonUp(nFlags, point);
}

void CSaoleiDlg::OnRButtonDown(UINT nFlags, CPoint point)
{
    // TODO: 在此添加消息处理程序代码和/或调用默认值
    // TODO: Add your message handler code here and/or call default
    int i, j, k, l;
    int tagnumber;
    if ((point.x < m_nMinesLeft) || (point.x > m_nMinesLeft + 16 * m_nCols) || (point.y < m_nMinesTop) || (point.y > m_nMinesTop + 16 * m_nRows) || (m_bGameStoped)) //不在雷区,或扫雷已结束
        return;
    i = (point.y - m_nMinesTop) / 16;
    j = (point.x - m_nMinesLeft) / 16;
    switch (blocks[i][j]->getState()) //根据不同的状态做不同的处理
    {
    case original:                        //原始状态
        blocks[i][j]->setState(mineflag); //标记为雷
        blocks[i][j]->draw();
        m_nMineRemained--;
        DrawMineRemained();
        break;
    case mineflag:                            //标记为雷的状态
        blocks[i][j]->setState(questionflag); //标记为问号
        blocks[i][j]->draw();
        m_nMineRemained++;
        DrawMineRemained();
        break;
    case questionflag:                    //标记为问号状态
        blocks[i][j]->setState(original); //取消标记
        blocks[i][j]->draw();
        break;
    case opened: //翻开状态
        tagnumber = 0;
        for (k = i - 1; k <= i + 1; k++)
        {
            for (l = j - 1; l <= j + 1; l++)
            {
                if ((k >= 0) && (k < m_nRows) && (l >= 0) && (l < m_nCols) && (blocks[k][l]->getState() == mineflag))
                    tagnumber++;
            }
        }
        if (tagnumber < blocks[i][j]->getType()) //如果周围雷数都已经标记出来
            return;
        for (k = i - 1; k <= i + 1; k++) //将与其邻接得格翻开
        {
            for (l = j - 1; l <= j + 1; l++)
            {
                if ((k >= 0) && (k < m_nRows) && (l >= 0) && (l < m_nCols) && (blocks[k][l]->getState() == original))
                {
                    if (blocks[k][l]->getType() != ismine) // 如果不是雷，翻开
                    {
                        blocks[k][l]->setState(opened);
                        blocks[k][l]->draw();
                        m_nFinished++;
                        if (m_nFinished == m_nRows * m_nCols - m_nMines) //胜利
                        {
                            Win();
                        }
                        else if (blocks[k][l]->getType() == zero) //翻开周边
                        {
                            Search(k, l);
                        }
                    }
                    else //以前标记错了，失败
                    {
                        Lose(k, l);
                    }
                }
            }
        }
        break;
    }

    CDialogEx::OnRButtonDown(nFlags, point);
}

void CSaoleiDlg::OnTimer(UINT_PTR nIDEvent)
{
    // TODO: 在此添加消息处理程序代码和/或调用默认值
    if (m_nTimeUsed < 999)
    {
        m_nTimeUsed++;
        DrawTimeUsed();
    }
    PlaySound(MAKEINTRESOURCE(ID_WAVE_TIME), AfxGetResourceHandle(), SND_ASYNC | SND_RESOURCE);
    CDialogEx::OnTimer(nIDEvent);
}

void CSaoleiDlg::OnBasic()
{
    // TODO: 在此添加命令处理程序代码
    initData1(10, 10, 10, 0);
    initData2();
    init3();
}

void CSaoleiDlg::OnCustomize()
{
    // TODO: 在此添加命令处理程序代码
}

void CSaoleiDlg::OnEnhanced()
{
    // TODO: 在此添加命令处理程序代码
    // TODO: Add your command handler code here
    initData1(99, 16, 30, 2);
    initData2();
    init3();
}

void CSaoleiDlg::OnExit()
{
    // TODO: 在此添加命令处理程序代码
    SendMessage(WM_CLOSE);
}

void CSaoleiDlg::OnIntermediate()
{
    // TODO: 在此添加命令处理程序代码
    // TODO: Add your command handler code here
    initData1(40, 16, 16, 1);
    initData2();
    init3();
}

```



## 实现扫雷功能

### 添加松开鼠标的消息响应函数

### 添加 Win、Lose、Search 方法

#### Saolei.h

```c++
// Saolei.h: PROJECT_NAME 应用程序的主头文件

#pragma once
#ifndef __AFXWIN_H__
#error "在包含此文件之前包含 'pch.h' 以生成 PCH"
#endif

#include "resource.h" // 主符号

// CSaoleiApp:
// 有关此类的实现，请参阅 Saolei.cpp

class CSaoleiApp : public CWinApp
{
public:
    CSaoleiApp();

    // 重写
public:
    virtual BOOL InitInstance();

    // 实现

    DECLARE_MESSAGE_MAP()
};

extern CSaoleiApp theApp;

```

### 添加鼠标右键响应函数



## 其他功能

### 计时功能

### 选择游戏难度

### 加人声音



## 小结

## 习题十七

