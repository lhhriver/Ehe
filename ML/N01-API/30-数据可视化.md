
# 数据可视化

## 特征相关图


```python
from jupyterthemes import jtplot
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from sklearn.datasets import load_breast_cancer
breast_cancer = load_breast_cancer()
df = pd.DataFrame(breast_cancer.data, columns=breast_cancer.feature_names)

df = df[[
    'mean radius', 'mean texture', 'mean perimeter', 'mean area',
    'mean smoothness', 'mean compactness', 'mean concavity',
    'mean concave points', 'mean symmetry', 'mean fractal dimension',
    'radius error', 'texture error', 'perimeter error', 'area error'
]]

%matplotlib inline

jtplot.style()

plt.figure(figsize=(12, 12), dpi=200)
sns.heatmap(df.corr(),
            xticklabels=df.corr().columns,
            yticklabels=df.corr().columns,
            cmap='RdYlGn',
            center=0,
            annot=True)

# Decorations
plt.title('Correlogram of mtcars', fontsize=22)
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()
```


![png](images/output_71_0.png)



```python
import seaborn as sns
df = sns.load_dataset('iris')

# Plot
plt.figure(figsize=(10, 10), dpi=80)
sns.pairplot(df,
             kind="scatter",
             hue="species",
             plot_kws=dict(s=80, edgecolor="white", linewidth=2.5))
plt.show()
```


    <Figure size 800x800 with 0 Axes>



![png](images/output_72_1.png)


## 特征条形图

多个


```python
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression

breast_cancer = load_breast_cancer()

data = pd.DataFrame(breast_cancer.data, columns=breast_cancer.feature_names)
data["target"] = breast_cancer.target

columns = data.columns[0:3]

for i, col in enumerate(columns):
    plt.figure(num=i, figsize=(8, 6), dpi=80)
    sns.distplot(data.loc[data['target'] == 0, col],
                 color="dodgerblue",
                 label="0",
                 hist_kws={'alpha': .7},
                 kde_kws={'linewidth': 3})

    sns.distplot(data.loc[data['target'] == 1, col],
                 color="orange",
                 label="1",
                 hist_kws={'alpha': .7},
                 kde_kws={'linewidth': 3})
    # plt.ylim(0, 1)

    plt.title('Density Plot of %s by %s Type' % (col, "target"), fontsize=22)
    plt.legend()
    plt.show()
```


![png](images/output_75_0.png)



![png](images/output_75_1.png)



![png](images/output_75_2.png)


单个


```python
plt.figure(figsize=(8, 6), dpi=80)
sns.distplot(data.loc[data['target'] == 0, "mean radius"],
             color="dodgerblue",
             label="0",
             hist_kws={'alpha': .7},
             kde_kws={'linewidth': 3})

sns.distplot(data.loc[data['target'] == 1, "mean radius"],
             color="orange",
             label="1",
             hist_kws={'alpha': .7},
             kde_kws={'linewidth': 3})
plt.ylim(0, 0.35)

# Decoration
plt.title('Density Plot of City Mileage by Vehicle Type', fontsize=22)
plt.legend()
plt.show()
```


![png](images/output_77_0.png)


## 特征重要性


```python
import numpy as np
from sklearn.datasets import load_breast_cancer
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split

breast_cancer = load_breast_cancer()
x_train, x_test, y_train, y_test = train_test_split(breast_cancer.data,
                                                    breast_cancer.target,
                                                    test_size=0.3,
                                                    random_state=33)

model = RandomForestClassifier()
model.fit(x_train, np.ravel(y_train.astype("int")))

feature_names = breast_cancer.feature_names

feature_importances = sorted(zip(feature_names, model.feature_importances_),
                             key=lambda x: x[1],
                             reverse=True)

feature_importances
```




    [('worst perimeter', 0.18620499720166467),
     ('worst concave points', 0.1724040979991729),
     ('mean concavity', 0.12139581096137361),
     ('worst radius', 0.11722628241351166),
     ('mean radius', 0.10274405729905142),
     ('area error', 0.06258149216927737),
     ('worst concavity', 0.059125708110069265),
     ('worst area', 0.04198900033806815),
     ('mean texture', 0.02042974054036658),
     ('mean area', 0.013758839736876239),
     ('mean perimeter', 0.012932128072494936),
     ('worst texture', 0.01258086052250248),
     ('mean smoothness', 0.01145304304875531),
     ('worst compactness', 0.010621629664887607),
     ('fractal dimension error', 0.00943917408309775),
     ('mean symmetry', 0.006992660719017956),
     ('worst fractal dimension', 0.005903612475538661),
     ('radius error', 0.005814661084451121),
     ('compactness error', 0.004715078731814143),
     ('concavity error', 0.003991494322523306),
     ('worst symmetry', 0.003367296095990084),
     ('texture error', 0.002831428613893433),
     ('perimeter error', 0.002826671247274786),
     ('mean compactness', 0.0026149280031858707),
     ('symmetry error', 0.002127236624334952),
     ('mean concave points', 0.0018283290991729182),
     ('concave points error', 0.0008680793508828308),
     ('smoothness error', 0.0008515190415062046),
     ('worst smoothness', 0.00038014242924384157),
     ('mean fractal dimension', 0.0)]




```python
feature_importances = model.feature_importances_
n = 10
# n = feature_names.shape[0]
index = np.argsort(-feature_importances)[0:n]

feature_names = breast_cancer.feature_names
feature_names = feature_names[index]
```


```python
# 竖图
plt.figure(figsize=(12, 8))
plt.title("feature_importances")
plt.bar(range(n), feature_importances[index], color="r", align="center")
plt.xticks(range(n), feature_names, rotation=45)
plt.xlim([-1, n])

# Annotate Text
for n, value in zip(range(feature_names.shape[0]), feature_importances[index]):
    plt.text(n, value + 0.002, round(value, 4), horizontalalignment='center')

plt.show()
```


![png](images/output_81_0.png)



```python
plt.figure(figsize=(12, 8))
plt.barh(range(n), feature_importances[index], color="r", align="center")
plt.yticks(range(n), feature_names, rotation=0)
plt.ylim([-1, n])
plt.xlabel("feature_importances")
plt.show()
```


![png](images/output_82_0.png)



```python

```

## 混淆矩阵


```python
from jupyterthemes import jtplot
import numpy as np
from sklearn import svm, datasets
from sklearn.svm import SVC
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix

import matplotlib.pyplot as plt
%matplotlib inline

jtplot.style()

iris = datasets.load_iris()
class_names = iris.target_names

x_train, x_test, y_train, y_test = train_test_split(iris.data,
                                                    iris.target,
                                                    random_state=0)

classifier = SVC(kernel='linear', C=0.01)
classifier.fit(x_train, y_train)
y_pred = classifier.predict(x_test)

# Compute confusion matrix
cm = confusion_matrix(y_test, y_pred)
# cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]  # 归一化
print(cm)

plt.figure(figsize=(10, 10))
plt.imshow(cm, interpolation='nearest', cmap=plt.cm.Blues)
plt.title('Confusion matrix')
plt.colorbar()
plt.xticks(np.arange(len(class_names)), class_names, rotation=0)
plt.yticks(np.arange(len(class_names)), class_names)

thresh = cm.max() / 2.
for i in range(cm.shape[0]):
    for j in range(cm.shape[1]):
        plt.text(j,
                 i,
                 cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

# plt.tight_layout()
plt.ylabel('True label')
plt.xlabel('Predicted label')
```

    [[13  0  0]
     [ 0 10  6]
     [ 0  0  9]]





    Text(0.5, 0, 'Predicted label')




![png](images/output_85_2.png)


## ROC曲线


```python
import numpy as np
from sklearn.datasets import load_breast_cancer
from sklearn.linear_model import LogisticRegression

from sklearn.model_selection import train_test_split
from sklearn.metrics import roc_curve, auc
import matplotlib.pyplot as plt
%matplotlib inline

breast_cancer = load_breast_cancer()

x_train, x_test, y_train, y_test = train_test_split(breast_cancer.data,
                                                    breast_cancer.target,
                                                    test_size=0.3,
                                                    random_state=33)

lr = LogisticRegression()
lr.fit(x_train, np.ravel(y_train.astype("int")))

fpr, tpr, thresholds = roc_curve(y_test,
                                 lr.predict_proba(x_test)[:, 1],
                                 pos_label=1)

plt.figure(figsize=(8, 6))
plt.plot(fpr,
         tpr,
         color='darkorange',
         lw=2,
         label='ROC curve (area = %0.2f)' % auc(fpr, tpr))
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')

plt.title('Receiver operating characteristic example')
plt.xlabel('False Positive Rate')  # 坐标轴标签
plt.ylabel('True Positive Rate')  # 坐标轴标签
plt.ylim(0, 1.01)  # 边界范围
plt.xlim(0, 1.0)  # 边界范围
plt.legend(loc="lower right")  # 图例
plt.show()  # 显示作图结果
```


![png](images/output_87_0.png)



```python
import numpy as np
import matplotlib.pyplot as plt
from itertools import cycle

from sklearn import datasets
from sklearn.svm import SVC
from sklearn.metrics import roc_curve, auc
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from scipy import interp

%matplotlib inline

# Import some data to play with
iris = datasets.load_iris()
X = iris.data
y = iris.target

# Binarize the output
y = label_binarize(y, classes=[0, 1, 2])
n_classes = y.shape[1]

# Add noisy features to make the problem harder
random_state = np.random.RandomState(0)
n_samples, n_features = X.shape
X = np.c_[X, random_state.randn(n_samples, 200 * n_features)]

# shuffle and split training and test sets
X_train, X_test, y_train, y_test = train_test_split(X,
                                                    y,
                                                    test_size=.5,
                                                    random_state=0)

# Learn to predict each class against the other
classifier = OneVsRestClassifier(
    SVC(kernel='linear', probability=True, random_state=random_state))

y_score = classifier.fit(X_train, y_train).decision_function(X_test)

# Compute ROC curve and ROC area for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y_test[:, i], y_score[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Compute micro-average ROC curve and ROC area
fpr["micro"], tpr["micro"], _ = roc_curve(y_test.ravel(), y_score.ravel())
roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])

plt.figure(figsize=(8, 6))
plt.plot(fpr[2],
         tpr[2],
         color='darkorange',
         lw=2,
         label='ROC curve (area = %0.2f)' % roc_auc[2])
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()
```


![png](images/output_88_0.png)