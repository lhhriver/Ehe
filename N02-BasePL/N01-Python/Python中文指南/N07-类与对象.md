#  【基础】类的理解与使用

##  通俗理解类

类（英文名 class），是具有相同特性（属性）和行为（方法）的对象（实例）的抽象模板。

从定义上来理解类，是一件非常吃力的事情，特别是对那些没有任何基础的初学者。

下面我举例来说明类中一些关键术语都是什么意思：

- 类：动物属于一个类，植物属于一个类
- 实例：猫和狗都属于同一类，就是动物类，那么猫和狗是动物类的实例/对象。
- 属性：类中所有的变量，都叫做属性。
- 方法：类中的所有函数，都叫做方法。

类与对象的关系就如模具和铸件的关系，类的实例化的结果就是对象，而对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为（方法）的对象。

##  如何定义类

定义一个类，使用的是 class 关键字

下边我定义了一个 Animal 的类

```python
class Animal:
    age = 0
    def __init__(self, name):
        self.name = name

    def run(self):
        print(f"{self.name} 跑起来了")
```

其中

- `Animal` 是类名
- `__init__` 是构造函数，用于实例的初始化
- `self.name` 是实例属性，`age`  是类属性
- `run` 是方法，第一个参数 self 是什么意思呢？这个咱后面再讲。

除了上面这种写法外

```python
# 第一种写法
class Animal:
  ...
```

还有另外两种写法，与之是等价的

```python
# 第二种写法
class Animal():
  ...
  
# 第二种写法
class Animal(object):
  ...
```

因为在 Python 3 中，无论你是否显示继承自 object，Python 解释器都会默认你继承 object ，这是新式类的写法，与之对应的是 Python 2 的经典类写法（Python 2 已经远去，无需要再了解经典类写法）。

##  如何实例化

定义了类之后，就可以通过下边的写法实例化它，并访问属性，调用方法

```python
>>> class Animal:
...     def __init__(self, name):
...         self.name = name
...     def run(self):
...         print(f"{self.name} 跑起来了")
...
>>>
>>> dog=Animal(name="小黑")  # 实例化出 dog 对象
```

在实例化时传入的参数 `name="小黑"` 传进入到构造函数 `__init__` 中，最终赋值 `self.name` 成为实例的属性。

##  方法的调用

实例化成对象后，如果访问实例属性，可以用 `对象.属性名` 进行访问。

```python
>>> dog=Animal(name="小黑")
>>> dog.name  # 访问属性
'小黑'
```

如果要调用方法，有两种方法

1. 通过 `对象.方法名`：使用这种方法，在定义方法时 self 就代表对象（dog），调用时无需再传入了。

```python
>>> dog=Animal(name="小黑")
>>> dog.run()  # 调用方法
小黑 跑起来了
```

2. 通过 `类.方法名`：使用这种方法，self 参数要传入实例对象

```python
>>> dog=Animal(name="小黑")
>>> Animal.run(dog)
小黑 跑起来了
```

#  【基础】静态方法与类方法

##  写法上的差异

类的方法可以分为：

1. 静态方法：有 `staticmethod` 装饰的函数
2. 类方法：有 `classmethod` 装饰的函数
3. 实例方法：没有任何装饰器的普通函数

举个例子，如下这段代码中，`run` 普通的实例方法，`eat`  是静态方法，`jump` 是类方法。

```python
class Animal:
    def __init__(self, name):
        self.name = name
        
    def run(self):
        print(f"{self.name}跑起来啦")
        
    @staticmethod
    def eat():
        print("正在吃饭...")
        
    @classmethod
    def jump(cls, name):
        print(f"{name}跳起来啦")
```

这三种方法，在写法有很大的区别：

1、普通的实例方法，在定义时，他的第一个方法固定是 self，如果是从实例调用，那么 self 参数 不需要传入，如果是通过类调用，那么 self 要传入已经实例化的对象。

```python
>>> dog=Animal(name="小黑")
>>> dog.run()
小黑跑起来啦
>>> Animal.run(dog)
小黑跑起来啦
```

2、静态方法，在定义时，不需要 self 参数。

```python
>>> dog=Animal(name="小黑")
>>> dog.eat()
正在吃饭...
>>> Animal.eat()
正在吃饭...
```

3、类方法，在定义时，第一个参数固定是 cls，为 class 的简写，代表类本身。不管是通过实例还是类调用类方法，都不需要传入 cls 的参数。

```python
>>> dog=Animal(name="小黑")
>>> dog.jump("小黑")
小黑跳起来啦
>>> Animal.jump("小黑")
小黑跳起来啦
```

##  方法与函数区别

在前面，我们很经常提到方法和函数，为免有同学将他们混为一谈，我这里总结一下他们的区别。

在 Python 3.x 中，

1. 普通函数（未定位在类里）和静态方法，都是函数（`function` ）。

2. 实例方法（@staticmethod）和类方法，都是方法（`method` ）。

这些结论其实都可以使用 `type` 函数得到验证。

先准备如下代码

```python
class Animal:
    def __init__(self, name):
        self.name = name
        
    def run(self):
        print(f"{self.name}跑起来啦")
        
    @staticmethod
    def eat():
        print("正在吃饭...")
        
    @classmethod
    def jump(cls, name):
        print(f"{name}跳起来啦")

def demo_func():
    pass
```

然后进入 Python Console 模式

```python
>>> type(demo_func)  # 普通函数
<class 'function'>
>>> type(dog.eat)   # 静态方法
<class 'function'>
>>>
>>> type(dog.run)  # 实例方法
<class 'method'>
>>> type(dog.jump)  # 类方法
<class 'method'>
```

到这里，你应该会有疑问了吧？

类方法和实例方法，名字本身就有方法，也是方法也说得过去。那静态方法呢，为什么不是方法而是函数呢？

对此，我的理解是：方法是一种和对象（实例或者类）绑定后的特殊函数。

方法本质上还是函数，不同之处在于它与对象进行绑定。

#  【基础】私有变量与私有方法

##  下划线妙用

在 Python 中，下划线可是非常推荐使用的符号：

1. 变量名推荐使用下划线分隔的蛇形命名法
2. 魔法方法、构造函数都需要使用双下划线
3. 对于暂时用不到的变量值，可以赋值给单下划线 `_` 进行占位

根据分类，我把下划线写法分成下面五种：

- 单前导下划线：`_var` 
- 单末尾下划线：`var_` 
- 双前导下划线：`__var`
- 双前导和末尾下划线：`__var__`
- 单下划线：`_`

由于篇幅所限，本篇将只介绍跟标题（私有变量与私有方法）有关的用法，也就是访问控制。

上面五种写法中，涉及到访问控制的有：`_var`  和 `__var`

##  单前导下划线 _var

下划线前缀的含义是告知其他程序员：**以单个下划线开头的变量或方法仅供内部使用**。

请看下面这个例子

```python
class Demo:
   def __init__(self):
       self.foo = 11
       self._bar = 22
```

如果你实例化此类，然后分别访问 `self.foo` 和 `self._bar` 会发生什么情况？

```python
>>> demo = Demo()
>>> demo.foo
11
>>> demo._bar
22
```

结果是：外界都可以直接访问这两个属性。

但实际上，二者是有区别的。PEP 8 有提及，如果一个属性的有单前导下划线，则该属性应该仅供内部访问。

但这并不是强制性的，不然上面我们也不可能通过 `self._bar` 访问到 22，但做为一名 Python 程序员最好遵守这一共识。



##  双前导下划线 __var

双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。

这也叫做**名称修饰(name mangling)** - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。

我知道这听起来很抽象。因此，我组合了一个小小的代码示例来予以说明：

```python
class Demo:
   def __init__(self):
       self.foo = 11
       self._bar = 22
       self.__baz = 33
```

将其进行实例化，然后使用 `dir()` 函数查看这个对象的属性

```python
>>> demo = Demo()
>>> dir(demo)
['_Demo__baz', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_bar', 'foo']
```

不难发现，`foo` 和 `_bar` 都很正常，可以使用 `demo.属性名` 进行访问。

但 `__baz` 明显和 `foo` 、 `_bar`  不一样，尝试访问后却报了 AttributeError，属性不存在。

```python
>>> demo.__baz
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'Demo' object has no attribute '__baz'
```

如果你仔细观察，你会看到此对象上有一个名为`_Demo__baz`的属性。这就是Python解释器所做的名称修饰。它这样做是为了防止变量在子类中被重写。

如果想访问，那得按照 dir 提示的写法去访问，在 `__baz` 前面加上 `_类名`。

```python
>>> demo._Demo__baz
23
```

总结可得，使用双下划线开头的属性变量，就是一个私有变量。

这样的规则在属性上生效，在方法上也同样适用。

如果一个实例方法，以双下划线开头，那么这个方法就是一个私有的方法，不能由实例对象或者类直接调用。

必须得通过 `实例._类名__方法名` 来调用。

##  总结一下

Python并没有真正的私有化支持，但可用下划线得到伪私有。

 尽量避免定义以下划线开头的变量。

- 私有变量：以双下划线前导的变量，可以使用 `实例._类名__变量名` 进行访问
- 私有方法：以双下划线前导的方法，可以使用 `实例._类名__方法名()` 进行访问

私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。对于这些内容我放到了下一节的的封装，请继续往后学习。



#  【基础】类的封装（Encapsulation）

封装是指将数据与具体操作的实现代码放在某个对象内部，使这些代码的实现细节不被外界发现，外界只能通过接口使用该对象，而不能通过任何形式修改对象内部实现。

要了解封装，离不开“私有化”，就是将类或者是函数中的某些属性限制在某个区域之内，外部无法直接调用。

关于什么是 `私有化变量和私有化函数`，在上一节我已经很详细的讲过啦。

私有变量和私有方法，虽然有办法访问，但是仍然不建议使用上面给出的方法直接访问，而应该接口统一的接口（函数入口）来对私有变量进行查看、变量，对私有方法进行调用。这就是封装。

正是由于封装机制，程序在使用某一对象时不需要关心该对象的数据结构细节及实现操作的方法。使用封装能隐藏对象实现细节，使代码更易维护，同时因为不能直接调用、修改对象内部的私有信息，在一定程度上保证了系统安全性。类通过将函数和变量封装在内部，实现了比函数更高一级的封装。

请看下面这段代码

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

xh = Person(name="小红", age=27)
if xh.age >= 18:
    print(f"{xh.name}已经是成年人了")
else:
    print(f"{xh.name}还是未年人")
```

我定义了一个 Person 的类，它有 name 和 age 两个属性。

如果想判断小明是不是成年人，需要使用 `xh.age` 来与 18 比较。

对于很多女生还来说，年龄是非常隐私的。如果不想年龄被人随意就获取，可以在 `age` 前加两个下划线，将其变成一个私有变量。外界就无法随随便便就知道某个人年龄啦。

如此一来，想要知道一个人是否是成年人，该怎么办呢？

这时候，就该 `封装` 出场啦。

我可以定义一个用于专门判断一个人是否成年人的函数，对 `self.__age` 这个属性进行封装。

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.__age = age
        
    def is_adult(self):
        return self.__age >= 18

xh = Person(name="小红", age=27)
xh.is_adult()
```



#  【基础】类的继承（Inheritance）

类的继承，跟人类繁衍的关系相似。

被继承的类称为基类（也叫做父类），继承而得的类叫派生类（也叫子类），这种关系就像人类的父子关系。

继承最大的好处是子类获得了父类的全部变量和方法的同时，又可以根据需要进行修改、拓展。

继承的语法结构是

```python
class 子类(父类):
```

##  单继承

举个例子：下面的代码中。先是定义了一个 People 类，里面有一个 speak 方法。然后再定义一个 Student 类，并继承自 People 类。

```python
# 父类定义
class People:
    def __init__(self, name, age, weight):
        self.name = name
        self.age = age

    def speak(self):
        print(f"{self.name} 说: 我{self.age}岁。")

# 单继承示例
class Student(People):
    def __init__(self, name, age, weight, grade):
        # 调用父类的实例化方法
        People.__init__(self, name, age, weight)
        self.grade = grade
```

由于继承的机制，Student 实例会拥有 People 类所有属性和方法，比如下边我可以直接调用 People 类的 speak 方法。

```python
>>> xm = Student(name="小明", age=10, weight=50, grade="三年级")
>>> xm.speak()
小明 说: 我 10 岁。
```

你如果不想使用父类的方法，你可以重写它以覆盖父类的 `speak` 方法。

```python
# 单继承示例
class Student(People):
    def __init__(self, name, age, weight, grade):
        # 调用父类的实例化方法
        People.__init__(self, name, age, weight)
        self.grade = grade

    # 重写父类的speak方法
    def speak(self):
        print(f"{self.name} 说: 我{self.age}岁了，我在读{self.grade}")
```

此时，再调用的话，就会调用自己的方法了

```python
>>> xm = Student(name="小明", age=10, weight=50, grade="三年级")
>>> xm.speak()
小明 说: 我10岁了，我在读三年级
```

##  多继承

Python 还支持多继承，可以继承自多个类。

```python
class 子类(父类1, 父类2, 父类3...):
```

多继承的话，情况会比单继承复杂得多。

假设多个父类都有一个 foo 方法，并且子类没有重写 foo 方法，那么 子类 的实例在调用 foo 方法时，应该使用哪个父类的 foo 方法呢？

关于这一点，只要简单的做个验证就行啦。

有如下代码，定义了 7 个类

```python
class D:pass
class C(D):pass

class B(C):
    def show(self):
        print("i am B")

class G:pass
class F(G):pass

class E(F):
    def show(self):
        print("i am E")

class A(B, E):pass
```

它们的继承关系是

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-496258.png)

运行后的结果如下

```python
>>> a = A()
>>> a.show()
i am B
```

在类A中，没有show()这个方法，于是它只能去它的父类里查找，它首先在B类中找，结果找到了，于是直接执行B类的show()方法。可见，在A的定义中，继承参数的书写有先后顺序，写在前面的被优先继承。

##  继承顺序

那如果B没有show方法，而是D有呢？

```python
class D:
    def show(self):
        print("i am D")

class C(D):pass
class B(C):pass


class G:pass
class F(G):pass

class E(F):
    def show(self):
        print("i am E")

class A(B, E):pass
```

执行结果是

```python
>>> a = A()
>>> a.show()
i am D
```

由此可见，多继承的顺序使用的是从左向右再深度优先的原则。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-510251.png)

##  MRO 算法

上面的继承案例是只是非常简单的一种场景，在实际应用中，会远比这个来得复杂。

此时如果你单纯的将其理解成

- 从左向右
- 深度优先

就会发现很场景下想要理清的方法解析顺序（MRO）是非常难的。

在这种情况下，你还可以有两种方法：

1. 使用 `__mro__` 来查询
2. 使用 merge算法进行推导

### 使用 mro 查询

比如在下面这个菱形继承中

```python
class A(object):pass
class B(A):pass
class C(A):pass
class D(B, C):pass
```

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-371251.png)

可以使用 `__mro__` 

```python
>>> print(D.__mro__)
```

或者借助 inspect 模块

```python
>>> import inspect
>>> print inspect.getmro(D)
```

得到的结果都将是

```python
(<class '__main__.D'>, 
 <class '__main__.B'>, 
 <class '__main__.C'>, 
 <class '__main__.A'>, 
 <class 'object'>)
```

### 使用 merge 推导

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-386252.png)

1. 检查第一个列表的头元素（如 L[B1] 的头），记作 H。
2. 若 H 未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作 H，继续该步骤。
3. 重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系，Python 会抛出异常。

你可以在草稿纸上，参照上面的merge算法，写出如下过程

```
L[object] = [object]
L[D] = [D, object]
L[E] = [E, object]
L[F] = [F, object]
L[B] = [B, D, E, object]
L[C] = [C, D, F, object]
L[A] = [A] + merge(L[B], L[C], [B], [C])
     = [A] + merge([B, D, E, object], [C, D, F, object], [B], [C])
     = [A, B] + merge([D, E, object], [C, D, F, object], [C])
     = [A, B, C] + merge([D, E, object], [D, F, object])
     = [A, B, C, D] + merge([E, object], [F, object])
     = [A, B, C, D, E] + merge([object], [F, object])
     = [A, B, C, D, E, F] + merge([object], [object])
     = [A, B, C, D, E, F, object]
```

## 附录：参考文章

---


-  https://www.python.org/download/releases/2.3/mro/
-  https://www.cnblogs.com/whatisfantasy/p/6046991.html

#  【基础】类的多态（Polymorphism）

多态，是指在同一类型下的不同形态。

比如下面这段代码

```python
class People:
    def speak(self):
        pass

class American(People):
    def speak(self):
        print("Hello, boys")

class Chinese(People):
    def speak(self):
        print("你好，老铁")
        
p1 = American()
p2 = Chinese()
```

American 和 Chinese 都继承了 People 类，但他们在 `speak()` 函数下，却有不同的形态表现。American 说英文，Chinese 说汉语。

倘若现在有一个 `do_speak` 函数

```python
def do_speak(people):
    people.speak()

do_speak(p1)
do_speak(p2)
```

那么无论传入的 American 实例还是 Chinese 实例，只要他有实现 speak 方法都可以。

这就是 Python 中非常有名鸭子类型：**一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。**

套入刚刚的代码实例中，就是一个对象，只要有 speak 方法，那么他就是一个 `do_speak` 方法所需要的 people 对象。

可能有人会觉得，这些内容很自然啊，没什么不好理解，不觉得多态有什么特殊，Python就是这样啊！

如果你学过 JAVA 这一类强类型静态语言，就不会这么觉得了，对于JAVA，必须指定函数参数的数据类型，只能传递对应参数类型或其子类型的参数，不能传递其它类型的参数，show_kind()函数只能接收animal、dog、cat和pig类型，而不能接收job类型。就算接收dog、cat和pig类型，也是通过面向对象的多态机制实现的。



# 【基础】类的 property 属性

在之前的学习中，对象的属性，我们都是通过把变量值赋值给对象本身来实现的。

```python
>>> class Student:pass
...
>>>
>>> s = Student()
>>> s.name = "王炳明"
>>> s.age = 27
```

直接赋值会存在一个问题，就是无法对属性值进行合法性较验，比如我给 age 赋值的是负数，在业务上这种数据是不合法的。但上面那种写法是无法检查出来的。

```python
>>> s.age = -27
>>> s.age
-27
```

为了实现属性的合法性校验，Python 引入的 property 属性。

请看下面这段代码

```python
class Student:
    @property
    def age(self):
        return self._age

    @age.setter
    def age(self, value):
        if 0 <= value <= 150:
            self._age = value
        else:
            raise ValueError("Valid value must be in [0, 150]")
```

此时再对 age 属性进行赋值就会对 value 的值进行合法性检查，小于 0 或者 大于 150 的都是不合法数据。

```python
>>> s = Student()
>>> s.age = -27
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 10, in age
ValueError: Valid value must be in [0, 150]
```

由此我们知道了 `property` ，其实是 Python 中一个内置的装饰器，它可以在新式类中把一个函数 `改造` 成属性。

- 当你读取属性值时，会进入被 `property` 装饰的函数。
- 当你对属性进行赋值时，会进入被 `@xx.setter` 装饰的函数。

- 两个装饰器，一定是 `@property` 在前面，而 `@xx.setter` 在后



#  【进阶】类的 Mixin 设计模式

类的单继承，是开发者再熟悉不过的继承方式，写起来也毫不费力。

而多继承呢，见得很多，写得很少。在很多的项目代码里，你还会见到一种很奇怪的类，他们有一个命名上的共同点，就是在类名的结尾，都喜欢用 Mixin。

##  认识Mixin模式

那我们今天就来讲讲这个 Mixin，对于这个Mixin，如何理解？它其实是一种设计模式，如果开发者之间没有产生这样一种设计模式的共识，那么设计模式将不复存在。

为了让大家，对这个 Mixin 有一个更直观的理解，我摘录了网上一段说明。

继承是一个”is-a”关系。比如轿车类继承交通工具类，因为轿车是一个(“is-a”)交通工具。一个物品不可能是多种不同的东西，因此就不应该存在多重继承。不过有没有这种情况，一个类的确是需要继承多个类呢？

答案是有，我们还是拿交通工具来举例子，民航飞机是一种交通工具，对于土豪们来说直升机也是一种交通工具。对于这两种交通工具，它们都有一个功能是飞行，但是轿车没有。所以，我们不可能将飞行功能写在交通工具这个父类中。但是如果民航飞机和直升机都各自写自己的飞行方法，又违背了代码尽可能重用的原则（如果以后飞行工具越来越多，那会出现许多重复代码）。

怎么办，那就只好让这两种飞机同时继承交通工具以及飞行器两个父类，这样就出现了多重继承。这时又违背了继承必须是”is-a”关系。这个难题该怎么破？

这时候 Mixin 就闪亮登场了。飞行只是飞机做为交通工具的一种（增强）属性，我们可以为这个飞行的功能单独定义一个（增强）类，称之为 Mixin 类。这个类，是做为增强功能，添加到子类中的。为了让其他开发者，一看就知道这是个 Mixin 类，一般都要求开发者遵循规范，在类名末尾加上 Mixin 。

举个例子

```python
class Vehicle(object):
    pass

class PlaneMixin(object):
    def fly(self):
        print('I am flying')

class Airplane(Vehicle, PlaneMixin):
    pass
```

使用Mixin类实现多重继承要遵循以下几个规范

- 责任明确：必须表示某一种功能，而不是某个物品；
- 功能单一：若有多个功能，那就写多个Mixin类；
- 绝对独立：不能依赖于子类的实现；子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。

##  不使用Mixin的弊端

你肯定会问，不使用 Mixin 行吗？

当然可以，这个问题就像在问，我不遵循 PEP8 代码规范行吗？完全没问题，只是不推荐那样做。

那么到底有什么理由，让我们要去用到 Mixin 设计模式呢？

不使用的话，大概有如下三点弊端：

**1、结构复杂**

单继承中一个类的父类是什么，父类的父类是什么非常明确。多继承一个类有多个父类，父类又有多个父类，继承关系复杂。

**2、优先顺序模糊**

多个父类中有同名方法，在开发过程中，容易造成思维混乱，子类不知道继承哪个父类，会增加开发难度。关于子类的继承顺序，有一个比较复杂的 C3 算法，如果你还不清楚，可以点击我的另一篇文章 ，了解一下。

**3、功能冲突**

多重继承有多个父类，但是子类只能继承一个，对于同名方法，就会导致另一个父类的方法失效。

# 9 【进阶】类的魔术方法（超全整理）

什么是魔法方法呢？它们在面向对象的Python的处处皆是。

它们是一些可以让你对类添加`魔法`的特殊方法。它们经常是两个下划线包围来命名的（比如 `__init__` ， `__lt__` ）。

本文整理自：[ (译)Python魔法方法指南](https://pyzh.readthedocs.io/en/latest/python-magic-methods-guide.html#id28)，内容非常多，不适合新手全文阅读，如果你是跟着教程从头看到这的，建议先跳过本文内容。而如果你是一名有经验的 Python 老手，可以考虑全文通读，会加深你对 Python 魔法方法的理解。

##  构造方法

我们最为熟知的基本的魔法方法就是 `__init__` ，我们可以用它来指明一个对象初始化的行为。然而，当我们调用 x = SomeClass() 的时候， `__init__` 并不是第一个被调用的方法。事实上，第一个被调用的是 `__new__` ，这个 方法才真正地创建了实例。当这个对象的生命周期结束的时候， `__del__` 会被调用。让我们近一步理解这三个方法：

- `__new__(cls,[…)`

    `__new__` 是对象实例化时第一个调用的方法，它只取下 cls 参数，并把其他参数传给 `__init__` 。`__new__` 很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。我不打算深入讨论 `__new__` ，因为它并不是很有用， Python文档 中 有详细的说明。

- `__init__(self,[…])`

    类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x = SomeClass(10, 'foo') ， `__init__` 就会接到参数 10 和 'foo' 。`__init__` 在Python的类定义中用的最多。

- `__del__(self)`

    `__new__` 和 `__init__` 是对象的构造器， `__del__` 是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于 x.`__del__()`。而是定义了当对象被垃圾回收时的行为。当对象需要在销毁时做一些处理的时候这个方法很有用，比如 socket 对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候， `__del__` 并不会 执行。所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。

这里有个 `__init__` 和 `__del__` 的例子:

```python
from os.path import join

class FileObject:
    '''文件对象的装饰类，用来保证文件被删除时能够正确关闭。'''

    def __init__(self, filepath='~', filename='sample.txt'):
        # 使用读写模式打开filepath中的filename文件
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file
```

##  操作符

使用Python魔法方法的一个巨大优势就是可以构建一个拥有Python内置类型行为的对象。这意味着你可以避免使用非标准的、丑陋的方式来表达简单的操作。在一些语言中，这样做很常见:

```python
if instance.equals(other_instance):
    # do something
```

你当然可以在Python也这么做，但是这样做让代码变得冗长而混乱。不同的类库可能对同一种比较操作采用不同的方法名称，这让使用者需要做很多没有必要的工作。运用魔法方法的魔力，我们可以定义方法 `__eq__`

```python
if instance == other_instance:
    # do something
```

这是魔法力量的一部分，这样我们就可以创建一个像内建类型那样的对象了！

###  比较操作符

Python包含了一系列的魔法方法，用于实现对象之间直接比较，而不需要采用方法调用。同样也可以重载Python默认的比较方法，改变它们的行为。下面是这些方法的列表：

- `__cmp__(self, other)`

    `__cmp__` 是所有比较魔法方法中最基础的一个，它实际上定义了所有比较操作符的行为（<,==,!=,等等），但是它可能不能按照你需要的方式工作（例如，判断一个实例和另一个实例是否相等采用一套标准，而与判断一个实例是否大于另一实例采用另一套）。`__cmp__` 应该在 self < other 时返回一个负整数，在 self == other 时返回0，在 self > other 时返回正整数。最好只定义你所需要的比较形式，而不是一次定义全部。如果你需要实现所有的比较形式，而且它们的判断标准类似，那么 `__cmp__` 是一个很好的方法，可以减少代码重复，让代码更简洁。

- `__eq__(self, other)`

    定义等于操作符(==)的行为。

- `__ne__(self, other)`

    定义不等于操作符(!=)的行为。

- `__lt__(self, other)`

    定义小于操作符(<)的行为。

- `__gt__(self, other)`

    定义大于操作符(>)的行为。

- `__le__(self, other)`

    定义小于等于操作符(<)的行为。

- `__ge__(self, other)`

    定义大于等于操作符(>)的行为。

举个例子，假如我们想用一个类来存储单词。我们可能想按照字典序（字母顺序）来比较单词，字符串的默认比较行为就是这样。我们可能也想按照其他规则来比较字符串，像是长度，或者音节的数量。在这个例子中，我们使用长度作为比较标准，下面是一种实现:

```python
class Word(str):
    '''单词类，按照单词长度来定义比较行为'''

    def __new__(cls, word):
        # 注意，我们只能使用 `__new__` ，因为str是不可变类型
        # 所以我们必须提前初始化它（在实例创建时）
        if ' ' in word:
            print "Value contains spaces. Truncating to first space."
            word = word[:word.index(' ')]
            # Word现在包含第一个空格前的所有字母
        return str.`__new__`(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) < len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) <= len(other)
```

现在我们可以创建两个 Word 对象（ Word('foo') 和 Word('bar'))然后根据长度来比较它们。注意我们没有定义 `__eq__` 和 `__ne__` ，这是因为有时候它们会导致奇怪的结果（很明显， Word('foo') == Word('bar') 得到的结果会是true）。根据长度测试是否相等毫无意义，所以我们使用 str 的实现来比较相等。

从上面可以看到，不需要实现所有的比较魔法方法，就可以使用丰富的比较操作。标准库还在 functools 模块中提供了一个类装饰器，只要我们定义 `__eq__` 和另外一个操作符（ `__gt__`, `__lt__` 等），它就可以帮我们实现比较方法。这个特性只在 Python 2.7 中可用。当它可用时，它能帮助我们节省大量的时间和精力。要使用它，只需要它 @total_ordering 放在类的定义之上就可以了

###  数值操作符

就像你可以使用比较操作符来比较类的实例，你也可以定义数值操作符的行为。固定好你的安全带，这样的操作符真的有很多。看在组织的份上，我把它们分成了五类：一元操作符，常见算数操作符，反射算数操作符（后面会涉及更多），增强赋值操作符，和类型转换操作符。

#### 一元操作符

一元操作符只有一个操作符。

- `__pos__(self)`

    实现取正操作，例如 +some_object。

- `__neg_(self)`

    实现取负操作，例如 -some_object。

- `__abs__(self)`

    实现内建绝对值函数 abs() 操作。

- `__invert__(self)`

    实现取反操作符 ~。

- `__round__(self， n)`

    实现内建函数 round() ，n 是近似小数点的位数。

- `__floor__(self)`

    实现 math.floor() 函数，即向下取整。

- `__ceil__(self)`

    实现 math.ceil() 函数，即向上取整。

- `__trunc__(self)`

    实现 math.trunc() 函数，即距离零最近的整数。

#### 常见算数操作符

现在，我们来看看常见的二元操作符（和一些函数），像+，-，*之类的，它们很容易从字面意思理解。

- `__add__(self, other)`

    实现加法操作。

- `__sub__(self, other)`

    实现减法操作。

- `__mul__(self, other)`

    实现乘法操作。

- `__floordiv__(self, other)`

    实现使用 // 操作符的整数除法。

- `__div__(self, other)`

    实现使用 / 操作符的除法。

- `__truediv__(self, other)`

    实现 *true* 除法，这个函数只有使用 `from __future__ import division` 时才有作用。

- `__mod__(self, other)`

    实现 % 取余操作。

- `__divmod__(self, other)`

    实现 divmod 内建函数。

- `__pow__(self)`

    实现 ** 操作符。

- `__lshift__(self, other)`

    实现左移位运算符 << 。

- `__rshift__(self, other)`

    实现右移位运算符 >> 。

- `__and__(self, other)`

    实现按位与运算符 & 。

- `__or__(self, other)`

    实现按位或运算符 | 。

- `__xor__(self, other)`

    实现按位异或运算符 ^ 。

#### 反射算数运算符

还记得刚才我说会谈到反射运算符吗？可能你会觉得它是什么高端霸气上档次的概念，其实这东西挺简单的，下面举个例子:

```python
some_object + other
```

这是“常见”的加法，反射是一样的意思，只不过是运算符交换了一下位置:

```python
other + some_object
```

所有反射运算符魔法方法和它们的常见版本做的工作相同，只不过是处理交换连个操作数之后的情况。绝大多数情况下，反射运算和正常顺序产生的结果是相同的，所以很可能你定义 `__radd__` 时只是调用一下 `__add__`。注意一点，操作符左侧的对象（也就是上面的 other ）一定不要定义（或者产生 NotImplemented 异常） 操作符的非反射版本。例如，在上面的例子中，只有当 other 没有定义 `__add__` 时 some_object.`__radd__` 才会被调用。

- `__radd__(self, other)`

    实现反射加法操作。

- `__rsub__(self, other)`

    实现反射减法操作。

- `__rmul__(self, other)`

    实现反射乘法操作。

- `__rfloordiv__(self, other)`

    实现使用 // 操作符的整数反射除法。

- `__rdiv__(self, other)`

    实现使用 / 操作符的反射除法。

- `__rtruediv__(self, other)`

    实现 *true* 反射除法，这个函数只有使用 `from __future__ import division` 时才有作用。

- `__rmod__(self, other)`

    实现 % 反射取余操作符。

- `__rdivmod__(self, other)`

    实现调用 divmod(other, self) 时 divmod 内建函数的操作。

- `__rpow__(self)`

    实现 ** 反射操作符。

- `__rlshift__(self, other)`

    实现反射左移位运算符 << 的作用。

- `__rshift__(self, other)`

    实现反射右移位运算符 >> 的作用。

- `__rand__(self, other)`

    实现反射按位与运算符 & 。

- `__ror__(self, other)`

    实现反射按位或运算符 | 。

- `__rxor__(self, other)`

    实现反射按位异或运算符 ^ 。

#### 增强赋值运算符

Python同样提供了大量的魔法方法，可以用来自定义增强赋值操作的行为。或许你已经了解增强赋值，它融合了“常见”的操作符和赋值操作，如果你还是没听明白，看下面的例子:

```python
x = 5
x += 1 # 也就是 x = x + 1
```

这些方法都应该返回左侧操作数应该被赋予的值（例如， a += b `__iadd__` 也许会返回 a + b ，这个结果会被赋给 a ）,下面是方法列表：

- `__iadd__(self, other)`

    实现加法赋值操作。

- `__isub__(self, other)`

    实现减法赋值操作。

- `__imul__(self, other)`

    实现乘法赋值操作。

- `__ifloordiv__(self, other)`

    实现使用 //= 操作符的整数除法赋值操作。

- `__idiv__(self, other)`

    实现使用 /= 操作符的除法赋值操作。

- `__itruediv__(self, other)`

    实现 *true* 除法赋值操作，这个函数只有使用`from __future__  import division` 时才有作用。

- `__imod__(self, other)`

    实现 %= 取余赋值操作。

- `__ipow__(self)`

    实现 **= 操作。

- `__ilshift__(self, other)`

    实现左移位赋值运算符 <<= 。

- `__irshift__(self, other)`

    实现右移位赋值运算符 >>= 。

- `__iand__(self, other)`

    实现按位与运算符 &= 。

- `__ior__(self, other)`

    实现按位或赋值运算符 | 。

- `__ixor__(self, other)`

    实现按位异或赋值运算符 ^= 。

#### 类型转换操作符

Python也有一系列的魔法方法用于实现类似 float() 的内建类型转换函数的操作。它们是这些：

- `__int__(self)`

    实现到int的类型转换。

- `__long__(self)`

    实现到long的类型转换。

- `__float__(self)`

    实现到float的类型转换。

- `__complex__(self)`

    实现到complex的类型转换。

- `__oct__(self)`

    实现到八进制数的类型转换。

- `__hex__(self)`

    实现到十六进制数的类型转换。

- `__index__(self)`

    实现当对象用于切片表达式时到一个整数的类型转换。如果你定义了一个可能会用于切片操作的数值类型，你应该定义 `__index__`。

- `__trunc__(self)`

    当调用 math.trunc(self) 时调用该方法，`__trunc__`应该返回 self 截取到一个整数类型（通常是long类型）的值。

- `__coerce__(self)`

    该方法用于实现混合模式算数运算，如果不能进行类型转换， `__coerce__` 应该返回 None 。反之，它应该返回一个二元组 self 和 other ，这两者均已被转换成相同的类型。

##  类的表示

使用字符串来表示类是一个相当有用的特性。在Python中有一些内建方法可以返回类的表示，相对应的，也有一系列魔法方法可以用来自定义在使用这些内建函数时类的行为。

- `__str__(self)`

    定义对类的实例调用 str() 时的行为。

- `__repr__(self)`

    定义对类的实例调用 repr() 时的行为。str() 和 repr() 最主要的差别在于“目标用户”。repr() 的作用是产生机器可读的输出（大部分情况下，其输出可以作为有效的Python代码），而 str() 则产生人类可读的输出。

- `__unicode__(self)`

    定义对类的实例调用 unicode() 时的行为。unicode() 和 str() 很像，只是它返回unicode字符串。注意，如果调用者试图调用 str() 而你的类只实现了 `__unicode__`() ，那么类将不能正常工作。所有你应该总是定义 `__str__`() ，以防有些人没有闲情雅致来使用unicode。

- `__format__(self)`

    定义当类的实例用于新式字符串格式化时的行为，例如， "Hello, 0:abc!".format(a) 会导致调用 `a.__format__("abc")` 。当定义你自己的数值类型或字符串类型时，你可能想提供某些特殊的格式化选项，这种情况下这个魔法方法会非常有用。

- `__hash__(self)`

    定义对类的实例调用 hash() 时的行为。它必须返回一个整数，其结果会被用于字典中键的快速比较。同时注意一点，实现这个魔法方法通常也需要实现 `__eq__` ，并且遵守如下的规则：a == b 意味着 hash(a) == hash(b)。

- `__nonzero__(self)`

    定义对类的实例调用 bool() 时的行为，根据你自己对类的设计，针对不同的实例，这个魔法方法应该相应地返回True或False。

- `__dir__(self)`

    定义对类的实例调用 dir() 时的行为，这个方法应该向调用者返回一个属性列表。一般来说，没必要自己实现 `__dir__` 。但是如果你重定义了 `__getattr__` 或者 `__getattribute__` （下个部分会介绍），乃至使用动态生成的属性，以实现类的交互式使用，那么这个魔法方法是必不可少的。

到这里，我们基本上已经结束了魔法方法指南中无聊并且例子匮乏的部分。既然我们已经介绍了较为基础的魔法方法，是时候涉及更高级的内容了。

##  访问控制

很多从其他语言转向Python的人都抱怨Python的类缺少真正意义上的封装（即没办法定义私有属性然后使用公有的getter和setter）。然而事实并非如此。实际上Python不是通过显式定义的字段和方法修改器，而是通过魔法方法实现了一系列的封装。

- `__getattr__(self, name)`

当用户试图访问一个根本不存在（或者暂时不存在）的属性时，你可以通过这个魔法方法来定义类的行为。这个可以用于捕捉错误的拼写并且给出指引，使用废弃属性时给出警告（如果你愿意，仍然可以计算并且返回该属性），以及灵活地处理AttributeError。只有当试图访问不存在的属性时它才会被调用，所以这不能算是一个真正的封装的办法。

- `__setattr__(self, name, value)`

和 `__getattr__` 不同， `__setattr__` 可以用于真正意义上的封装。它允许你自定义某个属性的赋值行为，不管这个属性存在与否，也就是说你可以对任意属性的任何变化都定义自己的规则。然后，一定要小心使用 `__setattr__` ，这个列表最后的例子中会有所展示。

- `__delattr__(self, name)`

这个魔法方法和 `__setattr__`几乎相同，只不过它是用于处理删除属性时的行为。和 `_setattr__` 一样，使用它时也需要多加小心，防止产生无限递归（在 `__delattr__` 的实现中调用 del self.name 会导致无限递归）。

- `__getattribute__(self, name)`

`__getattribute__` 看起来和上面那些方法很合得来，但是最好不要使用它。`__getattribute__` 只能用于新式类。在最新版的Python中所有的类都是新式类，在老版Python中你可以通过继承 object 来创建新式类。`__getattribute__` 允许你自定义属性被访问时的行为，它也同样可能遇到无限递归问题（通过调用基类的 `__getattribute__` 来避免）。`__getattribute__` 基本上可以替代 `__getattr__` 。只有当它被实现，并且显式地被调用，或者产生 AttributeError 时它才被使用。这个魔法方法可以被使用（毕竟，选择权在你自己），我不推荐你使用它，因为它的使用范围相对有限（通常我们想要在赋值时进行特殊操作，而不是取值时），而且实现这个方法很容易出现Bug。

自定义这些控制属性访问的魔法方法很容易导致问题，考虑下面这个例子:

```python
def __setattr__(self, name. value):
    self.name = value
    # 因为每次属性幅值都要调用 __setattr__()，所以这里的实现会导致递归
    # 这里的调用实际上是 self.__setattr('name', value)。因为这个方法一直
    # 在调用自己，因此递归将持续进行，直到程序崩溃

def __setattr__(self, name, value):
    self.__dict__[name] = value # 使用 __dict__ 进行赋值
    # 定义自定义行为
```

再次重申，Python的魔法方法十分强大，能力越强责任越大，了解如何正确的使用魔法方法更加重要。

到这里，我们对Python中自定义属性存取控制有了什么样的印象？它并不适合轻度的使用。实际上，它有些过分强大，而且违反直觉。然而它之所以存在，是因为一个更大的原则：Python不指望让杜绝坏事发生，而是想办法让做坏事变得困难。自由是至高无上的权利，你真的可以随心所欲。下面的例子展示了实际应用中某些特殊的属性访问方法（注意我们之所以使用 super 是因为不是所有的类都有 `__dict__` 属性）:

```python
class AccessCounter(object):
    ''' 一个包含了一个值并且实现了访问计数器的类
    每次值的变化都会导致计数器自增'''

    def __init__(self, val):
            super(AccessCounter, self).__setattr__('counter', 0)
            super(AccessCounter, self).__setattr__('value', val)

    def __setattr__(self, name, value):
            if name == 'value':
                    super(AccessCounter, self).__setattr_('counter', self.counter + 1)
        # 使计数器自增变成不可避免
        # 如果你想阻止其他属性的赋值行为
        # 产生 AttributeError(name) 就可以了
        super(AccessCounter, self).__setattr__(name, value)

    def __delattr__(self, name):
            if name == 'value':
                    super(AccessCounter, self).__setattr('counter', self.counter + 1)
                    super(AccessCounter, self).__delattr(name)
```

##  自定义序列

有许多办法可以让你的Python类表现得像是内建序列类型（字典，元组，列表，字符串等）。这些魔法方式是目前为止我最喜欢的。它们给了你难以置信的控制能力，可以让你的类与一系列的全局函数完美结合。在了解激动人心的内容之前，首先你需要掌握一些预备知识。

既然讲到创建自己的序列类型，就不得不说一说协议了。协议类似某些语言中的接口，里面包含的是一些必须实现的方法。在Python中，协议完全是非正式的，也不需要显式的声明，事实上，它们更像是一种参考标准。

为什么我们要讲协议？因为在Python中实现自定义容器类型需要用到一些协议。首先，不可变容器类型有如下协议：想实现一个不可变容器，你需要定义 `__len__` 和 `__getitem__` (后面会具体说明）。可变容器的协议除了上面提到的两个方法之外，还需要定义 `__setitem__` 和 `__delitem__` 。最后，如果你想让你的对象可以迭代，你需要定义 `__iter__` ，这个方法返回一个迭代器。迭代器必须遵守迭代器协议，需要定义 `__iter__` （返回它自己）和 next 方法。

###  容器背后的魔法方法

- `__len__`(self)

    返回容器的长度，可变和不可变类型都需要实现。

- `__getitem__`(self, key)

    定义对容器中某一项使用 self[key] 的方式进行读取操作时的行为。这也是可变和不可变容器类型都需要实现的一个方法。它应该在键的类型错误式产生 TypeError 异常，同时在没有与键值相匹配的内容时产生 KeyError 异常。

- `__setitem__`(self, key)

    定义对容器中某一项使用 self[key] 的方式进行赋值操作时的行为。它是可变容器类型必须实现的一个方法，同样应该在合适的时候产生 KeyError 和 TypeError 异常。

- `__iter__`(self, key)

    它应该返回当前容器的一个迭代器。迭代器以一连串内容的形式返回，最常见的是使用 iter() 函数调用，以及在类似 for x in container: 的循环中被调用。迭代器是他们自己的对象，需要定义 `__iter__` 方法并在其中返回自己。

- `__reversed__`(self)

    定义了对容器使用 reversed() 内建函数时的行为。它应该返回一个反转之后的序列。当你的序列类是有序时，类似列表和元组，再实现这个方法，

- `__contains__`(self, item)

    `__contains__` 定义了使用 in 和 not in 进行成员测试时类的行为。你可能好奇为什么这个方法不是序列协议的一部分，原因是，如果 `__contains__` 没有定义，Python就会迭代整个序列，如果找到了需要的一项就返回 True 。

- `__missing__`(self ,key)

    `__missing__` 在字典的子类中使用，它定义了当试图访问一个字典中不存在的键时的行为（目前为止是指字典的实例，例如我有一个字典 d ， "george" 不是字典中的一个键，当试图访问 d["george'] 时就会调用 d.`__missing__`("george") ）。

###  一个例子

让我们来看一个实现了一些函数式结构的列表，可能在其他语言中这种结构更常见（例如Haskell）:

```python
class FunctionalList:
    '''一个列表的封装类，实现了一些额外的函数式
    方法，例如head, tail, init, last, drop和take。'''

    def __init__(self, values=None):
        if values is None:
            self.values = []
        else:
            self.values = values

    def __len__(self):
        return len(self.values)

    def __getitem__(self, key):
        # 如果键的类型或值不合法，列表会返回异常
        return self.values[key]

    def __setitem__(self, key, value):
        self.values[key] = value

    def __delitem__(self, key):
        del self.values[key]

    def __iter__(self):
        return iter(self.values)

    def __reversed__(self):
        return reversed(self.values)

    def append(self, value):
        self.values.append(value)

    def head(self):
        # 取得第一个元素
        return self.values[0]

    def tail(self):
        # 取得除第一个元素外的所有元素
        return self.valuse[1:]

    def init(self):
        # 取得除最后一个元素外的所有元素
        return self.values[:-1]

    def last(self):
        # 取得最后一个元素
        return self.values[-1]

    def drop(self, n):
        # 取得除前n个元素外的所有元素
        return self.values[n:]

    def take(self, n):
        # 取得前n个元素
        return self.values[:n]
```

就是这些，一个（微不足道的）有用的例子，向你展示了如何实现自己的序列。当然啦，自定义序列有更大的用处，而且绝大部分都在标准库中实现了（Python是自带电池的，记得吗？），像 Counter , OrderedDict 和 NamedTuple 。

##  反射

你可以通过定义魔法方法来控制用于反射的内建函数 isinstance 和 issubclass 的行为。下面是对应的魔法方法：

- `__instancecheck__(self, instance)`

    检查一个实例是否是你定义的类的一个实例（例如 isinstance(instance, class) ）。

- `__subclasscheck__(self, subclass)`

    检查一个类是否是你定义的类的子类（例如 issubclass(subclass, class) ）。

这几个魔法方法的适用范围看起来有些窄，事实也正是如此。我不会在反射魔法方法上花费太多时间，因为相比其他魔法方法它们显得不是很重要。但是它们展示了在Python中进行面向对象编程（或者总体上使用Python进行编程）时很重要的一点：不管做什么事情，都会有一个简单方法，不管它常用不常用。这些魔法方法可能看起来没那么有用，但是当你真正需要用到它们的时候，你会感到很幸运，因为它们还在那儿（也因为你阅读了这本指南！）

##  抽象基类

请参考 *http://docs.python.org/2/library/abc.html*

##  可调用的对象

你可能已经知道了，在Python中，函数是一等的对象。这意味着它们可以像其他任何对象一样被传递到函数和方法中，这是一个十分强大的特性。

Python中一个特殊的魔法方法允许你自己类的对象表现得像是函数，然后你就可以“调用”它们，把它们传递到使用函数做参数的函数中，等等等等。这是另一个强大而且方便的特性，让使用Python编程变得更加幸福。

- `__call__(self, [args…])`

    允许类的一个实例像函数那样被调用。本质上这代表了 x() 和 x.`__call__`() 是相同的。注意 `__call__` 可以有多个参数，这代表你可以像定义其他任何函数一样，定义 `__call__` ，喜欢用多少参数就用多少。

`__call__` 在某些需要经常改变状态的类的实例中显得特别有用。“调用”这个实例来改变它的状态，是一种更加符合直觉，也更加优雅的方法。一个表示平面上实体的类是一个不错的例子:

```python
class Entity:
        '''表示一个实体的类，调用它的实例
        可以更新实体的位置'''

        def __init__(self, size, x, y):
                self.x, self.y = x, y
                self.size = size

        def __call__(self, x, y):
                '''改变实体的位置'''
                self.x, self.y = x, y
```

##  上下文管理器

在Python 2.5中引入了一个全新的关键词，随之而来的是一种新的代码复用方法—— with 声明。上下文管理的概念在Python中并不是全新引入的（之前它作为标准库的一部分实现），直到PEP 343被接受，它才成为一种一级的语言结构。可能你已经见过这种写法了:

```python
with open('foo.txt') as bar:
    # 使用bar进行某些操作
```

当对象使用 with 声明创建时，上下文管理器允许类做一些设置和清理工作。上下文管理器的行为由下面两个魔法方法所定义：

- `__enter__(self)`

    定义使用 with 声明创建的语句块最开始上下文管理器应该做些什么。注意 `__enter__` 的返回值会赋给 with 声明的目标，也就是 as 之后的东西。

- `__exit__(self, exception_type, exception_value, traceback)`

    定义当 with 声明语句块执行完毕（或终止）时上下文管理器的行为。它可以用来处理异常，进行清理，或者做其他应该在语句块结束之后立刻执行的工作。如果语句块顺利执行， exception_type , exception_value 和 traceback 会是 None 。否则，你可以选择处理这个异常或者让用户来处理。如果你想处理异常，确保 `__exit__` 在完成工作之后返回 True 。如果你不想处理异常，那就让它发生吧。

对一些具有良好定义的且通用的设置和清理行为的类，`__enter__` 和 `__exit__`会显得特别有用。你也可以使用这几个方法来创建通用的上下文管理器，用来包装其他对象。下面是一个例子:

```python
class Closer:
    '''一个上下文管理器，可以在with语句中
    使用close()自动关闭对象'''

    def __init__(self, obj):
        self.obj = obj

    def __enter__(self, obj):
        return self.obj # 绑定到目标

    def __exit__(self, exception_type, exception_value, traceback):
        try:
                self.obj.close()
        except AttributeError: # obj不是可关闭的
                print 'Not closable.'
                return True # 成功地处理了异常
```

这是一个 Closer 在实际使用中的例子，使用一个FTP连接来演示（一个可关闭的socket):

```python
>>> from magicmethods import Closer
>>> from ftplib import FTP
>>> with Closer(FTP('ftp.somesite.com')) as conn:
...         conn.dir()
...
# 为了简单，省略了某些输出
>>> conn.dir()
# 很长的 AttributeError 信息，不能使用一个已关闭的连接
>>> with Closer(int(5)) as i:
...         i += 1
...
Not closable.
>>> i
6
```

看到我们的包装器是如何同时优雅地处理正确和不正确的调用了吗？这就是上下文管理器和魔法方法的力量。Python标准库包含一个 contextlib 模块，里面有一个上下文管理器 contextlib.closing() 基本上和我们的包装器完成的是同样的事情（但是没有包含任何当对象没有close()方法时的处理）。

##  创建描述符对象

描述符是一个类，当使用取值，赋值和删除 时它可以改变其他对象。描述符不是用来单独使用的，它们需要被一个拥有者类所包含。描述符可以用来创建面向对象数据库，以及创建某些属性之间互相依赖的类。描述符在表现具有不同单位的属性，或者需要计算的属性时显得特别有用（例如表现一个坐标系中的点的类，其中的距离原点的距离这种属性）。

要想成为一个描述符，一个类必须具有实现 `__get__` , `__set__` 和 `__delete__` 三个方法中至少一个。

让我们一起来看一看这些魔法方法：

- `__get__(self, instance, owner)`

    定义当试图取出描述符的值时的行为。instance 是拥有者类的实例， owner 是拥有者类本身。

- `__set__(self, instance, owner)`

    定义当描述符的值改变时的行为。instance 是拥有者类的实例， value 是要赋给描述符的值。

- `__delete__(self, instance, owner)`

    定义当描述符的值被删除时的行为。instance 是拥有者类的实例

现在，来看一个描述符的有效应用：单位转换:

```python
class Meter(object):
    '''米的描述符。'''

    def __init__(self, value=0.0):
        self.value = float(value)
    def __get__(self, instance, owner):
        return self.value
    def __set__(self, instance, owner):
            self.value = float(value)

class Foot(object):
    '''英尺的描述符。'''

    def __get__(self, instance, owner):
            return instance.meter * 3.2808
    def __set__(self, instance, value):
            instance.meter = float(value) / 3.2808

class Distance(object):
    '''用于描述距离的类，包含英尺和米两个描述符。'''
    meter = Meter()
    foot = Foot()
```

##  拷贝

有些时候，特别是处理可变对象时，你可能想拷贝一个对象，改变这个对象而不影响原有的对象。这时就需要用到Python的 copy 模块了。然而（幸运的是），Python模块并不具有感知能力， 因此我们不用担心某天基于Linux的机器人崛起。但是我们的确需要告诉Python如何有效率地拷贝对象。

- `__copy__(self)`

    定义对类的实例使用 copy.copy() 时的行为。copy.copy() 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。

- `__deepcopy__(self, memodict=)`

    定义对类的实例使用 copy.deepcopy() 时的行为。copy.deepcopy() 返回一个对象的深拷贝，这个对象和它的数据全都被拷贝了一份。memodict 是一个先前拷贝对象的缓存，它优化了拷贝过程，而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 copy.deepcopy() ，使用 memodict 作为第一个参数。

这些魔法方法有什么用武之地呢？像往常一样，当你需要比默认行为更加精确的控制时。例如，如果你想拷贝一个对象，其中存储了一个字典作为缓存（可能会很大），拷贝缓存可能是没有意义的。如果这个缓存可以在内存中被不同实例共享，那么它就应该被共享。

## Pickling

如果你和其他的Python爱好者共事过，很可能你已经听说过Pickling了。Pickling是Python数据结构的序列化过程，当你想存储一个对象稍后再取出读取时，Pickling会显得十分有用。然而它同样也是担忧和混淆的主要来源。

Pickling是如此的重要，以至于它不仅仅有自己的模块（ pickle ），还有自己的协议和魔法方法。首先，我们先来简要的介绍一下如何pickle已存在的对象类型（如果你已经知道了，大可跳过这部分内容）。

###  小试牛刀

我们一起来pickle吧。假设你有一个字典，你想存储它，稍后再取出来。你可以把它的内容写入一个文件，小心翼翼地确保使用了正确地格式，要把它读取出来，你可以使用 exec() 或处理文件输入。但是这种方法并不可靠：如果你使用纯文本来存储重要数据，数据很容易以多种方式被破坏或者修改，导致你的程序崩溃，更糟糕的情况下，还可能在你的计算机上运行恶意代码。因此，我们要pickle它:

```python
import pickle

data = {'foo': [1,2,3],
                'bar': ('Hello', 'world!'),
                'baz': True}
jar = open('data.pkl', 'wb')
pickle.dump(data, jar) # 将pickle后的数据写入jar文件
jar.close()
```

过了几个小时，我们想把它取出来，我们只需要反pickle它:

```python
import pickle

pkl_file = open('data.pkl', 'rb') # 与pickle后的数据连接
data = pickle.load(pkl_file) # 把它加载进一个变量
print data
pkl_file.close()
```

将会发生什么？正如你期待的，它就是我们之前的 data 。

现在，还需要谨慎地说一句：pickle并不完美。Pickle文件很容易因为事故或被故意的破坏掉。Pickling或许比纯文本文件安全一些，但是依然有可能被用来运行恶意代码。而且它还不支持跨Python版本，所以不要指望分发pickle对象之后所有人都能正确地读取。然而不管怎么样，它依然是一个强有力的工具，可以用于缓存和其他类型的持久化工作。

###  Pickle你的对象

Pickle不仅仅可以用于内建类型，任何遵守pickle协议的类都可以被pickle。Pickle协议有四个可选方法，可以让类自定义它们的行为（这和C语言扩展略有不同，那不在我们的讨论范围之内）。

- `__getinitargs__(self)`

    如果你想让你的类在反pickle时调用 `__init__` ，你可以定义 `__getinitargs__`(self) ，它会返回一个参数元组，这个元组会传递给 `__init__` 。注意，这个方法只能用于旧式类。

- `__getnewargs__(self)`

    对新式类来说，你可以通过这个方法改变类在反pickle时传递给 `__new__` 的参数。这个方法应该返回一个参数元组。

- `__getstate__(self)`

    你可以自定义对象被pickle时被存储的状态，而不使用对象的 `__dict__` 属性。这个状态在对象被反pickle时会被 `__setstate__` 使用。

- `__setstate__(self)`

    当一个对象被反pickle时，如果定义了 `__setstate__` ，对象的状态会传递给这个魔法方法，而不是直接应用到对象的 `__dict__` 属性。这个魔法方法和 `__getstate__` 相互依存：当这两个方法都被定义时，你可以在Pickle时使用任何方法保存对象的任何状态。

- `__reduce__(self)`

    当定义扩展类型时（也就是使用Python的C语言API实现的类型），如果你想pickle它们，你必须告诉Python如何pickle它们。**reduce** 被定义之后，当对象被Pickle时就会被调用。它要么返回一个代表全局名称的字符串，Pyhton会查找它并pickle，要么返回一个元组。这个元组包含2到5个元素，其中包括：一个可调用的对象，用于重建对象时调用；一个参数元素，供那个可调用对象使用；被传递给 `__setstate__` 的状态（可选）；一个产生被pickle的列表元素的迭代器（可选）；一个产生被pickle的字典元素的迭代器（可选）；

- `__reduce_ex__(self)`

    `__reduce_ex__` 的存在是为了兼容性。如果它被定义，在pickle时 `__reduce_ex__` 会代替 `__reduce__` 被调用。`__reduce__` 也可以被定义，用于不支持 `__reduce_ex__` 的旧版pickle的API调用。

###  一个例子

我们的例子是 Slate ，它会记住它的值曾经是什么，以及那些值是什么时候赋给它的。然而 每次被pickle时它都会变成空白，因为当前的值不会被存储:

```python
import time

class Slate:
        '''存储一个字符串和一个变更日志的类
        每次被pickle都会忘记它当前的值'''

        def __init__(self, value):
                self.value = value
                self.last_change = time.asctime()
                self.history = {}

        def change(self, new_value):
                # 改变当前值，将上一个值记录到历史
                self.history[self.last_change] = self.value
                self.value = new_value)
                self.last_change = time.asctime()

        def print_change(self):
                print 'Changelog for Slate object:'
                for k,v in self.history.items():
                        print '%s\t %s' % (k,v)

        def __getstate__(self):
                # 故意不返回self.value或self.last_change
                # 我们想在反pickle时得到一个空白的slate
                return self.history

        def __setstate__(self):
                # 使self.history = slate，last_change
                # 和value为未定义
                self.history = state
                self.value, self.last_change = None, None
```

##  总结在最后

这本指南的目标是使所有阅读它的人都能有所收获，无论他们有没有使用Python或者进行面向对象编程的经验。如果你刚刚开始学习Python，你会得到宝贵的基础知识，了解如何写出具有丰富特性的，优雅而且易用的类。如果你是中级的Python程序员，你或许能掌握一些新的概念和技巧，以及一些可以减少代码行数的好办法。如果你是专家级别的Python爱好者，你又重新复习了一遍某些可能已经忘掉的知识，也可能顺便了解了一些新技巧。无论你的水平怎样，我希望这趟遨游Python特殊方法的旅行，真的对你产生了魔法般的效果（实在忍不住不说最后这个双关）。

#  【进阶】神奇的元类编程（metaclass）

##   类是如何产生的

类是如何产生？这个问题也许你会觉得很傻。

实则不然，很多初学者只知道使用继承的表面形式来创建一个类，却不知道其内部真正的创建是由 `type` 来创建的。

type？这不是判断对象类型的函数吗？

是的，type通常用法就是用来判断对象的类型。但除此之外，他最大的用途是用来动态创建类。当Python扫描到class的语法的时候，就会调用type函数进行类的创建。

##  如何使用type创建类

首先，`type()` 需要接收三个参数

1. 类的名称，若不指定，也要传入空字符串：`""`
2. 父类，注意以tuple的形式传入，若没有父类也要传入空tuple：`()`，默认继承object
3. 绑定的方法或属性，注意以dict的形式传入

来看个例子

```python
# 准备一个基类（父类）
class BaseClass:
    def talk(self):
        print("i am people")

# 准备一个方法
def say(self):
    print("hello")

# 使用type来创建User类
User = type("User", (BaseClass, ), {"name":"user", "say":say})
```

##  理解什么是元类

什么是类？可能谁都知道，类就是用来创建对象的「模板」。

那什么是元类呢？一句话通俗来说，元类就是创建类的「模板」。

为什么type能用来创建类？因为它本身是一个元类。使用元类创建类，那就合理了。

type是Python在背后用来创建所有类的元类，我们熟知的类的始祖 `object` 也是由type创建的。更有甚者，连type自己也是由type自己创建的，这就过份了。

```python
>>> type(type)
<class 'type'>

>>> type(object)
<class 'type'>

>>> type(int)
<class 'type'>

>>> type(str)
<class 'type'>
```

如果要形象的来理解的话，就看下面这三行话。

- str：用来创建字符串对象的类。
- int：是用来创建整数对象的类。
- type：是用来创建类对象的类。

反过来看

- 一个实例的类型，是类
- 一个类的类型，是元类
- 一个元类的类型，是type

写个简单的小示例来验证下

```python
>>> class MetaPerson(type):
...     pass
...
>>> class Person(metaclass=MetaPerson):
...     pass
...
>>> Tom = Person()
>>> print(type(Tom))
<class '__main__.Person'>
>>> print(type(Tom.__class__))
<class '__main__.MetaPerson'>
>>> print(type(Tom.__class__.__class__))
<class 'type'>
```

下面再来看一个稍微完整的

```python
# 注意要从type继承
class BaseClass(type):
    def __new__(cls, *args, **kwargs):
        print("in BaseClass")
        return super().__new__(cls, *args, **kwargs)

class User(metaclass=BaseClass):
    def __init__(self, name):
        print("in User")
        self.name = name
        
# in BaseClass

user = User("wangbm")
# in User
```

综上，我们知道了类是元类的实例，所以在创建一个普通类时，其实会走元类的 `__new__`。

同时，我们又知道在类里实现了 `__call__` 就可以让这个类的实例变成可调用。

所以在我们对普通类进行实例化时，实际是对一个元类的实例（也就是普通类）进行直接调用，所以会走进元类的 `__call__`

在这里可以借助 「单例的实现」举一个例子，你就清楚了

```python
class MetaSingleton(type):
	def __call__(cls, *args, **kwargs):
		print("cls:{}".format(cls.__name__))
		print("====1====")
		if not hasattr(cls, "_instance"):
			print("====2====")
			cls._instance = type.__call__(cls, *args, **kwargs)
		return cls._instance

class User(metaclass=MetaSingleton):
	def __init__(self, *args, **kw):
		print("====3====")
		for k,v in kw:
			setattr(self, k, v)
```

验证结果

```python
>>> u1 = User('wangbm1')
cls:User
====1====
====2====
====3====
>>> u1.age = 20
>>> u2 = User('wangbm2')
cls:User
====1====
>>> u2.age
20
>>> u1 is u2
True
```



##  使用元类的意义

正常情况下，我们都不会使用到元类。但是这并不意味着，它不重要。假如某一天，我们需要写一个框架，很有可能就需要你对元类要有进一步的研究。

元类有啥用，用我通俗的理解，元类的作用过程：

1. 拦截类的创建
2. 拦截下后，进行修改
3. 修改完后，返回修改后的类

所以，很明显，为什么要用它呢？不要它会怎样？

使用元类，是要对类进行定制修改。使用元类来动态生成元类的实例，而99%的开发人员是不需要动态修改类的，因为这应该是框架才需要考虑的事。

但是，这样说，你一定不会服气，到底元类用来干什么？其实元类的作用就是`创建API`，一个最典型的应用是 `Django ORM`。

##  元类实战：ORM

使用过Django ORM的人都知道，有了ORM，使得我们操作数据库，变得异常简单。

ORM的一个类(User)，就对应数据库中的一张表。id,name,email,password 就是字段。

```python
class User(BaseModel):
    id = IntField('id')
    name = StrField('username')
    email = StrField('email')
    password = StrField('password')

    class Meta:
        db_table = "user"
```

如果我们要插入一条数据，我们只需这样做

```python
# 实例化成一条记录
u = User(id=20180424, name="xiaoming", 
         email="xiaoming@163.com", password="abc123")

# 保存这条记录
u.save()
```

通常用户层面，只需要懂应用，就像上面这样操作就可以了。

但是今天我并不是来教大家如何使用ORM，我们是用来探究ORM内部究竟是如何实现的。我们也可以自己写一个简易的ORM。

从上面的`User`类中，我们看到`StrField`和`IntField`，从字段意思上看，我们很容易看出这代表两个字段类型。字段名分别是`id`,`username`,`email`,`password`。

`StrField`和`IntField`在这里的用法，叫做`属性描述符`。
简单来说呢，`属性描述符`可以实现对属性值的类型，范围等一切做约束，意思就是说变量id只能是int类型，变量name只能是str类型，否则将会抛出异常。

那如何实现这两个`属性描述符`呢？请看代码。

```python
import numbers

class Field:
    pass

class IntField(Field):
    def __init__(self, name):
        self.name = name
        self._value = None

    def __get__(self, instance, owner):
        return self._value

    def __set__(self, instance, value):
        if not isinstance(value, numbers.Integral):
            raise ValueError("int value need")
        self._value = value

class StrField(Field):
    def __init__(self, name):
        self.name = name
        self._value = None

    def __get__(self, instance, owner):
        return self._value

    def __set__(self, instance, value):
        if not isinstance(value, str):
            raise ValueError("string value need")
        self._value = value
```

我们看到`User`类继承自`BaseModel`，这个`BaseModel`里，定义了数据库操作的各种方法，譬如我们使用的`save`函数，也可以放在这里面的。所以我们就可以来写一下这个`BaseModel`类

```python
class BaseModel(metaclass=ModelMetaClass):
    def __init__(self, *args, **kw):
        for k,v in kw.items():
            # 这里执行赋值操作，会进行数据描述符的__set__逻辑
            setattr(self, k, v)
        return super().__init__()

    def save(self):
        db_columns=[]
        db_values=[]
        for column, value in self.fields.items():
            db_columns.append(str(column))
            db_values.append(str(getattr(self, column)))
        sql = "insert into {table} ({columns}) values({values})".format(
                table=self.db_table, columns=','.join(db_columns),
                values=','.join(db_values))
        pass
```

从`BaseModel`类中，save函数里面有几个新变量。

1. fields: 存放所有的字段属性
2. db_table：表名

我们思考一下这个`u`实例的创建过程：

`type` -> `ModelMetaClass` -> `BaseModel` -> `User` -> `u`

这里会有几个问题。

* init的参数是User实例时传入的，所以传入的id是int类型，name是str类型。看起来没啥问题，若是这样，我上面的数据描述符就失效了，不能起约束作用。所以我们希望init接收到的id是IntField类型，name是StrField类型。
* 同时，我们希望这些字段属性，能够自动归类到fields变量中。因为，做为BaseModel，它可不是专门为User类服务的，它还要兼容各种各样的表。不同的表，表里有不同数量，不同属性的字段，这些都要能自动类别并归类整理到一起。这是一个ORM框架最基本的。
* 我们希望对表名有两种选择，一个是User中若指定Meta信息，比如表名，就以此为表名，若未指定就以类名的小写 做为表名。虽然BaseModel可以直接取到User的db_table属性，但是如果在数据库业务逻辑中，加入这段复杂的逻辑，显然是很不优雅的。

上面这几个问题，其实都可以通过元类的`__new__`函数来完成。

下面就来看看，如何用元类来解决这些问题呢？请看代码。

```python
class ModelMetaClass(type):
    def __new__(cls, name, bases, attrs):
        if name == "BaseModel":
            # 第一次进入__new__是创建BaseModel类，name="BaseModel"
            # 第二次进入__new__是创建User类及其实例，name="User"
            return super().__new__(cls, name, bases, attrs)

        # 根据属性类型，取出字段
        fields = {k:v for k,v in attrs.items() if isinstance(v, Field)}

        # 如果User中有指定Meta信息，比如表名，就以此为准
        # 如果没有指定，就默认以 类名的小写 做为表名，比如User类，表名就是user
        _meta = attrs.get("Meta", None)
        db_table = name.lower()
        if _meta is not None:
            table = getattr(_meta, "db_table", None)
            if table is not None:
                db_table = table

        # 注意原来由User传递过来的各项参数attrs，最好原模原样的返回，
        # 如果不返回，有可能下面的数据描述符不起作用
        # 除此之外，我们可以往里面添加我们自定义的参数
        attrs["db_table"] = db_table
        attrs["fields"] = fields
        return super().__new__(cls, name, bases, attrs)
```

##  \__new__ 有什么用？

在没有元类的情况下，每次创建实例，在先进入 `__init__` 之前都会先进入 ` __new__`。

```python
class User:
	def __new__(cls, *args, **kwargs):
		print("in BaseClass")
		return super().__new__(cls)

	def __init__(self, name):
		print("in User")
		self.name = name
```

使用如下

```python
>>> u = User('wangbm')
in BaseClass
in User
>>> u.name
'wangbm'
```

在有元类的情况下，每次创建类时，会都先进入 元类的 `__new__` 方法，如果你要对类进行定制，可以在这时做一些手脚。

综上，元类的`__new__`和普通类的不一样：

- 元类的`__new__` 在创建类时就会进入，它可以获取到上层类的一切属性和方法，包括类名，魔法方法。
- 而普通类的`__new__` 在实例化时就会进入，它仅能获取到实例化时外界传入的属性。

## 附录：参考文章

- [Python Cookbook - 元编程](http://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p09_meta_programming.html)
- [深刻理解Python中的元类](http://blog.jobbole.com/21351/)

#  【进阶】深藏不露的描述符（Descriptor）

在前几节里，有介绍过 property 的用法，property 实现将一系列函数改造成对象属性，并实现参数的访问检查。

很少有人会去深究这里面的原理究竟是什么？实际上对于大部分开发者而言，只要学会应用即可，无需深入探讨。

因此本节内容是 Python 的进阶知识点，若你是新手，请跳过此章节，否则会打击你的学习自信心。

打开天窗说亮话，实际上 property 的内部原理是 `描述符 （Descriptor）`

本篇都将带你全面的学习描述符，一起来感受 Python 语言的优雅。



##  为什么要使用描述符？

假想你正在给学校写一个成绩管理系统，并没有太多编码经验的你，可能会这样子写。

```python
class Student:
    def __init__(self, name, math, chinese, english):
        self.name = name
        self.math = math
        self.chinese = chinese
        self.english = english

    def __repr__(self):
        return "<Student: {}, math:{}, chinese: {}, english:{}>".format(
                self.name, self.math, self.chinese, self.english
            )
```

看起来一切都很合理

```python
>>> std1 = Student('小明', 76, 87, 68)
>>> std1
<Student: 小明, math:76, chinese: 87, english:68>
```

但是程序并不像人那么智能，不会自动根据使用场景判断数据的合法性，如果老师在录入成绩的时候，不小心录入了将成绩录成了负数，或者超过100，程序是无法感知的。

聪明的你，马上在代码中加入了判断逻辑。

```python
class Student:
    def __init__(self, name, math, chinese, english):
        self.name = name
        if 0 <= math <= 100:
            self.math = math
        else:
            raise ValueError("Valid value must be in [0, 100]")
        
        if 0 <= chinese <= 100:
            self.chinese = chinese
        else:
            raise ValueError("Valid value must be in [0, 100]")
      
        if 0 <= chinese <= 100:
            self.english = english
        else:
            raise ValueError("Valid value must be in [0, 100]")
        

    def __repr__(self):
        return "<Student: {}, math:{}, chinese: {}, english:{}>".format(
                self.name, self.math, self.chinese, self.english
            )
```

这下程序稍微有点人工智能了，能够自己明辨是非了。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-832264.png)

程序是智能了，但在`__init__`里有太多的判断逻辑，很影响代码的可读性。巧的是，你刚好学过 Property 特性，可以很好的应用在这里。于是你将代码修改成如下，代码的可读性瞬间提升了不少

```python
class Student:
    def __init__(self, name, math, chinese, english):
        self.name = name
        self.math = math
        self.chinese = chinese
        self.english = english

    @property
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 <= value <= 100:
            self._math = value
        else:
            raise ValueError("Valid value must be in [0, 100]")

    @property
    def chinese(self):
        return self._chinese

    @chinese.setter
    def chinese(self, value):
        if 0 <= value <= 100:
            self._chinese = value
        else:
            raise ValueError("Valid value must be in [0, 100]")

    @property
    def english(self):
        return self._english

    @english.setter
    def english(self, value):
        if 0 <= value <= 100:
            self._english = value
        else:
            raise ValueError("Valid value must be in [0, 100]")

    def __repr__(self):
        return "<Student: {}, math:{}, chinese: {}, english:{}>".format(
                self.name, self.math, self.chinese, self.english
            )
```

程序还是一样的人工智能，非常好。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-815257.png)

你以为你写的代码，已经非常优秀，无懈可击了。



没想到，人外有天，你的主管看了你的代码后，深深地叹了口气：类里的三个属性，math、chinese、english，都使用了 Property 对属性的合法性进行了有效控制。功能上，没有问题，但就是太啰嗦了，三个变量的合法性逻辑都是一样的，只要大于0，小于100 就可以，代码重复率太高了，这里三个成绩还好，但假设还有地理、生物、历史、化学等十几门的成绩呢，这代码简直没法忍。去了解一下 Python 的描述符吧。

经过主管的指点，你知道了「描述符」这个东西。怀着一颗敬畏之心，你去搜索了下关于 描述符的用法。

其实也很简单，一个实现了 `描述符协议` 的类就是一个描述符。

什么描述符协议：在类里实现了 `__get__()`、`__set__()`、`__delete__()` 其中至少一个方法。

- `__get__`： 用于访问属性。它返回属性的值，若属性不存在、不合法等都可以抛出对应的异常。
- `__set__ `：将在属性分配操作中调用。不会返回任何内容。
- `__delete__ `：控制删除操作。不会返回内容。

对描述符有了大概的了解后，你开始重写上面的方法。

如前所述，Score 类是一个描述符，当从 Student 的实例访问 math、chinese、english这三个属性的时候，都会经过 Score 类里的三个特殊的方法。这里的 Score 避免了 使用Property 出现大量的代码无法复用的尴尬。

```python
class Score:
    def __init__(self, default=0):
        self._score = default

    def __set__(self, instance, value):
        if not isinstance(value, int):
            raise TypeError('Score must be integer')
        if not 0 <= value <= 100:
            raise ValueError('Valid value must be in [0, 100]')

        self._score = value

    def __get__(self, instance, owner):
        return self._score

    def __delete__(self):
        del self._score
        
class Student:
    math = Score(0)
    chinese = Score(0)
    english = Score(0)

    def __init__(self, name, math, chinese, english):
        self.name = name
        self.math = math
        self.chinese = chinese
        self.english = english


    def __repr__(self):
        return "<Student: {}, math:{}, chinese: {}, english:{}>".format(
                self.name, self.math, self.chinese, self.english
            )
```

实现的效果和前面的一样，可以对数据的合法性进行有效控制（字段类型、数值区间等）

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-803260.png)

以上，我举了下具体的实例，从最原始的编码风格到 Property ，最后引出描述符。由浅入深，一步一步带你感受到描述符的优雅之处。

到这里，你需要记住的只有一点，就是描述符给我们带来的编码上的便利，它在实现 `保护属性不受修改`、`属性类型检查` 的基本功能，同时有大大提高代码的复用率。



##  描述符的访问规则

描述符分两种：

- 数据描述符：实现了`__get__` 和 `__set__` 两种方法的描述符
- 非数据描述符：只实现了`__get__` 一种方法的描述符

你一定会问，他们有什么区别呢？网上的讲解，我看过几个，很多都把一个简单的东西讲得复杂了。

其实就一句话，**数据描述器和非数据描述器的区别在于：它们相对于实例的字典的优先级不同**。

如果实例字典中有与描述符同名的属性，如果描述符是数据描述符，优先使用数据描述符，如果是非数据描述符，优先使用字典中的属性。

这边还是以上节的成绩管理的例子来说明，方便你理解。

```python
# 数据描述符
class DataDes:
    def __init__(self, default=0):
        self._score = default

    def __set__(self, instance, value):
        self._score = value

    def __get__(self, instance, owner):
        print("访问数据描述符里的 __get__")
        return self._score

# 非数据描述符
class NoDataDes:
    def __init__(self, default=0):
        self._score = default

    def __get__(self, instance, owner):
        print("访问非数据描述符里的 __get__")
        return self._score


class Student:
    math = DataDes(0)
    chinese = NoDataDes(0)

    def __init__(self, name, math, chinese):
        self.name = name
        self.math = math
        self.chinese = chinese
        
    def __getattribute__(self, item):
        print("调用 __getattribute__")
        return super(Student, self).__getattribute__(item)
     
    def __repr__(self):
        return "<Student: {}, math:{}, chinese: {},>".format(
                self.name, self.math, self.chinese)
```

需要注意的是，math 是数据描述符，而 chinese 是非数据描述符。从下面的验证中，可以看出，当实例属性和数据描述符同名时，会优先访问数据描述符（如下面的math），而当实例属性和非数据描述符同名时，会优先访问实例属性（`__getattribute__`）

```python
>>> std = Student('xm', 88, 99)
>>> 
>>> std.math
调用 __getattribute__
访问数据描述符里的 __get__
88
>>> std.chinese
调用 __getattribute__
99
```

讲完了数据描述符和非数据描述符，我们还需要了解的对象属性的查找规律。

当我们对一个实例属性进行访问时，Python 会按 `obj.__dict__` → `type(obj).__dict__` → `type(obj)的父类.__dict__` 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。

##  基于描述符如何实现property

经过上面的讲解，我们已经知道如何定义描述符，且明白了描述符是如何工作的。

正常人所见过的描述符的用法就是上面提到的那些，我想说的是那只是描述符协议最常见的应用之一，或许你还不知道，其实有很多 Python 的特性的底层实现机制都是基于 `描述符协议` 的，比如我们熟悉的`@property` 、`@classmethod` 、`@staticmethod` 和 `super` 等。

先来说说 `property` 吧。

有了前面的基础，我们知道了 property 的基本用法。这里我直接切入主题，从第一篇的例子里精简了一下。

```python
class Student:
    def __init__(self, name):
        self.name = name

    @property
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 <= value <= 100:
            self._math = value
        else:
            raise ValueError("Valid value must be in [0, 100]")
```

不防再简单回顾一下它的用法，通过property装饰的函数，如例子中的 math 会变成 Student 实例的属性。而对 math 属性赋值会进入 使用 `math.setter` 装饰函数的逻辑代码块。

为什么说 property 底层是基于描述符协议的呢？通过 PyCharm 点击进入 property 的源码，很可惜，只是一份类似文档一样的伪源码，并没有其具体的实现逻辑。

不过，从这份伪源码的魔法函数结构组成，可以大体知道其实现逻辑。

这里我自己通过模仿其函数结构，结合「描述符协议」来自己实现类 `property` 特性。

代码如下：

```python
class TestProperty(object):

    def __init__(self, fget=None, fset=None, fdel=None, doc=None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        self.__doc__ = doc

    def __get__(self, obj, objtype=None):
        print("in __get__")
        if obj is None:
            return self
        if self.fget is None:
            raise AttributeError
        return self.fget(obj)

    def __set__(self, obj, value):
        print("in __set__")
        if self.fset is None:
            raise AttributeError
        self.fset(obj, value)

    def __delete__(self, obj):
        print("in __delete__")
        if self.fdel is None:
            raise AttributeError
        self.fdel(obj)


    def getter(self, fget):
        print("in getter")
        return type(self)(fget, self.fset, self.fdel, self.__doc__)

    def setter(self, fset):
        print("in setter")
        return type(self)(self.fget, fset, self.fdel, self.__doc__)

    def deleter(self, fdel):
        print("in deleter")
        return type(self)(self.fget, self.fset, fdel, self.__doc__)
```

然后 Student 类，我们也相应改成如下

```python
class Student:
    def __init__(self, name):
        self.name = name

    # 其实只有这里改变
    @TestProperty
    def math(self):
        return self._math

    @math.setter
    def math(self, value):
        if 0 <= value <= 100:
            self._math = value
        else:
            raise ValueError("Valid value must be in [0, 100]")
```



为了尽量让你少产生一点疑惑，我这里做两点说明：

1. 使用`TestProperty`装饰后，`math` 不再是一个函数，而是`TestProperty` 类的一个实例。所以第二个math函数可以使用 `math.setter` 来装饰，本质是调用`TestProperty.setter` 来产生一个新的 `TestProperty` 实例赋值给第二个`math`。

2. 第一个 `math` 和第二个 `math` 是两个不同 `TestProperty` 实例。但他们都属于同一个描述符类（TestProperty），当对 math 对于赋值时，就会进入 `TestProperty.__set__`，当对math 进行取值里，就会进入 `TestProperty.__get__`。仔细一看，其实最终访问的还是Student实例的 `_math` 属性。

说了这么多，还是运行一下，更加直观一点。

```python
# 运行后，会直接打印这一行，这是在实例化 TestProperty 并赋值给第二个math
in setter
>>>
>>> s1.math = 90
in __set__
>>> s1.math
in __get__
90
```

对于以上理解 `property` 的运行原理有困难的同学，请务必参照我上面写的两点说明。如有其他疑问，可以加微信与我进行探讨。

##  基于描述符如何实现staticmethod

说完了 `property` ，这里再来讲讲  `@classmethod` 和 `@staticmethod` 的实现原理。

我这里定义了一个类，用了两种方式来实现静态方法。

```python
class Test:
    @staticmethod
    def myfunc():
        print("hello")

# 上下两种写法等价

class Test:
    def myfunc():
        print("hello")
    # 重点：这就是描述符的体现
    myfunc = staticmethod(myfunc)
```

这两种写法是等价的，就好像在 `property` 一样，其实以下两种写法也是等价的。

```python
@TestProperty
def math(self):
    return self._math
  
math = TestProperty(fget=math)
```

话题还是转回到 `staticmethod` 这边来吧。

由上面的注释，可以看出 `staticmethod` 其实就相当于一个描述符类，而`myfunc` 在此刻变成了一个描述符。关于 `staticmethod` 的实现，你可以参照下面这段我自己写的代码，加以理解。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-876255.png)

调用这个方法可以知道，每调用一次，它都会经过描述符类的 `__get__` 。

```python
>>> Test.myfunc()
in staticmethod __get__
hello
>>> Test().myfunc()
in staticmethod __get__
hello
```

##  基于描述符如何实现classmethod

同样的 ` classmethod` 也是一样。

```python
class classmethod(object):
    def __init__(self, f):
        self.f = f

    def __get__(self, instance, owner=None):
        print("in classmethod __get__")
        
        def newfunc(*args):
            return self.f(owner, *args)
        return newfunc

class Test:
    def myfunc(cls):
        print("hello")
        
    # 重点：这就是描述符的体现
    myfunc = classmethod(myfunc)
```

验证结果如下

```python
>>> Test.myfunc()
in classmethod __get__
hello
>>> Test().myfunc()
in classmethod __get__
hello
```

讲完了 `property`、`staticmethod`和`classmethod` 与 描述符的关系。我想你应该对描述符在 Python 中的应用有了更深的理解。对于 super 的实现原理，就交由你来自己完成。

##  所有实例共享描述符

通过以上内容的学习，你是不是觉得自己已经对描述符足够了解了呢？

可在这里，我想说以上的描述符代码都有问题。

问题在哪里呢？请看下面这个例子。

```python
class Score:
    def __init__(self, default=0):
        self._value = default

    def __get__(self, instance, owner):
        return self._value

    def __set__(self, instance, value):
        if 0 <= value <= 100:
            self._value = value
        else:
            raise ValueError


class Student:
    math = Score(0)
    chinese = Score(0)
    english = Score(0)

    def __repr__(self):
        return "<Student math:{}, chinese:{}, english:{}>".format(self.math, self.chinese, self.english)
```

Student 里没有像前面那样写了构造函数，但是关键不在这儿，没写只是因为没必要写。

然后来看一下会出现什么样的问题呢

```python
>>> std1 = Student()
>>> std1
<Student math:0, chinese:0, english:0>
>>> std1.math = 85
>>> std1
<Student math:85, chinese:0, english:0>
>>> std2 = Student()
>>> std2 # std2 居然共享了std1 的属性值
<Student math:85, chinese:0, english:0>
>>> std2.math = 100
>>> std1 # std2 也会改变std1 的属性值
<Student math:100, chinese:0, english:0>
```

从结果上来看，std2 居然共享了 std1 的属性值，只要其中一个实例的变量发生改变，另一个实例的变量也会跟着改变。

探其根因，是由于此时 math，chinese，english 三个全部是类变量，导致 std2 和 std1 在访问 math，chinese，english 这三个变量时，其实都是访问类变量。

问题是不是来了？小明和小强的分数怎么可能是绑定的呢？这很明显与实际业务不符。

使用描述符给我们制造了便利，却无形中给我们带来了麻烦，难道这也是描述符的特性吗？

描述符是个很好用的特性，会出现这个问题，是由于我们之前写的描述符代码都是错误的。

描述符的机制，在我看来，只是抢占了访问顺序，而具体的逻辑却要因地制宜，视情况而定。

如果要把 math，chinese，english  这三个变量变成实例之间相互隔离的属性，应该这么写。

```python
class Score:
    def __init__(self, subject):
        self.name = subject

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

    def __set__(self, instance, value):
        if 0 <= value <= 100:
            instance.__dict__[self.name] = value
        else:
            raise ValueError


class Student:
    math = Score("math")
    chinese = Score("chinese")
    english = Score("english")

    def __init__(self, math, chinese, english):
        self.math = math
        self.chinese = chinese
        self.english = english

    def __repr__(self):
        return "<Student math:{}, chinese:{}, english:{}>".format(self.math, self.chinese, self.english)
```

引导程序逻辑进入描述符之后，不管你是获取属性，还是设置属性，都是直接作用于 instance 的。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-146251.png)

这段代码，你可以仔细和前面的对比一下。

不难看出：

- 之前的错误代码，更像是把描述符当做了存储节点。
- 之后的正确代码，则是把描述符直接当做代理，本身不存储值。

以上便是我对描述符的全部分享，希望能对你有所帮助。



## 参考文档

- [Python描述器引导(翻译)](https://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html#python)

