# 【代码美化】如何更好进行变量的命名？

命名是一件困难的事情，要想出一个恰到好处的命名需要一番功夫，尤其我们的母语还不是编程语言所通用的英语。不过这一切都是值得了，好的命名让你的代码更直观，更有表达力。

在进行变量的命名时，应注意：

1. 变量名，最好能体现 『变量用途』，『数据类型』，『单复数』等
2. 变量名，请不要过于随便，如使用数字 1，和字母 a
3. 变量名，不要如不能正确引导，至少要做到不误导。比如 user_list 不应该是一个字典类型 
4. 变量名，请使用蛇形命名法（如 user_info），而不是使用驼峰命名法（userInfo）。

#  【代码美化】写好函数的 6 个建议

Python 虽然好用，但用好真的很难。

尤其是函数部分，只要写不好，后面的一连串人都会遭殃。

看又看不懂，测试起来也麻烦，维护又维护不动，真是让人头疼。

那怎么写好一个 Python 函数呢？

《Writing Idiomatic Python》一书的作者在 Medium 上发表了一篇文章，给出了 6 个建议。

希望能够给你带来帮助。

##  怎样算是好函数？

“好”的 Python 函数和“差”的 Python 函数之间有什么差别呢？每个人都有自己的理解。基于我的理解，如果一个 Python 函数能够符合下面的大部分条件，我会认为它是一个“好”函数：

- 命名合理
- 单一功能
- 包括文档字符串
- 返回一个值
- 不超过 50 行
- 是幂等函数或纯函数

对许多人来说，这些要求可能显得过于苛刻了。

不过，我保证，如果你的函数遵循这些规则，你的代码会非常漂亮，会让其他的程序员都“馋哭”的。

下面，我将一一讨论这些规则，然后总结它们是如何创造“好”函数的。

##  注意命名

在这个问题上，我最喜欢的一句话是：

> 计算机科学中只有两件事很让人头疼：缓存失效和命名。

尽管这听起来很莫名其妙，但给一个事情命名太难了。下面是一个反面案例：

```python
def getknn(from_df):
```

原文中这个代码没有放上去，我们根据上下文信息进行了补充。

这个函数命名的第一个问题是它使用了缩写。

对于那些并不出名的缩略词来说，使用完整的英语单词会更好。缩写单词的唯一原因是为了节省打字时间，但是每个现代编辑器都有自动填充功能，所以你只需要键入一次全名就可以了。

缩写通常是特定领域的。在上面的代码中，KNN 指的是“K-Nearest Neighbors”，df 指的是“DataFrame”，这是一个数据结构。如果另一个不熟悉这些首字母缩写的程序员正在阅读代码，几乎很难看懂。

关于这个函数的名字还有另外两个小瑕疵：

- “get”这个词是无关紧要的。对于大多数命名比较好的函数来说，很明显有一些东西会从函数中返回，它的名字将反映这一点。
- from_df 也不是必要的。如果没有明确的参数名称，函数的文档字符串或类型注释会描述参数的类型。

那么我们如何重命名这个函数呢？很简单：

```python
def k_nearest_neighbors(dataframe):
```

即使是外行，这个函数要计算的内容也很清楚，参数的名称(dataframe)也清楚地表明了参数类型。

##  单一功能

单一功能原则不仅适用于类和模块，也同样适用于函数。

一个函数应该只有一个功能。也就是说，它应该只做一件事。

一个重要的原因是，如果每个函数只做一件事，只有这件事发生了变化，才需要改变这个函数。

此外，如果这个函数的单个功能不再需要了，直接把它删了就行了。

还是用例子来说明吧。下面这个函数，可以做不止一件“事情”:

```python
def calculate_and print_stats(list_of_numbers):
    sum = sum(list_of_numbers)
    mean = statistics.mean(list_of_numbers)
    median = statistics.median(list_of_numbers)
    mode = statistics.mode(list_of_numbers)
    print('-----------------Stats-----------------')
    print('SUM: {}'.format(sum) print('MEAN: {}'.format(mean)
    print('MEDIAN: {}'.format(median)
    print('MODE: {}'.format(mode)
```

这个函数做了两件事：一是计算一组关于数字列表的统计数据，二是将它们打印到 STDOUT。

如果需要计算新的或不同的统计数据，或者需要改变输出的格式，就需要对这个函数进行调整。

所以，这个函数最好写成两个独立的函数：一个用来执行并返回计算结果，另一个用来获取这些结果并打印出来。

这种处理方式，不仅能让测试函数更容易，并且还允许这两个部分有了迁移性，如果合适的话，还可能一起应用到不同的模块中。

在编程中，你会发现好多函数都可以做很多很多事情。同样，为了可读性和可测试性，这些函数应该被分解成更小的函数，每个函数只有一个功能。

##  文档字符串（Docstrings）

虽然每个人似乎都知道 PEP - 8，它定义了 Python 的样式指南，但是很少有人知道 PEP - 257，它是关于文档字符串的。我再这里不简单地重复 PEP - 257 的内容了，你可以在闲暇时读一下。其中的关键内容是：

- 每个函数都需要有一个文档字符串
- 使用适当的语法和标点符号；用完整的句子写
- 首先对函数的作用进行一句话的总结
- 使用说明性语言而不是描述性语言

在编写函数时，要养成写文档字符串的习惯，并在编写函数代码之前尝试写一下。

如果你不能写一个清晰的文档字符串来描述函数做什么，就说明你需要再考虑考虑为什么要写这个函数了。

##  返回值

函数可以被认为是一些独立的程序。它们以参数的形式接受一些输入，并返回一些结果。

参数有没有都可以，但从 Python 内部的角度来看，返回值是必须要有的。你不可能创建一个没有返回值的函数。如果函数没有返回值，Python 会“强制”返回 None。你可以测试一下这段代码：

```python
❯ python3
Python 3.7.0 (default, Jul 232018, 20:22:55)
[Clang 9.1.0 (clang-902.0.39.2)] on darwin
Type "help", "copyright", "credits"or"license"for more information.
>>> def add(a, b):
...   print(a + b)
...
>>> b = add(1, 2)
3
>>> b
>>> b isNone
True
```

你会发现 b 的返回值实际上是 None。即使你写的函数没有返回语句，它仍然会返回一些东西。而且，每个函数都应该返回一个有用的值，测试起来也会更方便。毕竟，你写的代码应该能够被测试。

试想一下，测试上面的 add 函会有多艰难。遵循这个概念，我们应该这样写代码：

```python
with open('foo.txt', 'r') as input_file:
    for line in input_file:
        if line.strip().lower().endswith('cat'):
        # ... do something useful with these lines
```

`if line.strip().lower().endswith(‘cat’):` 这一行能够工作，是因为每个字符串方法( strip ( )、lower ( )、end swith ( ) )都返回一个字符串作为调用函数的结果。

当给定函数没有返回值时，有一些常见的原因：

**“它所做的只是[一些与 I/O 相关的事情，比如将一个值保存到数据库中]。我不能返回任何有用的东西。”**

我不同意。如果操作顺利完成，函数可以返回 True。

**“我们修改了其中一个参数，将其用作参考参数。”**

这里有两点需要注意。首先，尽最大努力避免这种做法。用好了令人惊讶，用不好非常危险。

其次，即使这样做不可行，复制某个参数的成本太高，你也可以回到上一条建议。

**“我需要返回多个值。单独返回一个值是没有意义的。”**

可以使用元组返回多个值。

总是返回一个有用的值，调用者总是可以自由地忽略它们。

##  函数长度

让你读一个 200 行的函数，并说出它是做什么的，你是什么感受？

函数的长度直接影响可读性，从而影响可维护性。所以要保持你的函数简短。50 行是一个随意的数字，在我看来是合理的。你编写的大多数函数应该要短一些。

如果一个函数遵循单一功能原则，它很可能是相当短的。如果它是纯函数或是幂等的(下面讨论) ，它也可能是短的。

那么，如果函数太长，应该怎么做？重构。这会改变程序的结构而不改变其行为。

从一个长函数中提取几行代码，并把它们变成自己的函数。这是缩短长函数的最快、也是最常见的方式。

加上你给所有这些新函数取了合适的名称，因此生成的代码读起来也会更容易。

##  幂等和函数纯度

不管被调用了多少次，幂等函数总是在给定相同参数集的情况下返回相同的值。

结果不依赖于非局部变量、参数的可变性或来自任何 I / O 流的数据。下面的这个 add_three(number)函数是幂等函数：

```python
def add_three(number):
    """Return *number* + 3."""
    return number + 3
```

不管一个人调用 add_three(7)多少次，答案总是 10。以下是一个非幂等函数：

```python
def add_three():
    """Return 3 + the number entered by the user."""
    number = int(input('Enter a number: '))
    return number + 3
```

这个函数的返回值取决于 I / O，即用户输入的数字。对 add_three()的每次调用都会返回不同的值。

如果它被调用两次，用户可以第一次输入 3，第二次输入 7，分别调用 add_three()返回 6 和 10。

幂等性的一个现实中例子是在电梯前点击“向上”按钮。第一次按时，电梯会被“通知”你要上去。因为按按钮是幂等的，所以反复按它都没有什么影响。结果是一样的。

###  为什么幂等很重要？

可维护性和可维护性。幂等函数很容易测试，因为在使用相同的参数时，它们总是返回相同的结果。

测试仅仅是检查通过不同调用返回值的预期值。更重要的是，这些测试很快，这是单元测试中一个重要且经常被忽视的问题。

而在处理幂等函数时，重构是轻而易举的事情。无论如何在函数之外更改代码，使用相同的参数调用它的结果总是一样的。

###  什么是纯函数？

在函数编程中，如果一个函数既幂等又没有可观察到的副作用，它就被认为是纯函数。函数外部的任何东西都不会影响这个值。

然而，这并不意味着函数不能影响非局部变量或 I / O 流之类的事情。例如，如果上面 add_three(number)的幂等版本在返回结果之前打印了结果，那么它仍然被认为是幂等的，因为当它访问 I / O 流时，这个访问与从函数返回的值无关。

调用 print()只是一个副作用：除了返回值之外，还与程序的其他部分或系统本身进行了一些交互。

让我们把我们的 add_three(number)示例再向前推进一步。我们可以编写下面的代码片段来确定调用 add_three(number)的次数：

```python
add_three_calls = 0
def add_three(number):
    """Return *number* + 3."""
    global add_three_calls
    print(f'Returning {number + 3}')
    add_three_calls += 1
    return number + 3
def num_calls():
    """Return the number of times *add_three* was called."""
    return add_three_calls
```

我们现在正在打印到控制台(一个副作用)并修改一个非局部变量(另一个副作用)，但是由于这两者都不影响函数返回的值，它仍然是幂等的。

纯函数没有副作用。它不仅不使用任何“外部数据”来计算值，除了计算和返回所述值之外，它与系统/程序的其余部分都没有交互。因此，虽然我们新的 add_three(number)定义仍然是幂等的，但它不再是纯的。

纯函数没有日志语句或 print()调用。它们不使用数据库或互联网连接。它们不访问或修改非局部变量。它们不调用任何其他非纯函数。

简而言之，它们无法做到爱因斯坦所说的“远距离幽灵般的行动”(在计算机科学环境中)。它们不会以任何方式修改程序或系统的其余部分。

在命令式编程(编写 Python 代码时所做的那种)中，它们是所有函数中最安全的函数。

它们也很容易被测试和维护，甚至比只是幂等函数更重要的是，测试它们基本上可以和执行它们一样快。

测试本身很简单：没有数据库连接或其他外部资源进行模拟，也不需要安装代码，之后也没有什么需要清理的。

明确地说，幂等性和纯函数只是一种期望，不是必需的。也就是说，由于好处很多，我们可能会希望只编写纯函数或幂等函数，但这不现实。

重要的是，我们要有意识开始写代码来隔离副作用和外部依赖性。这会使得我们编写的每一行代码都更容易被测试。



#  【代码美化】自觉遵守 PEP8 代码风格

每个编程语言都有自己的编码，而在 Python 中最受认可的是 PEP 8的编码风格规范。每个写 Python 代码的人都有必要过一遍 PEP 8的内容  ，它可以让你的代码“ 更好看”，更容易被阅读。

##  代码编排

1. 缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。
2. 每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。
3. 类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。

##  文档编排

1. 模块内容的顺序：模块说明和docstring—import—globals&constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。
2. 不要在一句import中多个库，比如import os, sys不推荐。
3. 如果采用from XX import XX引用库，可以省略 module，都是可能出现命名冲突，这时就要采用import XX。

##  空格的使用

总体原则，避免不必要的空格。

1. 各种右括号前不要加空格。
2. 逗号、冒号、分号前不要加空格。
3. 函数的左括号前不要加空格。如Func(1)。
4. 序列的左括号前不要加空格。如list[2]。
5. 操作符左右各加一个空格，不要为了对齐增加空格。
6. 函数默认参数使用的赋值符左右省略空格。
7. 不要将多句语句写在同一行，尽管使用‘；’允许。
8. if/for/while语句中，即使执行语句只有一句，也必须另起一行。

##  注释

总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。

1、块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：

```python
# Description : Module config.
# 
# Input : None
#
# Output : None
```

2、行注释，在一句代码后加注释。比如：(但是这种方式尽量少使用)

```bash
x = x + 1       # Increment x
```

3、避免无谓的注释。

##  文档描述

1. 为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。
2. 如果docstring要换行，参考如下例子,详见PEP 257



```python
"""
Return a foobang
Optional plotz says to frobnicate the bizbaz first.
"""
```

##  命名规范

总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。

1. 尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。
2. 模块命名尽量短小，使用全部小写的方式，可以使用下划线。
3. 包命名尽量短小，使用全部小写的方式，不可以使用下划线。
    4.类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。
4. 异常命名使用CapWords+Error后缀的方式。
5. 全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是**all**机制;二是前缀一个下划线。
6. 函数命名使用全部小写的方式，可以使用下划线。
7. 常量命名使用全部大写的方式，可以使用下划线。
8. 类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。
9. 类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。
10. 类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。
11. 为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明__a,访问时，只能通过Foo._Foo__a，避免歧义。如果子类也叫Foo，那就无能为力了。
12. 类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。



#  【代码美化】Pythonic 代码的 15 个案例

Python由于语言的简洁性，让我们以人类思考的方式来写代码，新手更容易上手，老鸟更爱不释手。

要写出 Pythonic（优雅的、地道的、整洁的）代码，还要平时多观察那些大牛代码，这里明哥收集了一些比较常见的 Pythonic 写法，帮助你养成写优秀代码的习惯。

##  变量交换

交换两个变量的值，正常都会想利用一个中间临时变量来过渡。

```python
tmp = a
a = b
b = tmp
```

能用一行代码解决的（并且不影响可读性的），决不用三行代码。

```python
a,b = b,a
```

##  列表推导

下面是一个非常简单的 for 循环。

```python
my_list = []
for i in range(10):
    my_list.append(i*2)
```

在一个 for 循环中，如果逻辑比较简单，不如试用一下列表的列表推导式，虽然只有一行代码，但也逻辑清晰。

```python
my_list = [i*2 for i in range(10)]
```

##  单行表达式

上面两个案例，都将多行代码用另一种方式写成了一行代码。

这并不意味着，代码行数越少，就越 Pythonic 。

比如下面这样写，就不推荐。

```python
print('hello'); print('world')

if x == 1: print('hello,world')

if <complex comparison> and <other complex comparison>:
    # do something
```

建议还是按照如下的写法来

```python
print（'hello'）
print（'world'）

if x == 1:
    print('hello,world')

cond1 = <complex comparison>
cond2 = <other complex comparison>
if cond1 and cond2:
    # do something
```

##  带索引遍历

使用 for 循环时，如何取得对应的索引，初学者习惯使用 range + len 函数

```python
for i in range(len(my_list)):
    print(i, "-->", my_list[i])
```

更好的做法是利用 enumerate 这个内置函数

```python
for i,item in enumerate(my_list):
    print(i, "-->",item)
```

##  序列解包

使用 `*` 可以对一个列表解包

```python
a, *rest = [1, 2, 3]
# a = 1, rest = [2, 3]

a, *middle, c = [1, 2, 3, 4]
# a = 1, middle = [2, 3], c = 4
```

##  字符串拼接

如果一个列表（或者可迭代对象）中的所有元素都是字符串对象，想要将他们连接起来，通常做法是

```python
letters = ['s', 'p', 'a', 'm']
s=""
for let in letters:
    s += let
```

更推荐的做法是使用 join 函数

```python
letters = ['s', 'p', 'a', 'm']
word = ''.join(letters)
```

##  真假判断

判断一个变量是否为真（假），新手习惯直接使用 `==` 与 True、False、None 进行对比

```python
if attr == True:
    print('True!')

if attr == None:
    print('attr is None!')
```

实际上，`""`、`[]`、`{}` 这些没有任何元素的容器都是假值，可直接使用 `if not xx` 来判断。

```python
if attr:
    print('attr is truthy!')

if not attr:
    print('attr is falsey!')
```

## 访问字典元素

当直接使用 `[]` 来访问字典里的元素时，若key不存在，是会抛异常的，所以新会可能会先判断一下是否有这个 key，有再取之。

```python
d = {'hello': 'world'}
if d.has_key('hello'):
    print(d['hello'])    # prints 'world'
else:
    print('default_value')
```

更推荐的做法是使用 `get` 来取，如果没有该 key 会默认返回 None（当然你也可以设置默认返回值）

```python
d = {'hello': 'world'}

print(d.get('hello', 'default_value')) # prints 'world'
print(d.get('thingy', 'default_value')) # prints 'default_value'
```

##  操作列表

下面这段代码，会根据条件过滤过列表中的元素

```python
a = [3, 4, 5]
b = []
for i in a:
    if i > 4:
        b.append(i)
```

实际上可以使用列表推导或者高阶函数 filter 来实现

```python
a = [3, 4, 5]
b = [i for i in a if i > 4]
# Or:
b = filter(lambda x: x > 4, a)
```

除了 filter 之外，还有 map、reduce 这两个函数也很好用

```python
a = [3, 4, 5]
b = map(lambda i: i + 3, a)
# b: [6,7,8]
```

##  文件读取

文件读取是非常常用的操作，在使用完句柄后，是需要手动调用 close 函数来关闭句柄的

```python
fp = open('file.txt')
print(fp.read())
fp.close()
```

如果代码写得太长，即使你知道需要手动关闭句柄，却也会经常会漏掉。因此推荐养成习惯使用 `with open` 来读写文件，上下文管理器会自动执行关闭句柄的操作

```python
with open('file.txt') as fp:
    for line in fp.readlines():
        print(line)
```

##  代码续行

将一个长度较长的字符串放在一行中，是很影响代码可读性的(下面代码可向左滑动)

```python
long_string = 'For a long time I used to go to bed early. Sometimes, when I had put out my candle, my eyes would close so quickly that I had not even time to say “I’m going to sleep.”'
```

稍等注重代码可读性的人，会使用三个引号 `\`来续写 

```python
long_string = 'For a long time I used to go to bed early. ' \
              'Sometimes, when I had put out my candle, ' \
              'my eyes would close so quickly that I had not even time to say “I’m going to sleep.”'
```

不过，对我来说，我更喜欢这样子写 使用括号包裹 `()`

```python
long_string = (
    "For a long time I used to go to bed early. Sometimes, "
    "when I had put out my candle, my eyes would close so quickly "
    "that I had not even time to say “I’m going to sleep.”"
)
```

导包的时候亦是如此

```python
from some.deep.module.inside.a.module import (
    a_nice_function, another_nice_function, yet_another_nice_function)
```

##  显式代码

有时候出于需要，我们会使用一些特殊的魔法来使代码适应更多的场景不确定性。

```python
def make_complex(*args):
    x, y = args
    return dict(**locals())
```

但若非必要，请不要那么做。无端增加代码的不确定性，会让原先本就动态的语言写出更加动态的代码。

```python
def make_complex(x, y):
    return {'x': x, 'y': y}
```

##  使用占位符

对于暂不需要，却又不得不接收的的变量，请使用占位符

```python
filename = 'foobar.txt'
basename, _, ext = filename.rpartition('.')
```

##  链式比较

对于下面这种写法

```python
score = 85
if score > 80 and score < 90:
    print("良好")
```

其实还有更好的写法

```python
score = 85
if 80 < score < 90:
    print("良好")
```

如果你理解了上面的链式比较操作，那么你应该知道为什么下面这行代码输出的结果是 False

```
>>> False == False == True 
False
```

##  三目运算

对于简单的判断并赋值

```python
age = 20
if age > 18:
    type = "adult"
else:
    type = "teenager"
```

其实是可以使用三目运算，一行搞定。

```python
age = 20  
b = "adult" if age > 18 else "teenager"
```

#  【代码美化】写出漂亮 Python 代码的 20条准则

通常，当我们在学校学习时，编程美学不是一个关键问题。用 Python 写代码时，个人也会遵循自己的风格。然而，当我们必须花大把时间来理解一个人的隐式代码时，这项工作肯定不受欢迎，这种情况同样可能发生在别人阅读我们的代码时。所以，让我们聚焦 Python 之禅和一些改进技巧，从而解决问题。

##  Python 之禅？

对于此前没听说过的人，请在 Python 解释器中键入并执行`import this`，会出现由 Tim Peters 撰写的 19 条指导原则：

1. 优美胜于丑陋；
2. 明了胜于晦涩；
3. 简单胜于复杂；
4. 复杂胜于晦涩；
5. 扁平胜于嵌套；
6. 间隔胜于紧凑；
7. 可读性很重要；
8. 特例不足以特殊到违背这些原则；
9. 实用性胜过纯粹；
10. 永远不要默默地忽视错误；
11. 除非明确需要这样做；
12. 面对模棱两可，拒绝猜测；
13. 解决问题最直接的方法应该有一种，最好只有一种；
14. 当然这是没法一蹴而就的，除非你是荷兰人；
15. 做也许好过不做；
16. 但不想就做还不如不做；
17. 如果方案难以描述明白，那么一定是个糟糕的方案；
18. 如果实现容易描述，那可能是个好方案；
19. 命名空间是一种绝妙的理念，多加利用！

在这篇文章中，我将分享自己对这些格言的理解以及我学到的一些有用的 Python 技巧。

##  优美胜于丑陋

Python 具有语法简单、代码可读性强和命令类似英语等特点，这让编写 Python 代码比使用其他编程语言更容易、更高效。例如，使用`or` `and`和`|| &&`构建语义相同的表达式：

```python
# &&, ||
if a == 0 && b == 1 || c == True:

# and, or
if a == 0 and b == 1 or c == True:

# 这两个逻辑表达式在 Python 中是相同的
# 从语义的角度来看，可以使用选择操作符来构造完全相同的表达式。
```

此外，代码的布局和组成非常重要，有大量资源涉及这个主题。下面是最受欢迎也是我最喜欢的一个：PEP 8——Python 代码风格指南。

https://www.python.org/dev/peps/pep-0008/

浏览完 PEP8 后，看看下面这些文章，其中展示了一些亮点和应用：

- 如何参照 PEP 8 编写漂亮的 Python 代码

    https://realpython.com/python-pep8/

- 优雅的 Python 与 PEP8

    https://medium.com/@mariasurmenok/stylish-python-with-pep8-c3ca93531418

- PEP-8 的陷阱

    https://medium.com/@ian.reinert/the-pitfalls-of-pep-8-b6108b006ed9

永远不要弄乱你的代码。要优雅而美丽。

##  明了胜于晦涩

在 Python 中，良好的命名约定不仅可以提升你的课堂成绩，而且还能让你的代码更明了。幸运的是，你能在 PEP8 中找到一些指导原则，我想在下面强调其中的一些要点。

https://www.python.org/dev/peps/pep-0008/

- 一般来说，避免使用以下名称：
- 太宽泛，如`my_list`；
- 太冗长，如`list_of_machine_learning_data_set`；
- 太模糊，如“1”、“I”、“o”、“O”。
- 包 / 模块名应该全部小写：
- 首选使用一个单词命名；
- 当需要使用多个单词时，使用下划线分割它们。
- 类名应遵循 UpperCaseCamelCase 规范
- 变量\方法\函数应该采用小写（如果需要，用下划线分割）
- 常量名必须全大写（如果需要，用下划线分割）

一切都必须清晰易懂。

##  简单胜于复杂

> 简单比复杂更难：你必须付出巨大艰辛，化繁为简。但这一切到最后都是值得的，因为一旦你做到了，你便能创造奇迹。——乔布斯

很多时候，在处理迭代器时，我们还需要保存迭代计数。Python 通过提供一个名为`enumerate()`的内置函数简化这一任务。以下是一种不成熟的方法，然后是推荐方法：

```python
words = ['Hannibal', 'Hanny', 'Steeve']
# 不成熟的方法
index = 0
for word in words:
    print(index, word)
    index += 1

# 推荐方法
for index, word in enumerate(words):
    print(index, word)
```

另一个示例是使用内置的`zip()`函数，该函数创建一个迭代器，对来自两个或多个迭代器的元素进行配对。你可以使用它来快速有效地解决常见的编程问题，比如创建字典。

```python
subjects = ['math', 'chemistry', 'biology', 'pyhsics']
grades = ['100', '83', '90', '92']
grades_dict = dict(zip(subjects, grades))
print(grades_dict)
```

化繁为简的能力就是消除不必要的东西，保留必要的东西。

##  复杂胜于晦涩

复杂（complex ）和晦涩（complicated ）的区别在于，复杂是指组件的系统层级，晦涩是指难度高。

有时候，尽管我们试图让任务变得简单和傻瓜化，结果可能仍然很糟。

在这种情况下，编程优化变得很有必要，我最喜欢的学习方法是完成 coding challenge websites 上的工作。你可以查看其他人的解决方案，甚至能受到更好算法的启发。

https://www.freecodecamp.org/news/the-10-most-popular-coding-challenge-websites-of-2016-fb8a5672d22f/

对于入门，HackerRank 提供了适合新手程序员的各种级别任务，这非常棒。之后，可以去尝试更专业的网站，比如 Coderbyte 和 Topcoder。

##  扁平胜于嵌套

嵌套模块在 Python 中并不常见——至少我之前没有见过像`module.class.subclass.function`这样的东西——可读性不好。虽然在另一个子模块中构建子模块可能会减少代码行数，但我们不希望用户被不直观的语法所困扰。

##  间隔胜于紧凑

不要在一行中插入太多代码，这会给读者带来压力。建议最大行长度 79 个字符。这样，当使用代码评审工具时，编辑器窗口宽度限制才能很好工作。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-032255.webp)

使用 Python 从 Unsplash 下载图片

##  可读性很重要

代码的阅读次数比编写次数多。考虑下缩进，它让代码更容易阅读，比较下面的代码：

```python
money = 10000000
print("I earn", money, "dollars by writing on medium.")

money = 10_000_000
print(f"I earn {money} dollars by writing on medium.")
```

在本例中，代码结果相同，但是后一段代码通过使用下划线占位符和 f-string 提供了更好的可读性。在 Python 3.6 发布后，f-string 开始让格式化变得更简单，并且在处理包含更多变量的更长的句子时更强大。

> 一个作家的风格不应该在他的思想和读者的思想间设置障碍。

##  特例不足以特殊到违背这些原则

关键是为一般情况提供一贯支持，尝试将一个繁琐的项目重新组织成一个简单形式。例如，根据其功能，结构化类的代码或将其分类到不同的文件中，即使 Python 并不强迫你这样做。由于 Python 是一种多范式编程语言，解决问题的一个强大方法是创建对象，这就是所谓的面向对象编程。

面向对象编程是一种组织程序结构的编程范式，让属性和行为可以被看作是单独对象。它的优点是直观和易于操作，许多教程都很好地解释了这些概念。

##  实用性胜过纯粹

这句格言与前一句相矛盾，它提醒我们保持它们之间的平衡

##  永远不要默默地忽视错误

放过错误最终会留下隐式 Bug，并且这些 Bug 更难被发现。Python 提供了健壮的错误处理，与其他语言相比，程序员使用该工具并不难。

```python
try:
    x = int(input("Please enter an Integer: "))
except ValueError:
    print("Oops! This is not an Integer.")
except Exception as err:
    print(err)
else:
    print('You did it! Great job!')
finally:
    print('ヽ(✿ﾟ▽ﾟ)ノ')

# 1. 这段代码可能中断。
# 2. 如果出现值错误就会触发。
# 3. 处理值错误之外的错误。
# 4. 如果没有触发错误就执行。
# 5. 不管是否触发错误都执行。
```

根据 Python 文档：“即使一个语句或表达式在语法上是正确的，在试图执行它时也可能会导致错误。”特别是对于大型项目，我们不希望在耗时的计算后，代码崩溃。这就是异常管理的魅力所在。

##  除非明确需要这样做

在某些情况下，小错误不会困扰你。不过，也许你想捕获特定错误。要获得关于特定错误消息的更多细节，我建议阅读官方的内置异常文档并找到你需要的内容。

https://docs.python.org/3/library/exceptions.html

##  面对模棱两可，拒绝猜测

> 重要的是要不断学习，享受挑战，容忍歧义。我们都不知道最终会怎样。——玛蒂娜·霍纳

这句话优雅而抒情，但在编程中不是一个好的隐喻。歧义可能是指不清楚的语法、复杂的程序结构或触发错误消息的错误。例如，第一次使用`numpy`模块时的一个简单错误：

```python
import numpy as np

a = np.arange(5)
print(a < 3)
if a < 3:
    print('smaller than 3')
```

> ValueError: 具有多个元素的数组的真值不明确，请使用 a.any() 或 a.all()

如果执行上面代码，你将在输出中发现一个由 5 个布尔值组成的数组，表明值在 3 以下。因此，`if`语句不可能确定状态。消息中显示的内置函数`.all`() 和`.any()`用于代替 And/Or。

```python
import numpy as np

a = np.array([True, True, True])
b = np.array([False, True, True])
c = np.array([False, False, False])

print(a.all())
print(a.any())

print(b.all())
print(b.any())

print(c.all())
print(c.any())
```

输出表明，`.all()`仅在所有项都为`True`时才返回`True`，而.`any()`在有一项为`True`时就返回`True`。

##  解决问题最直接的方法应该有一种，最好只有一种

想想为什么 Python 被描述为一种易于学习的编程语言。Python 具有非凡的内置函数 / 库和高度的可扩展性，它鼓励程序员优雅地编写代码。尽管有更多的解决方案可以提供灵活性，但对于同一个问题，它们可能会花费更多时间。



![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-986254.webp)

输入 import antigravity 并执行

##  当然这是没法一蹴而就的，除非你是荷兰人

Python 之父 Guido van Rossum 是一位荷兰程序员，他让这句格言变得无可争议。你不会声称自己比他更了解 Python……至少我不会。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-002258.webp)

照片来自 GitHub

##  做也许好过不做

> 你可以拖延，但时间不会，失去的时间一去不复返。——本杰明·富兰克林

对于那些像我一样患有拖延症，正在寻求改变的人，看看这个，和恐慌怪兽合作。

https://embed.ted.com/talks/tim_urban_inside_the_mind_of_a_master_procrastinator

另一方面，这个格言的另一个方面是阻止你过度计划，这并不比看 Netflix 更有效率。

拖延和过度计划的共同特征就是“什么都做不了。”

##  不想就做还不如不做

“做也许好过不做”并不意味着计划没用。把你的想法写下来，设定一个要征服的目标，比不想就做要好。

例如，我通常在每个星期天花一个小时来制定我的周计划，并在睡觉前更新我明天的计划，看看有什么需要推迟的事情。

##  如果解决方案难以解释清楚，那一定很糟糕

回想一下“复杂胜于晦涩”的理念。通常，晦涩的代码意味着弱设计，特别是在像 Python 这样的高级编程语言中。

然而，在某些情况下，其领域知识的复杂性可能会让实现难以解释，而如何优化让其明晰易懂至关重要。这里有一个规划项目指南，可以给你提供帮助。

https://docs.python-guide.org/writing/structure/

##  如果实现容易描述，那可能是个好方案

使设计（甚至人们的生活）更容易，即使背景知识可能很深刻，这是编程的专业知识，我认为也是编程中最困难的部分。

利用 Python 的简单性和可读性来实现一些疯狂的想法。

##  命名空间是一种绝妙的理念，多加利用！

最后但同样重要的是，命名空间是一组符号，用于组织各种对象，以便这些对象可以通过惟一的名称引用。在 Python 中，命名空间是由以下元素组成的系统：

1. 内置命名空间：可以在不创建自定义函数或导入模块（如`print()`函数）的情况下调用。
2. 全局命名空间：当用户创建一个类或函数时，将创建一个全局命名空间。
3. 局部命名空间：局部作用域中的命名空间。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-016253.webp)

命名空间关系图

命名空间系统可以防止 Python 模块名称之间产生冲突。

延展阅读：

https://medium.com/better-programming/how-to-make-python-programming-more-elegant-and-decent-4b5962695aa9



#  【代码美化】择优选择 EAFP 和 LBYL 代码风格

##  EAFP 风格

Python 有一套自己的哲学，其中 EAFP 是其中比较有名的。它的全称是

> Easier to Ask for Forgiveness than Permission

强行翻译一下，就是 **寻求原谅比获得授权更容易**。

对于第一次接触这个 EAFP 名词的同学，可能不好理解这句话的意思。

没有关系，咱先看一下 EAFP 风格的代码是什么样的，你就能立马 get 了。

下面这段代码，我在 try 里使用 `[key]` 的方法获取字典一个 value 值，但是由于 profile 并没有 age 的键。所以会抛出异常。

```python
profile = {"name": "王炳明"}
try:
    print(profile["age"])
except KeyError:
    print("Key is not exist")
```

像这种，先相信代码本身没有问题，任其执行，有问题了再通过捕获进行处理的代码风格，就叫做 EAFP 风格。

我个人把这种写法，称之为 **面向崩溃编程**。

##  LBYL 风格

LBYL 的全称是 

> Look Before You Leap

翻译一下，就是 `你跳之前先看看`，这是一种比较保守的写法。这种写法可能会有让你写很多的 if 判断语句来规避可能出现错误的各种场景。

还是以上面的代码为例，使用 LBYL 风格来写的话，是这样的

```python
profile = {"name": "王炳明"}
if "age" in profile:
    print(profile["age"])
else:
    print("Key is not exist")
```

##  选择哪种风格？

用一个生动的例子来描述他们的区别。

有一对小伙伴一起约去某名山游玩，由于这座山比较险峻，有各种各校的悬崖。

伙伴A，是一个比较大胆开放的人，他自己穿上了降落伞，所以在游玩的时候，无所顾忌，都不看路，一旦不小心跌落悬崖了也有降落伞保命。  -- `这是 EAFP 风格`

而伙伴B，是一个比较保守的人，他没有穿降落伞，所以每走一走都要看一看，前面是不是悬崖。-- `这是 LBLY 风格`



EAFP虽然是 Python 比较推荐的一种编码风格，但更多情况下，这两种风格会同时存在于你的代码中代码风格的目的是增强代码的可读性和健壮性，在有些场景下 EAFP 风格更加易读，在有些场景下 LBLY 风格更加易读，因此不必纠结使用哪种风格，具体情况应该具体分析。



#  【代码美化】使用 flake8 保证代码风格

`pep8` 是Python 语言的一个代码编写规范。如若你是新手，目前只想快速掌握基础，而不想过多去注重代码的的编写风格（虽然这很重要），那你可以尝试一下这个工具 - `autopep8`

首先在全局环境中（不要在虚拟环境中安装），安装一下这个工具。

```bash
$ sudo pip install autopep8
```

然后在 PyCharm 导入这个工具，具体设置如下图

```
Name: AutoPep8
Description: autopep8 your code
Program: autopep8
Arguments: --in-place --aggressive --aggressive $FilePath$
Working directory: $ProjectFileDir$
Output filters: $FILE_PATH$\:$LINE$\:$COLUMN$\:.*
```

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-741252.png)

我随意写了一段不符合 pep8 规范的代码。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-771251.png)

点击右键，选择 `External Tools` -> `AutoPep8`

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-757256.png)

看一下效果，还是挺明显的。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-786253.png)

你可能会说，Pycharm 本身就自带这个功能了呀，快捷键 `Command`+`Option`+`L` ，就可以实现一键pep8了。你可以对比一下，Pycharm 自带的代码 pep8 化功能 并没有像这个`autopep8` 来得彻底。 我相信你最终的选择肯定是后者。

