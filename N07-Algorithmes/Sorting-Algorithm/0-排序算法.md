# 排序算法的性能

|排序法|	平均时间|	最差情形|	稳定度	|额外空间|	备注|
|:-:|:-:|:-:|:-:|:-:|:-|
|冒泡	|O(n2)	|O(n2)	|稳定	|O(1)	|n小时较好|
|交换	|O(n2)	|O(n2)	|不稳定	|O(1)	|n小时较好|
|选择	|O(n2)	|O(n2)	|不稳定	|O(1)	|n小时较好|
|插入	|O(n2)	|O(n2)	|稳定	|O(1)	|大部分已排序时较好|
|基数	|O(logRB)	|O(logRB)	|稳定	|O(n)	|B是真数(0-9)，R是基数(个十百)|
|Shell	|O(nlogn)	|O(ns) 	|不稳定	|O(1)	|s是所选分组|
|快速	|O(nlogn)	|O(n2)	|不稳定	|O(nlogn)	|n大时较好|
|归并	|O(nlogn)	|O(nlogn)	|稳定	|O(1)	|n大时较好|
|堆	|O(nlogn)	|O(nlogn)	|不稳定	|O(1)	|n大时较好|

# 常见排序算法

## 插入排序

插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。
　
```python
def insert_sort(lists):
    # 插入排序
    count = len(lists)
    for i in range(1, count):
        key = lists[i]
        j = i - 1
        while j >= 0:
            if lists[j] > key:
                lists[j + 1] = lists[j]
                lists[j] = key
            j -= 1
    return lists

insert_sort([2,5,10,8,12,6,7,4,3,13,9])
```

## 希尔排序

希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

```python
def shell_sort(lists):
    # 希尔排序
    count = len(lists)
    step = 2
    group = count / step
    while group > 0:
        for i in range(0, group):
            j = i + group
            while j < count:
                k = j - group
                key = lists[j]
                while k >= 0:
                    if lists[k] > key:
                        lists[k + group] = lists[k]
                        lists[k] = key
                    k -= group
                j += group
        group /= step
    return lists

shell_sort([2,5,10,8,12,6,7,4,3,13,9])
```

## 冒泡排序

它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

```python
def bubble_sort(lists):
    # 冒泡排序
    count = len(lists)
    for i in range(0, count):
        for j in range(i + 1, count):
            if lists[i] > lists[j]:
                lists[i], lists[j] = lists[j], lists[i]
    return lists

bubble_sort([2,5,10,8,12,6,7,4,3,13,9])
```


## 快速排序

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j, 交换a[i]和a[j],重复上面的过程，直到i>j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。

```python
def quick_sort(lists, left, right):
    # 快速排序
    if left >= right:
        return lists
    key = lists[left]
    low = left
    high = right
    while left < right:
        while left < right and lists[right] >= key:
            right -= 1
        lists[left] = lists[right]
        while left < right and lists[left] <= key:
            left += 1
        lists[right] = lists[left]
    lists[right] = key
    quick_sort(lists, low, left - 1)
    quick_sort(lists, left + 1, high)
    return lists

quick_sort([2,5,10,8,12,6,7,4,3,13,9],0,10)
```

## 选择排序

基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。

选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。

```python
def select_sort(lists):
    # 选择排序
    count = len(lists)
    for i in range(0, count):
        min = i
        for j in range(i + 1, count):
            if lists[min] > lists[j]:
                min = j
        lists[min], lists[i] = lists[i], lists[min]
    return lists

select_sort([2,5,10,8,12,6,7,4,3,13,9])
```


## 堆排序

首先要知道的是，数组可以又一个二叉树来表示，既然是二叉树，它的表示也就是第一层一个节点，第二层两个节点，第三层四个节点，第四层八个节点。。。数组元素的放置位置就是挨着放，第一个元素放在第一层的唯一一个点，第二层的两个点放接下来的两个元素，即元素2和3，第三层的四个点，继续接下来的4个元素，即元素5、6、7、8。。。一直这么放下去，由于是二叉树，每次两分，所以树的深度是log2N。对于每一个节点，它的根节点在它的下一层，数组上的位置，就是2倍。         
这就是一个数组的二叉树形式的理解，这是堆排序的基础（事实上这并不需要代码完成）。接下来的任务，是要把这个二叉树改造成所谓的堆。堆可以这样去理解，也就是对于二叉树来说，父节点的值大于子节点。在上面数组对应的二叉树中，我们需要将它改造成一个父节点值大于子节点值的二叉树。办法是从后向前的遍历每个父节点，每个父节点和两个子节点进行对比，并进行调整，直到形成一个堆——这个时候，根节点的值是最大的。

将这个跟节点的值和数组最后一个值进行换位，后然继续上面的调整，形成堆，找到根节点，与倒数第二个值换位。。。以此类推，直到数组排序完毕
由于堆排序的堆的高度为log2N，而它每次调整的时候需要对比的次数趋向于N，所以整体的时间复杂度是N*log2N，但是它并不稳定的一种算法，依赖于给定的待排序数组。另外，堆排序是在原来的数组（二叉树）上进行调整和换位，并没有申请多余的空间。和冒泡一类两两相比的排序算法比较，堆排序主要是使用二叉树构建堆的方式，传递的排序结果。

我们知道堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1, n/2-2, ...1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法

```python
def heapSort(L):
    assert (type(L) == type(['']))
    length = len(L)
    if length == 0 or length == 1:
        return L

    def sift_down(L, start, end):
        root = start
        while True:
            child = 2 * root + 1
            if child > end: break
            if child + 1 <= end and L[child] > L[child + 1]:
                child += 1
            if L[root] > L[child]:
                L[root], L[child] = L[child], L[root]
                root = child
            else:
                break

    for start in range((len(L) - 2) / 2, -1, -1):
        sift_down(L, start, len(L) - 1)

    for end in range(len(L) - 1, 0, -1):
        L[0], L[end] = L[end], L[0]
        sift_down(L, 0, end - 1)
    return L

lists=[2,5,10,8,12,6,7,4,3,13,9]
heapSort(lists)
```

## 并归排序

归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。

归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。

```python
def merge(left, right):
    i, j = 0, 0
    result = []
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result += left[i:]
    result += right[j:]
    return result


def merge_sort(lists):
    # 归并排序
    if len(lists) <= 1:
        return lists
    num = len(lists) / 2
    left = merge_sort(lists[:num])
    right = merge_sort(lists[num:])
    return merge(left, right)

lists=[2,5,10,8,12,6,7,4,3,13,9]
merge_sort(lists)
```

## 基数排序

基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

```python

import math

def radix_sort(lists, radix=10):
    k = int(math.ceil(math.log(max(lists), radix)))
    bucket = [[] for i in range(radix)]
    for i in range(1, k+1):
        for j in lists:
            bucket[j/(radix**(i-1)) % (radix**i)].append(j)
        del lists[:]
        for z in bucket:
            lists += z
            del z[:]
    return lists

lists=[2,5,10,8,12,6,7,4,3,13,9]
merge_sort(lists)
```

## 桶排序

桶排序是一种计数排序方法，用标记过号码的桶，去装待排序数组中的数据，数组元素的值对应着桶的编号，最后按桶的标号取出。具体的方式是，获取待排序数组的最大值，以这个最大值建立数组，并将所有元素置为0，遍历待排序数组，如果元素的值和桶的编号相等，则桶的值自动加一。遍历完毕后，按照桶的编号倒序输入

```python
def countSort(l):
    assert(type(l)==type(['']))
    length = len(l)
    if length==0 or length==1:
        return l
    m = max(l)
    ret = []
    storage = [0]*(m+1)
    def count(x):
        storage[x]+=1
    def pop(x):
        tem = storage[x]
        while tem>0:
            ret.append(x)
            tem-=1
    map(lambda x:count(x),l)
    map(lambda x:pop(x),xrange(m,0,-1))
    return ret

lists=[2,5,10,8,12,6,7,4,3,13,9]
countSort(lists)
```

## 二叉树排序

这是另一个使用树进行排序的方法，和堆排序不同的是，这种方法需要这正的构建二叉树，而不是使用数组的二叉树形式。它的核心在与构建二叉树时的顺序以及输入二叉树时的顺序。

具体方法是，依次读取待排序数组的元素，并将其添加为一个二叉树的节点；添加的时候，按值的大小放在节点的左右，如果左右节点已经被占用，则递归到子节点进行添加。二叉树输出的时候，采取前序遍历或者后序遍历的方式输出。

```python
def binaryTreeSort(l):
    assert (type(l) == type(['']))
    length = len(l)
    if length == 0 or length == 1:
        return l

class Node:
	def __init__(self, value=None, left=None, right=None):
		self.__value = value
		self.__left = left
		self.__right = right

	@property
	def value(self):
		return self.__value

	@property
	def left(self):
		return self.__left

	@property
	def right(self):
		return self.__right

class BinaryTree:
	def __init__(self, root=None):
		self.__root = root
		self.__ret = []

	@property
	def result(self):
		return self.__ret

	def add(self, parent, node):
		if parent.value > node.value:
			if not parent.left:
				parent.left = node
			else:
				self.add(parent.left, node)
			pass
		else:
			if not parent.right:
				parent.right = node
			else:
				self.add(parent.right, node)

	def Add(self, node):
		if not self.__root:
			self.__root = node
		else:
			self.add(self.__root, node)

	def show(self, node):
		if not node:
			return
		if node.right:
			self.show(node.right)
		self.__ret.append(node.value)
		if node.left:
			self.show(node.left)

	def Show(self):
		self.show(self.__root)

b = BinaryTree()
for i in l:
	b.Add(Node(i))
b.Show()
return b.result

lists=[2,5,10,8,12,6,7,4,3,13,9]
binaryTreeSort(lists)
```


## 位图排序

```python
def setSort(L):
    assert (type(L) == type(['']))
    length = len(L)
    if length == 0 or length == 1:
        return L
    BIT = 32
    SHIFT = 5
    MASK = 0x1f
    N = 1 + len(L) / BIT
    a = [0] * N
    ret = []

def clearmap(i):
	a[i >> SHIFT] &= ~(1 << (i & MASK))

def setmap(i):
	a[i >> SHIFT] |= (1 << (i & MASK))

def showmap(i):
	for i in xrange(N):
		for j in xrange(32):
			if a[i] & (1 << j):
				ret.append(32 * i + j)

map(lambda x: clearmap(x), L)
map(lambda x: setmap(x), L)
map(lambda x: showmap(x), xrange(N))
if ret:
	return ret

lists=[2,5,10,8,12,6,7,4,3,13,9]
setSort(lists)
```


