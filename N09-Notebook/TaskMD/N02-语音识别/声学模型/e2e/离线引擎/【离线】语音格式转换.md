# 语音格式转换-FFMPEG

## 离线识别引擎FFMPEG源代码清单

### 概述

#### 编写目的

文档编写目的是为代码维护者能清楚了解代码模块的具体功能及分布位置，本文档的读者对象为开发人员和测试人员。

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件。

### 运行环境

#### 软件环境

|   分类   |  名称  |  版本   |
| :------: | :----: | :-----: |
| 操作系统 | Centos | 7.0以上 |
|  数据库  | Redis  |  3.2.0  |
|  数据库  | Mysql  |  5.7.6  |
| 能力接口 | Tomcat | 9.0.35  |

#### 硬件环境

|   服务器    |                最低配置                |                推荐配置                 |
| :---------: | :------------------------------------: | :-------------------------------------: |
| redis服务器 |        CPU：1 <br />内存：256M         |          CPU：1 <br />内存：1G          |
| 识别服务器  | CPU：4 <br />内存：10G <br />磁盘：20G | CPU：10 <br />内存：15G <br />磁盘：30G |



### 3.源代码清单

#### 代码清单

<table>
<tbody>
<tr class="odd">
<td>程序名</td>
<td>程序路径</td>
</tr>
<tr class="even">
<td><p>cmdutils.c</p>
<p>cmdutils.h</p>
<p>ffmpeg.c</p>
<p>ffmpeg_filter.c</p>
<p>ffmpeg.h</p>
<p>ffmpeg_hw.c</p>
<p>ffmpeg_opt.c</p>
<p>ffmpeg_qsv.c</p>
<p>ffmpeg_videotoolbox.c</p>
<p>ffplay.c</p>
<p>ffprobe.c</p>
<p>Makefile</p></td>
<td>ffmpeg-4.3/fftools</td>
</tr>
<tr class="odd">
<td><p>012v.c</p>
<p>4xm.c</p>
<p>8bps.c</p>
<p>8svx.c</p>
<p>a64colors.h</p>
<p>a64multienc.c</p>
<p>a64tables.h</p>
<p>aac_ac3_parser.c</p>
<p>aac_ac3_parser.h</p>
<p>aac_adtstoasc_bsf.c</p>
<p>aaccoder.c</p>
<p>aaccoder_trellis.h</p>
<p>aaccoder_twoloop.h</p>
<p>aacdec.c</p>
<p>aacdec_fixed.c</p>
<p>aacdectab.h</p>
<p>aacdec_template.c</p>
<p>aac_defines.h</p>
<p>aacenc.c</p>
<p>aacenc.h</p>
<p>aacenc_is.c</p>
<p>aacenc_is.h</p>
<p>aacenc_ltp.c</p>
<p>aacenc_ltp.h</p>
<p>aacenc_pred.c</p>
<p>aacenc_pred.h</p>
<p>aacenc_quantization.h</p>
<p>aacenc_quantization_misc.h</p>
<p>aacenctab.c</p>
<p>aacenctab.h</p>
<p>aacenc_tns.c</p>
<p>aacenc_tns.h</p>
<p>aacenc_utils.h</p>
<p>aac.h</p>
<p>aac_parser.c</p>
<p>aacps.c</p>
<p>aacpsdata.c</p>
<p>aacpsdsp_fixed.c</p>
<p>aacpsdsp_float.c</p>
<p>aacpsdsp.h</p>
<p>aacpsdsp_template.c</p>
<p>aacps_fixed.c</p>
<p>aacps_fixed_tablegen.c</p>
<p>aacps_fixed_tablegen.h</p>
<p>aacps_float.c</p>
<p>aacps.h</p>
<p>aacps_tablegen.c</p>
<p>aacps_tablegen.h</p>
<p>aacps_tablegen_template.c</p>
<p>aacpsy.c</p>
<p>aacsbr.c</p>
<p>aacsbrdata.h</p>
<p>aacsbr_fixed.c</p>
<p>aacsbr_fixed_tablegen.h</p>
<p>aacsbr.h</p>
<p>aacsbr_tablegen_common.h</p>
<p>aacsbr_tablegen.h</p>
<p>aacsbr_template.c</p>
<p>aactab.c</p>
<p>aactab.h</p>
<p>aandcttab.c</p>
<p>aandcttab.h</p>
<p>aasc.c</p>
<p>ac3.c</p>
<p>ac3dec.c</p>
<p>ac3dec_data.c</p>
<p>ac3dec_data.h</p>
<p>ac3dec_fixed.c</p>
<p>ac3dec_float.c</p>
<p>ac3dec.h</p>
<p>ac3dsp.c</p>
<p>ac3dsp.h</p>
<p>ac3enc.c</p>
<p>ac3enc_fixed.c</p>
<p>ac3enc_float.c</p>
<p>ac3enc.h</p>
<p>ac3enc_opts_template.c</p>
<p>ac3enc_template.c</p>
<p>ac3.h</p>
<p>ac3_parser.c</p>
<p>ac3_parser.h</p>
<p>ac3_parser_internal.h</p>
<p>ac3tab.c</p>
<p>ac3tab.h</p>
<p>acelp_filters.c</p>
<p>acelp_filters.h</p>
<p>acelp_pitch_delay.c</p>
<p>acelp_pitch_delay.h</p>
<p>acelp_vectors.c</p>
<p>acelp_vectors.h</p>
<p>adpcm.c</p>
<p>adpcm_data.c</p>
<p>adpcm_data.h</p>
<p>adpcmenc.c</p>
<p>adpcm.h</p>
<p>adts_header.c</p>
<p>adts_header.h</p>
<p>adts_parser.c</p>
<p>adts_parser.h</p>
<p>adx.c</p>
<p>adxdec.c</p>
<p>adxenc.c</p>
<p>adx.h</p>
<p>adx_parser.c</p>
<p>agm.c</p>
<p>aic.c</p>
<p>alac.c</p>
<p>alac_data.c</p>
<p>alac_data.h</p>
<p>alacdsp.c</p>
<p>alacdsp.h</p>
<p>alacenc.c</p>
<p>aliaspixdec.c</p>
<p>aliaspixenc.c</p>
<p>allcodecs.c</p>
<p>alsdec.c</p>
<p>amfenc.c</p>
<p>amfenc.h</p>
<p>amfenc_h264.c</p>
<p>amfenc_hevc.c</p>
<p>amr.h</p>
<p>amrnbdata.h</p>
<p>amrnbdec.c</p>
<p>amrwbdata.h</p>
<p>amrwbdec.c</p>
<p>anm.c</p>
<p>ansi.c</p>
<p>apedec.c</p>
<p>apng.h</p>
<p>aptx.c</p>
<p>aptxdec.c</p>
<p>aptxenc.c</p>
<p>aptx.h</p>
<p>arbc.c</p></td>
<td>ffmpeg-4.3/libavcodec</td>
</tr>
<tr class="even">
<td><p>alldevices.c</p>
<p>alsa.c</p>
<p>alsa_dec.c</p>
<p>alsa_enc.c</p>
<p>alsa.h</p>
<p>android_camera.c</p>
<p>avdevice.c</p>
<p>avdevice.h</p>
<p>avdeviceres.rc</p>
<p>avfoundation.m</p>
<p>bktr.c</p>
<p>caca.c</p>
<p>decklink_common_c.h</p>
<p>decklink_common.cpp</p>
<p>decklink_common.h</p>
<p>decklink_dec_c.c</p>
<p>decklink_dec.cpp</p>
<p>decklink_dec.h</p>
<p>decklink_enc_c.c</p>
<p>decklink_enc.cpp</p>
<p>decklink_enc.h</p>
<p>dshow.c</p>
<p>dshow_capture.h</p>
<p>dshow_common.c</p>
<p>dshow_crossbar.c</p>
<p>dshow_enummediatypes.c</p>
<p>dshow_enumpins.c</p>
<p>dshow_filter.c</p>
<p>dshow_pin.c</p>
<p>fbdev_common.c</p>
<p>fbdev_common.h</p>
<p>fbdev_dec.c</p>
<p>fbdev_enc.c</p>
<p>file_open.c</p>
<p>gdigrab.c</p>
<p>iec61883.c</p>
<p>internal.h</p>
<p>jack.c</p>
<p>kmsgrab.c</p>
<p>lavfi.c</p>
<p>libavdevice.v</p>
<p>libcdio.c</p>
<p>libdc1394.c</p>
<p>Makefile</p>
<p>openal-dec.c</p>
<p>opengl_enc.c</p>
<p>opengl_enc_shaders.h</p>
<p>oss.c</p>
<p>oss_dec.c</p>
<p>oss_enc.c</p>
<p>oss.h</p>
<p>pulse_audio_common.c</p>
<p>pulse_audio_common.h</p>
<p>pulse_audio_dec.c</p>
<p>pulse_audio_enc.c</p>
<p>reverse.c</p>
<p>sdl2.c</p>
<p>sndio.c</p>
<p>sndio_dec.c</p>
<p>sndio_enc.c</p>
<p>sndio.h</p></td>
<td>ffmpeg-4.3/libavdevice</td>
</tr>
<tr class="odd">
<td><p>aeval.c</p>
<p>af_acontrast.c</p>
<p>af_acopy.c</p>
<p>af_acrossover.c</p>
<p>af_acrusher.c</p>
<p>af_adeclick.c</p>
<p>af_adelay.c</p>
<p>af_aderivative.c</p>
<p>af_aecho.c</p>
<p>af_aemphasis.c</p>
<p>af_afade.c</p>
<p>af_afftdn.c</p>
<p>af_afftfilt.c</p>
<p>af_afir.c</p>
<p>af_afir.h</p>
<p>af_aformat.c</p>
<p>af_agate.c</p>
<p>af_aiir.c</p>
<p>af_alimiter.c</p>
<p>af_amerge.c</p>
<p>af_amix.c</p>
<p>af_amultiply.c</p>
<p>af_anequalizer.c</p>
<p>af_anlmdn.c</p>
<p>af_anlmdndsp.h</p>
<p>af_anlms.c</p>
<p>af_anull.c</p>
<p>af_apad.c</p>
<p>af_aphaser.c</p>
<p>af_apulsator.c</p>
<p>af_aresample.c</p>
<p>af_arnndn.c</p>
<p>af_asetnsamples.c</p>
<p>af_asetrate.c</p>
<p>af_ashowinfo.c</p>
<p>af_asoftclip.c</p>
<p>af_asr.c</p>
<p>af_astats.c</p>
<p>af_asubboost.c</p>
<p>af_atempo.c</p>
<p>af_axcorrelate.c</p>
<p>af_biquads.c</p>
<p>af_bs2b.c</p>
<p>af_channelmap.c</p>
<p>af_channelsplit.c</p>
<p>af_chorus.c</p>
<p>af_compand.c</p>
<p>af_compensationdelay.c</p>
<p>af_crossfeed.c</p>
<p>af_crystalizer.c</p>
<p>af_dcshift.c</p>
<p>af_deesser.c</p>
<p>af_drmeter.c</p>
<p>af_dynaudnorm.c</p>
<p>af_earwax.c</p>
<p>af_extrastereo.c</p>
<p>af_firequalizer.c</p>
<p>af_flanger.c</p>
<p>af_haas.c</p>
<p>af_hdcd.c</p>
<p>af_headphone.c</p>
<p>af_join.c</p>
<p>af_ladspa.c</p>
<p>af_loudnorm.c</p>
<p>af_lv2.c</p>
<p>af_mcompand.c</p>
<p>af_pan.c</p>
<p>af_replaygain.c</p>
<p>af_resample.c</p>
<p>af_rubberband.c</p>
<p>af_sidechaincompress.c</p>
<p>af_silencedetect.c</p>
<p>af_silenceremove.c</p>
<p>af_sofalizer.c</p>
<p>af_stereotools.c</p>
<p>af_stereowiden.c</p>
<p>af_superequalizer.c</p>
<p>af_surround.c</p>
<p>af_tremolo.c</p>
<p>af_vibrato.c</p>
<p>af_volume.c</p>
<p>af_volumedetect.c</p>
<p>af_volume.h</p>
<p>allfilters.c</p>
<p>asink_anullsink.c</p>
<p>asrc_afirsrc.c</p>
<p>asrc_anoisesrc.c</p>
<p>asrc_anullsrc.c</p>
<p>asrc_flite.c</p>
<p>asrc_hilbert.c</p>
<p>asrc_sinc.c</p>
<p>asrc_sine.c</p>
<p>atadenoise.h</p>
<p>audio.c</p>
<p>audio.h</p>
<p>avf_abitscope.c</p>
<p>avf_ahistogram.c</p>
<p>avf_aphasemeter.c</p>
<p>avf_avectorscope.c</p>
<p>avf_concat.c</p>
<p>avfilter.c</p>
<p>avfiltergraph.c</p>
<p>avfilter.h</p>
<p>avfilterres.rc</p>
<p>avf_showcqt.c</p>
<p>avf_showcqt.h</p>
<p>avf_showfreqs.c</p>
<p>avf_showspatial.c</p>
<p>avf_showspectrum.c</p>
<p>avf_showvolume.c</p>
<p>avf_showwaves.c</p>
<p>bbox.c</p>
<p>bbox.h</p>
<p>blend.h</p>
<p>boxblur.c</p>
<p>boxblur.h</p>
<p>bufferqueue.h</p>
<p>buffersink.c</p>
<p>buffersink.h</p>
<p>buffersrc.c</p>
<p>buffersrc.h</p>
<p>bwdif.h</p>
<p>colorspace.c</p>
<p>colorspacedsp.c</p>
<p>colorspacedsp.h</p>
<p>colorspacedsp_template.c</p>
<p>colorspacedsp_yuv2yuv_template.c</p>
<p>colorspace.h</p>
<p>convolution.h</p>
<p>deshake.h</p></td>
<td>ffmpeg-4.3/libavfilter</td>
</tr>
<tr class="even">
<td><p>3dostr.c</p>
<p>4xm.c</p>
<p>a64.c</p>
<p>aacdec.c</p>
<p>aadec.c</p>
<p>ac3dec.c</p>
<p>acm.c</p>
<p>act.c</p>
<p>adp.c</p>
<p>ads.c</p>
<p>adtsenc.c</p>
<p>adxdec.c</p>
<p>aea.c</p>
<p>afc.c</p>
<p>aiffdec.c</p>
<p>aiffenc.c</p>
<p>aiff.h</p>
<p>aixdec.c</p>
<p>allformats.c</p>
<p>alp.c</p>
<p>amr.c</p>
<p>anm.c</p>
<p>apc.c</p>
<p>ape.c</p>
<p>apetag.c</p>
<p>apetag.h</p>
<p>apm.c</p>
<p>apngdec.c</p>
<p>apngenc.c</p>
<p>aptxdec.c</p>
<p>aqtitledec.c</p>
<p>argo_asf.c</p>
<p>asf.c</p>
<p>asfcrypt.c</p>
<p>asfcrypt.h</p>
<p>asfdec_f.c</p>
<p>asfdec_o.c</p>
<p>asfenc.c</p>
<p>asf.h</p>
<p>assdec.c</p>
<p>assenc.c</p>
<p>ast.c</p>
<p>astdec.c</p>
<p>astenc.c</p>
<p>ast.h</p>
<p>async.c</p>
<p>au.c</p>
<p>av1.c</p>
<p>av1dec.c</p>
<p>av1.h</p>
<p>avc.c</p>
<p>avc.h</p>
<p>avformat.h</p>
<p>avformatres.rc</p>
<p>avidec.c</p>
<p>avienc.c</p>
<p>avi.h</p>
<p>aviobuf.c</p>
<p>avio.c</p>
<p>avio.h</p>
<p>avio_internal.h</p>
<p>avisynth.c</p>
<p>avlanguage.c</p>
<p>avlanguage.h</p>
<p>avr.c</p>
<p>avs.c</p>
<p>bethsoftvid.c</p>
<p>bfi.c</p>
<p>bink.c</p>
<p>bintext.c</p>
<p>bit.c</p>
<p>bluray.c</p>
<p>bmv.c</p>
<p>boadec.c</p>
<p>brstm.c</p>
<p>c93.c</p>
<p>cache.c</p>
<p>caf.c</p>
<p>cafdec.c</p>
<p>cafenc.c</p>
<p>caf.h</p>
<p>cavsvideodec.c</p>
<p>cdg.c</p>
<p>cdxl.c</p>
<p>chromaprint.c</p>
<p>cinedec.c</p>
<p>codec2.c</p>
<p>concat.c</p>
<p>concatdec.c</p>
<p>crcenc.c</p>
<p>crypto.c</p>
<p>cutils.c</p>
<p>dash.c</p>
<p>dashdec.c</p>
<p>dashenc.c</p>
<p>dash.h</p>
<p>data_uri.c</p>
<p>dauddec.c</p>
<p>daudenc.c</p>
<p>davs2.c</p>
<p>dcstr.c</p>
<p>derf.c</p>
<p>dfa.c</p>
<p>dhav.c</p>
<p>diracdec.c</p>
<p>dnxhddec.c</p>
<p>dsfdec.c</p>
<p>dsicin.c</p>
<p>dss.c</p>
<p>dtsdec.c</p>
<p>dtshddec.c</p>
<p>dump.c</p>
<p>dvbsub.c</p>
<p>dvbtxt.c</p>
<p>dv.c</p>
<p>dvenc.c</p>
<p>dv.h</p>
<p>dxa.c</p>
<p>eacdata.c</p>
<p>electronicarts.c</p>
<p>epafdec.c</p>
<p>ffmetadec.c</p>
<p>ffmetaenc.c</p>
<p>ffmeta.h</p>
<p>fifo.c</p>
<p>fifo_test.c</p>
<p>file.c</p>
<p>file_open.c</p>
<p>filmstripdec.c</p>
<p>filmstripenc.c</p>
<p>fitsdec.c</p>
<p>fitsenc.c</p>
<p>flacdec.c</p>
<p>flacenc.c</p>
<p>flacenc.h</p>
<p>flacenc_header.c</p>
<p>flac_picture.c</p>
<p>flac_picture.h</p>
<p>flic.c</p>
<p>flvdec.c</p>
<p>flvenc.c</p>
<p>flv.h</p>
<p>format.c</p>
<p>framecrcenc.c</p>
<p>framehash.c</p>
<p>frmdec.c</p>
<p>fsb.c</p>
<p>ftp.c</p>
<p>fwse.c</p>
<p>g722.c</p>
<p>g723_1.c</p>
<p>g726.c</p>
<p>g729dec.c</p>
<p>gdv.c</p>
<p>genh.c</p>
<p>gif.c</p>
<p>gifdec.c</p>
<p>golomb_tab.c</p>
<p>gopher.c</p>
<p>gsmdec.c</p>
<p>gxf.c</p>
<p>gxfenc.c</p>
<p>gxf.h</p>
<p>h261dec.c</p>
<p>h263dec.c</p>
<p>h264dec.c</p>
<p>hashenc.c</p>
<p>hca.c</p>
<p>hcom.c</p>
<p>hdsenc.c</p>
<p>hevc.c</p>
<p>hevcdec.c</p>
<p>hevc.h</p>
<p>hls.c</p>
<p>hlsenc.c</p>
<p>hlsplaylist.c</p>
<p>hlsplaylist.h</p>
<p>hlsproto.c</p>
<p>hnm.c</p>
<p>httpauth.c</p>
<p>httpauth.h</p>
<p>http.c</p>
<p>http.h</p>
<p>icecast.c</p>
<p>icodec.c</p>
<p>icoenc.c</p>
<p>id3v1.c</p>
<p>id3v1.h</p>
<p>id3v2.c</p>
<p>id3v2enc.c</p>
<p>id3v2.h</p>
<p>idcin.c</p>
<p>idroqdec.c</p>
<p>idroqenc.c</p>
<p>iff.c</p>
<p>ifv.c</p>
<p>ilbc.c</p>
<p>img2_alias_pix.c</p>
<p>img2_brender_pix.c</p>
<p>img2.c</p>
<p>img2dec.c</p>
<p>img2enc.c</p>
<p>img2.h</p>
<p>ingenientdec.c</p>
<p>internal.h</p>
<p>ip.c</p>
<p>ip.h</p>
<p>ipmovie.c</p>
<p>ircam.c</p>
<p>ircamdec.c</p>
<p>ircamenc.c</p>
<p>ircam.h</p>
<p>isom.c</p>
<p>isom.h</p>
<p>iss.c</p>
<p>iv8.c</p>
<p>ivfdec.c</p>
<p>ivfenc.c</p>
<p>jacosubdec.c</p>
<p>jacosubenc.c</p>
<p>jvdec.c</p>
<p>kvag.c</p>
<p>latmenc.c</p>
<p>libamqp.c</p>
<p>libavformat.v</p>
<p>libgme.c</p>
<p>libmodplug.c</p>
<p>libopenmpt.c</p>
<p>librtmp.c</p>
<p>libsmbclient.c</p>
<p>libsrt.c</p>
<p>libssh.c</p>
<p>libzmq.c</p>
<p>lmlm4.c</p>
<p>loasdec.c</p>
<p>log2_tab.c</p>
<p>lrc.c</p>
<p>lrcdec.c</p>
<p>lrcenc.c</p>
<p>lrc.h</p>
<p>lvfdec.c</p>
<p>lxfdec.c</p>
<p>m4vdec.c</p>
<p>Makefile</p>
<p>matroska.c</p>
<p>matroskadec.c</p>
<p>matroskaenc.c</p>
<p>matroska.h</p>
<p>md5proto.c</p>
<p>metadata.c</p>
<p>metadata.h</p>
<p>mgsts.c</p>
<p>microdvddec.c</p>
<p>microdvdenc.c</p>
<p>mj2kdec.c</p>
<p>mkvtimestamp_v2.c</p>
<p>mlpdec.c</p>
<p>mlvdec.c</p>
<p>mm.c</p>
<p>mmf.c</p>
<p>mms.c</p>
<p>mms.h</p>
<p>mmsh.c</p>
<p>mmst.c</p>
<p>mov.c</p>
<p>mov_chan.c</p>
<p>mov_chan.h</p>
<p>movenc.c</p>
<p>movenccenc.c</p>
<p>movenccenc.h</p>
<p>movenc.h</p>
<p>movenchint.c</p>
<p>mov_esds.c</p>
<p>mp3dec.c</p>
<p>mp3enc.c</p>
<p>mpc8.c</p>
<p>mpc.c</p>
<p>mpeg.c</p>
<p>mpegenc.c</p>
<p>mpeg.h</p>
<p>mpegts.c</p>
<p>mpegtsenc.c</p>
<p>mpegts.h</p>
<p>mpegvideodec.c</p>
<p>mpjpeg.c</p>
<p>mpjpegdec.c</p>
<p>mpl2dec.c</p>
<p>mpsubdec.c</p>
<p>msf.c</p>
<p>msnwc_tcp.c</p>
<p>mtaf.c</p>
<p>mtv.c</p>
<p>musx.c</p>
<p>mux.c</p>
<p>mvdec.c</p>
<p>mvi.c</p>
<p>mxf.c</p>
<p>mxfdec.c</p>
<p>mxfenc.c</p>
<p>mxf.h</p>
<p>mxg.c</p>
<p>ncdec.c</p>
<p>network.c</p>
<p>network.h</p>
<p>nistspheredec.c</p>
<p>nspdec.c</p>
<p>nsvdec.c</p>
<p>nullenc.c</p>
<p>nut.c</p>
<p>nutdec.c</p>
<p>nutenc.c</p>
<p>nut.h</p>
<p>nuv.c</p>
<p>oggdec.c</p>
<p>oggdec.h</p>
<p>oggenc.c</p>
<p>oggparsecelt.c</p>
<p>oggparsedirac.c</p>
<p>oggparseflac.c</p>
<p>oggparseogm.c</p>
<p>oggparseopus.c</p>
<p>oggparseskeleton.c</p>
<p>oggparsespeex.c</p>
<p>oggparsetheora.c</p>
<p>oggparsevorbis.c</p>
<p>oggparsevp8.c</p>
<p>oma.c</p>
<p>omadec.c</p>
<p>omaenc.c</p>
<p>oma.h</p>
<p>options.c</p>
<p>options_table.h</p>
<p>os_support.c</p>
<p>os_support.h</p>
<p>paf.c</p>
<p>pcm.c</p>
<p>pcmdec.c</p>
<p>pcmenc.c</p>
<p>pcm.h</p>
<p>pjsdec.c</p>
<p>pmpdec.c</p>
<p>pp_bnk.c</p>
<p>prompeg.c</p>
<p>protocols.c</p>
<p>psxstr.c</p>
<p>pva.c</p>
<p>pvfdec.c</p>
<p>qcp.c</p>
<p>qtpalette.c</p>
<p>qtpalette.h</p>
<p>r3d.c</p>
<p>rawdec.c</p>
<p>rawdec.h</p>
<p>rawenc.c</p>
<p>rawenc.h</p>
<p>rawutils.c</p>
<p>rawvideodec.c</p>
<p>rdt.c</p>
<p>rdt.h</p>
<p>realtextdec.c</p>
<p>redspark.c</p>
<p>replaygain.c</p>
<p>replaygain.h</p>
<p>riff.c</p>
<p>riffdec.c</p>
<p>riffenc.c</p>
<p>riff.h</p>
<p>rl2.c</p>
<p>rm.c</p>
<p>rmdec.c</p>
<p>rmenc.c</p>
<p>rm.h</p>
<p>rmsipr.c</p>
<p>rmsipr.h</p>
<p>rpl.c</p>
<p>rsd.c</p>
<p>rso.c</p>
<p>rsodec.c</p>
<p>rsoenc.c</p>
<p>rso.h</p>
<p>rtmpcrypt.c</p>
<p>rtmpcrypt.h</p>
<p>rtmpdh.c</p>
<p>rtmpdh.h</p>
<p>rtmpdigest.c</p>
<p>rtmp.h</p>
<p>rtmphttp.c</p>
<p>rtmppkt.c</p>
<p>rtmppkt.h</p>
<p>rtmpproto.c</p>
<p>rtp.c</p>
<p>rtpdec_ac3.c</p>
<p>rtpdec_amr.c</p>
<p>rtpdec_asf.c</p>
<p>rtpdec.c</p>
<p>rtpdec_dv.c</p>
<p>rtpdec_formats.h</p>
<p>rtpdec_g726.c</p>
<p>rtpdec.h</p>
<p>rtpdec_h261.c</p>
<p>rtpdec_h263.c</p>
<p>rtpdec_h263_rfc2190.c</p>
<p>rtpdec_h264.c</p>
<p>rtpdec_hevc.c</p>
<p>rtpdec_ilbc.c</p>
<p>rtpdec_jpeg.c</p>
<p>rtpdec_latm.c</p>
<p>rtpdec_mpa_robust.c</p>
<p>rtpdec_mpeg12.c</p>
<p>rtpdec_mpeg4.c</p>
<p>rtpdec_mpegts.c</p>
<p>rtpdec_qcelp.c</p>
<p>rtpdec_qdm2.c</p>
<p>rtpdec_qt.c</p>
<p>rtpdec_rfc4175.c</p>
<p>rtpdec_svq3.c</p>
<p>rtpdec_vc2hq.c</p>
<p>rtpdec_vp8.c</p>
<p>rtpdec_vp9.c</p>
<p>rtpdec_xiph.c</p>
<p>rtpenc_aac.c</p>
<p>rtpenc_amr.c</p>
<p>rtpenc.c</p>
<p>rtpenc_chain.c</p>
<p>rtpenc_chain.h</p>
<p>rtpenc.h</p>
<p>rtpenc_h261.c</p>
<p>rtpenc_h263.c</p>
<p>rtpenc_h263_rfc2190.c</p>
<p>rtpenc_h264_hevc.c</p>
<p>rtpenc_jpeg.c</p>
<p>rtpenc_latm.c</p>
<p>rtpenc_mpegts.c</p>
<p>rtpenc_mpv.c</p>
<p>rtpenc_vc2hq.c</p>
<p>rtpenc_vp8.c</p>
<p>rtpenc_vp9.c</p>
<p>rtpenc_xiph.c</p>
<p>rtp.h</p>
<p>rtpproto.c</p>
<p>rtpproto.h</p>
<p>rtsp.c</p>
<p>rtspcodes.h</p>
<p>rtspdec.c</p>
<p>rtspenc.c</p>
<p>rtsp.h</p>
<p>s337m.c</p>
<p>samidec.c</p>
<p>sapdec.c</p>
<p>sapenc.c</p>
<p>sauce.c</p>
<p>sauce.h</p>
<p>sbcdec.c</p>
<p>sbgdec.c</p>
<p>sccdec.c</p>
<p>sccenc.c</p>
<p>sctp.c</p>
<p>sdp.c</p>
<p>sdr2.c</p>
<p>sdsdec.c</p>
<p>sdxdec.c</p>
<p>segafilm.c</p>
<p>segafilmenc.c</p>
<p>segment.c</p>
<p>serdec.c</p>
<p>shortendec.c</p>
<p>sierravmd.c</p>
<p>siff.c</p>
<p>smacker.c</p>
<p>smjpeg.c</p>
<p>smjpegdec.c</p>
<p>smjpegenc.c</p>
<p>smjpeg.h</p>
<p>smoothstreamingenc.c</p>
<p>smush.c</p>
<p>sol.c</p>
<p>soxdec.c</p>
<p>soxenc.c</p>
<p>sox.h</p>
<p>spdif.c</p>
<p>spdifdec.c</p>
<p>spdifenc.c</p>
<p>spdif.h</p>
<p>srtdec.c</p>
<p>srtenc.c</p>
<p>srtp.c</p>
<p>srtp.h</p>
<p>srtpproto.c</p>
<p>stldec.c</p>
<p>subfile.c</p>
<p>subtitles.c</p>
<p>subtitles.h</p>
<p>subviewer1dec.c</p>
<p>subviewerdec.c</p>
<p>supdec.c</p>
<p>supenc.c</p>
<p>svag.c</p>
<p>swf.c</p>
<p>swfdec.c</p>
<p>swfenc.c</p>
<p>swf.h</p>
<p>takdec.c</p>
<p>tcp.c</p>
<p>tedcaptionsdec.c</p>
<p>tee.c</p>
<p>tee_common.c</p>
<p>tee_common.h</p>
<p>teeproto.c</p></td>
<td>ffmpeg-4.3/libavformat</td>
</tr>
<tr class="odd">
<td><p>audio_convert.c</p>
<p>audio_convert.h</p>
<p>audio_data.c</p>
<p>audio_data.h</p>
<p>audio_mix.c</p>
<p>audio_mix.h</p>
<p>audio_mix_matrix.c</p>
<p>avresample.h</p>
<p>avresampleres.rc</p>
<p>dither.c</p>
<p>dither.h</p>
<p>internal.h</p>
<p>libavresample.v</p>
<p>Makefile</p>
<p>options.c</p>
<p>resample.c</p>
<p>resample.h</p>
<p>resample_template.c</p></td>
<td>ffmpeg-4.3/libavresample</td>
</tr>
<tr class="even">
<td><p>adler32.c</p>
<p>adler32.h</p>
<p>aes.c</p>
<p>aes_ctr.c</p>
<p>aes_ctr.h</p>
<p>aes.h</p>
<p>aes_internal.h</p>
<p>attributes.h</p>
<p>audio_fifo.c</p>
<p>audio_fifo.h</p>
<p>avassert.h</p>
<p>avsscanf.c</p>
<p>avstring.c</p>
<p>avstring.h</p>
<p>avutil.h</p>
<p>avutilres.rc</p>
<p>base64.c</p>
<p>base64.h</p>
<p>blowfish.c</p>
<p>blowfish.h</p>
<p>bprint.c</p>
<p>bprint.h</p>
<p>bswap.h</p>
<p>buffer.c</p>
<p>buffer.h</p>
<p>buffer_internal.h</p>
<p>camellia.c</p>
<p>camellia.h</p>
<p>cast5.c</p>
<p>cast5.h</p>
<p>channel_layout.c</p>
<p>channel_layout.h</p>
<p>colorspace.h</p>
<p>color_utils.c</p>
<p>color_utils.h</p>
<p>common.h</p>
<p>cpu.c</p>
<p>cpu.h</p>
<p>cpu_internal.h</p>
<p>crc.c</p>
<p>crc.h</p>
<p>cuda_check.h</p>
<p>des.c</p>
<p>des.h</p>
<p>dict.c</p>
<p>dict.h</p>
<p>display.c</p>
<p>display.h</p>
<p>dovi_meta.c</p>
<p>dovi_meta.h</p>
<p>downmix_info.c</p>
<p>downmix_info.h</p>
<p>dynarray.h</p>
<p>encryption_info.c</p>
<p>encryption_info.h</p>
<p>error.c</p>
<p>error.h</p>
<p>eval.c</p>
<p>eval.h</p>
<p>ffmath.h</p>
<p>fifo.c</p>
<p>fifo.h</p>
<p>file.c</p>
<p>file.h</p>
<p>file_open.c</p>
<p>fixed_dsp.c</p>
<p>fixed_dsp.h</p>
<p>float_dsp.c</p>
<p>float_dsp.h</p>
<p>frame.c</p>
<p>frame.h</p>
<p>hash.c</p>
<p>hash.h</p>
<p>hdr_dynamic_metadata.c</p>
<p>hdr_dynamic_metadata.h</p>
<p>hmac.c</p>
<p>hmac.h</p>
<p>hwcontext.c</p>
<p>hwcontext_cuda.c</p>
<p>hwcontext_cuda.h</p>
<p>hwcontext_cuda_internal.h</p>
<p>hwcontext_d3d11va.c</p>
<p>hwcontext_d3d11va.h</p>
<p>hwcontext_drm.c</p>
<p>hwcontext_drm.h</p>
<p>hwcontext_dxva2.c</p>
<p>hwcontext_dxva2.h</p>
<p>hwcontext.h</p>
<p>hwcontext_internal.h</p>
<p>hwcontext_mediacodec.c</p>
<p>hwcontext_mediacodec.h</p>
<p>hwcontext_opencl.c</p>
<p>hwcontext_opencl.h</p>
<p>hwcontext_qsv.c</p>
<p>hwcontext_qsv.h</p>
<p>hwcontext_vaapi.c</p>
<p>hwcontext_vaapi.h</p>
<p>hwcontext_vdpau.c</p>
<p>hwcontext_vdpau.h</p>
<p>hwcontext_videotoolbox.c</p>
<p>hwcontext_videotoolbox.h</p>
<p>hwcontext_vulkan.c</p>
<p>hwcontext_vulkan.h</p>
<p>imgutils.c</p>
<p>imgutils.h</p>
<p>imgutils_internal.h</p>
<p>integer.c</p>
<p>integer.h</p>
<p>internal.h</p>
<p>intfloat.h</p>
<p>intmath.c</p>
<p>intmath.h</p>
<p>intreadwrite.h</p>
<p>lfg.c</p>
<p>lfg.h</p>
<p>libavutil.v</p>
<p>libm.h</p>
<p>lls.c</p>
<p>lls.h</p>
<p>log2_tab.c</p>
<p>log.c</p>
<p>log.h</p>
<p>lzo.c</p>
<p>lzo.h</p></td>
<td>ffmpeg-4.3/libavutil</td>
</tr>
</tbody>
</table>

## 离线FFMPEG概要设计说明

### 概述

#### 简介

FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。

#### 读者对象

本文档的读者对象为离线识别系统的开发人员、测试人员、系统维护人员及接入识别系统的第三方业务人员，通过本文档能够从总体上了解FFMPEG的架构形式及数据流向。

本说明给出FFMPEG的设计说明，包括最终实现的系统必须满足的功能、性能、接口、附属测试工具程序及设计约束等。

目的在于：

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件；

#### 术语定义

语音识别（Automatic Speech Recognition），简称（ASR）。

### 2总体设计

#### 总体需求

功能需求：对语音进行转码；

性能需求：转码耗时低；

接口需求：接口参数简单明了，接口中的每个参数都要有实际意义，保证接口调用流程清晰。

系统验证工具：提供系统完整性，功能正确性的验证工具；

#### 运行环境

##### 软件环境

|      |        |        |
| ---- | ------ | ------ |
| 分类   | 名称     | 版本     |
| 操作系统 | Centos | 7.0以上  |
| 数据库  | Redis  | 3.2.0  |
| 能力接口 | Tomcat | 9.0.35 |

##### 硬件环境

<table>
<tbody>
<tr class="odd">
<td>服务器</td>
<td>最低配置</td>
<td>推荐配置</td>
</tr>
<tr class="even">
<td>redis服务器</td>
<td><p>CPU：1</p>
<p>内存：256M</p></td>
<td><p>CPU：1</p>
<p>内存：1G</p></td>
</tr>
<tr class="odd">
<td>识别服务器</td>
<td><p>CPU：4</p>
<p>内存：10G</p>
<p>磁盘：20G</p></td>
<td><p>CPU：10</p>
<p>内存：15G</p>
<p>磁盘：30G</p></td>
</tr>
</tbody>
</table>

#### 系统总体结构设计

ffmpeg整个流程如下图所示。

![](media/image1.png)

1、FFmpeg程序把-i参数指定的若干文件内容读入到内存，按照输入的参数或者程序默认的参数来处理并且把结果写入到若干的文件中。输入和输出文件可以是计算机文件、管道、网络流、捕获设备等。

2、FFmpeg用libavformat包调用解复用器（demuxers）来读取输入文件中被编码的数据包(packets)，如果有多个输入文件，FFmpeg以有效输入流的最小时间戳来同步，

3、然后解码器（decoder）从已编码的数据包中产生未被压缩的帧（frame），在那之后调用可选的过滤器。

4、这些帧被传递到编码器，编码器会产生新的编码包

5、把新的编码包传递给复用器(muxer)处理并且把结果写入到输出文件中。

### 模块设计

#### ffmpeg主要组成部分

1、libavformat：用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能，包含demuxers和muxer库；

2、libavcodec：用于各种类型声音/图像编解码；

3、libavutil：包含一些公共的工具函数；

4、libswscale：用于视频场景比例缩放、色彩映射转换；

5、libpostproc：用于后期效果处理；

6、ffmpeg：是一个命令行工具，用来对视频文件转换格式，也支持对电视卡实时编码；

7、ffsever：是一个HTTP多媒体实时广播流服务器，支持时光平移；

8、ffplay：是一个简单的播放器，使用ffmpeg 库解析和解码，通过SDL显示；

在这组成部分中，需要熟悉基础概念有

容器(Container)

容器就是一种文件格式，比如flv，mkv等。包含下面5种流以及文件头信息。

流(Stream)

是一种视频数据信息的传输方式，5种流：音频，视频，字幕，附件，数据。

帧(Frame)

帧代表一幅静止的图像，分为I帧，P帧，B帧。

编解码器(Codec)

是对视频进行压缩或者解压缩，CODEC =COde （编码） +DECode（解码）

复用/解复用(mux/demux)

把不同的流按照某种容器的规则放入容器，这种行为叫做复用（mux）

把不同的流从某种容器中解析出来，这种行为叫做解复用(demux)

ffmpeg具体处理流程如下：

![IMG\_256](media/image2.jpeg)

主要函数介绍：

函数原型：

AVCodec \*avcodec\_find\_decoder(enum AVCodecID id);

参数说明：enum AVCodecID id 解码器的ID

返回值：注册的解码器

功能：

根据指定的AVCodecID查找注册的解码器。

函数原型：

AVCodecParserContext \*av\_parser\_init(int codec\_id)；

参数说明：int codec\_id 解码器的ID

返回值：AVCodecParserContext指针

功能：

初始化AVCodecParserContext。

函数原型：

AVCodecContext \*avcode\_alloc\_context3(const AVCodec \*codec)；

参数说明：AVCodec \*codec 解码器

返回值：AVCodecParserContext指针

功能：

为AVCodecContext分配内存。

函数原型：

int avcodec\_open2(AVCodecContext \*avctx, const AVCodec \*codec, AVDictionary \*\*options);

参数说明：

AVCodecContext \*avctx 需要初始化的AVCodecContext

const AVCodec \*codec 输入的AVCodec

AVDictionary \*\*options 一些选项。例如使用libx264编码的时候，“preset”，“tune”等都可以通过该参数设置

返回值：

int类型。取值及说明如下：

0 ：成功

\-1 ：失败

功能：

打开解码器。

函数原型：

int av\_parser\_parse2()；

参数说明：

返回值：

int类型。取值及说明如下：

0 ：成功

\<0 ：失败

功能：

解析获得一个Packet。

函数原型：

int avcodec\_send\_packet(AVCodecContext \*avctx, const AVPacket \*avpkt);

参数说明：

AVCodecContext \*avctx 需要初始化的AVCodecContext

const AVPacket \*avpkt 输入的AVPacket

返回值：

int类型。取值及说明如下：

0 ：成功

\<0 ：失败

功能：

将AVPacket压缩数据给解码器。

函数原型：

int avcodec\_receive\_frame(AVCodecContext \*avctx, AVFrame \*frame);

参数说明：

AVCodecContext \*avctx 需要初始化的AVCodecContext

AVFrame \*frame 输入的AVFrame

返回值：

int类型。取值及说明如下：

0 ：成功

\<0 ：失败

功能：

获取到解码后的AVFrame数据。

函数原型：

int av\_get\_bytes\_per\_sample(enum AVSampleFormat sample\_fmt);

参数说明：

enum AVSampleFormat sample\_fmt sample\_fmt入参

返回值：

int类型。取值及说明如下：

0 ：成功

\<0 ：失败

功能：

获取每个sample中的字节数。

关键数据结构说明：

AVCodecParser：用于解析输入的数据流并把它分成一帧一帧的压缩编码数据。比较形象的说法就是把长长的一段连续的数据“切割”成一段段的数据。

### 测试设计

#### 配置文件设计

设置配置文件，方便使用不同控制逻辑，支持不同的功能及结果输出，配置参数实现如下目的：

  - 通过参数控制支持特殊功能

配置主要参数如下表：

|        |     |         |
| ------ | --- | ------- |
| 参数     | 取值  | 说明      |
| inwav  | 字符串 | 待转码语音   |
| \-ar   |     | 设定声音采样率 |
| \-ac   |     | 设定声道数   |
| \-ab   |     | 设定声道数   |
| \-f    |     | 输出格式    |
| outwav | 字符串 | 转码后语音   |

#### 测试功能点

根据设计需求，对服务必须满足的功能点进行验证测试。

|             |                 |
| ----------- | --------------- |
| 测试功能        | 期望结果            |
| 使用不同的语音进行转码 | 正确配置参数，转码后语音正常。 |

### 可靠性设计

离线系统FFMPEG设计考虑了实际应用场景的复杂性和输入的多样性的情况，内部加入了大部分实际情况中会出现的异常情况的处理方案，保证稳定性和可靠性。

### 扩展性设计

系统本身遵循模块化设计，可以随时添加定制化功能，满足不同应用场景的需要。

### 维护性设计

离线系统为了方便后期的引擎维护，采用标准c/c++函数同时在较低编译器上进行编译

### 易用性设计

系统安装部署时有一键安装部署脚本，只需要执行脚本即可安装,减少操作量。系统启停均有对应的脚本，实现自动启动、停止服务。

## 离线识别引擎FFMPEG接口设计

###   
概述

#### 编写目的

本文档主要描述ffmpeg内部接口设计及接口中参数的数据结构，本文档的读者对象为离线识别系统的开发人员、测试人员、系统维护人员及接入识别系统的第三方业务人员，通过本文档能够从总体上了解识别系统内部的数据流向及处理方式。

本说明给出FFMPEG的接口设计说明，包括接口安全、版本兼容性、数据格式、服务端的异常处理等。

目的在于：

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件；

### 总体设计

#### 总体需求

接口需求：

1，接口参数简单明了，参数有实际意义；

2，接口功能定义明确；

3，接口的数据特性明确；

4，接口的规格和技术要求明确；

5，接口程序的数据处理逻辑清晰；

### ffmpeg接口设计

ffmpeg包含通用API、解码API、编码API。

#### 通用 API 

1.av\_register\_all：

编译配置（–enable、–disable） FFmpeg 的时候，会生成两个文件：config.mk、config.h。config.mk 会实际上就是 makefile 文件需要包含进去的子模块，会作用在编译阶段，帮助开发者编译出正确的库；而 config.h 是作用在运行阶段，这一阶段将确保需要注册哪些容器以及编解码格式到 FFmpeg 框架中。所以该函数的内部实现会先调用 avcodec\_register\_all 来注册所有 config.h 里面开放的编解码器，然后会注册所有的 Muxer 和 Demuxer，最后注册所有的 Protocol。如此，在 config 的过程中，enable、disable 的选项就作用到了运行时，该函数的源码分析涉及的源文件包括 url.c、alformats.c、mux.c、format.c 等文件。

av\_register\_all()的作用是：初始化所有组件，只有调用了该函数，才能使用复用器和编解码器，该接口内部的调用为：

(1).avcodec\_register\_all()，该接口内部执行步骤：

\- 注册硬件加速器：REGISTER\_HWACCEL()

\- 注册音视频编码器：REGISTER\_ENCODER()

\- 注册音视频解码器：REGISTER\_DECODER()

\- 打包注册：REGISTER\_ENCDEC()

\- 注册解析器：REGISTER\_PARSER()

(2).执行复用器和解复用器的注册：

\- 注册复用器：REGISTER\_MUXER()

\- 注册解复用器：REGISTER\_DEMUXER()

\- 打包注册：REGISTER\_MUXDEMUX()

2.av\_find\_codec：

在 avcodec\_register\_all 函数里面已经把编码器和解码器都存放到了一个链表中，因此都是从该链表进行遍历查找

3.avcodec\_open2：

打开编解码其的时候就会用到该函数，参数有三个，第一个是 AVCodecContext，如果想要传入私有参数，比如 preset、tune、profile，则可以为设置到 priv\_data 参数中。具体到函数实现时，它会找到对应的实现文件，比如，如果打开的是 libx264 编码器，那么实际上的 Codec 为 libx264.c 中的 ff\_libx264\_encoder，Codec 的生命周期方法就会委托给该结构体对应的函数指针所指向的函数。open 对应的就是 init 函数指针所指向的函数，该函数会调用具体的编码库的 API，并以对应的 AVCodecContext 中的 priv\_data 来填充对应第三方库所需要的私有参数。

4.av\_codec\_close：

和 open 类似，找到对应的实现文件中的 close 函数指针所指向的函数，然后该函数会调用对应第三方库的 API 来关闭掉对应编码库。其实 FFmpeg 所做的事情就是透明化所有的编码库，用自己的封装来为开发者提供统一的接口，开发者只需要在打开编解码库时指定编解码器的 ID 即可，之后编码、解码、关闭资源都会找到对应的实现文件去做具体的事情。

#### 解码API

1.avformat\_open\_input

该函数会根据提供的的文件路径判断文件的格式，继而决定使用哪一个 Demuxer。比如，如果是 flv 文件，那么 Demuxer 就会使用对应的 ff\_flv\_demuxer，之后关键的生命周期方法 read\_header、read\_packet、read\_seek、read\_close 都会使用 ff\_flv\_demuxer 中函数指针指定的函数。read\_header 函数会将 AVStream 结构体构造好。

2.avformat\_find\_stream\_info

这个函数非常重要，该方法的作用是将所有 Stream 的MetaData信息填充好，方法内部会先查找对应的解码器，并打开，紧接着利用 Demuxer 中的 read\_packet 函数读取一段数据进行解码，解码数据越多，分析出的流数据就会越准确，本地资源会比较快，网络资源则较慢。该函数提供了几个参数可以控制读取数据的长度，分别为：probe\_size、max\_analyze、fps\_probe\_size，这几个参数的值越小，读取速度越快，信息则相对不够准确。

3.av\_read\_frame

该方法读取出来的数据是 AVPacket，该函数的实现首先会委托到 Demuxer 的 read\_packet 方法，然后在该函数中把未处理完的压缩数据进行缓存处理。

4.avcodec\_decode

如果要解码 H264，会找到 ff\_h264\_decoder，其中最重要的三个声明周期方法为 init、decode、close。

#### 编码API

1.avformat\_alloc\_output\_context

和avformat\_open\_input类似，该函数最终会找到对应的格式复制给 AVFormatContext中的oformat。

2.avio\_open2

该方法首先调用函数ffurl\_open，构造除URLContext，这个结构体包含了 URLProtocol，接着调用avio\_alloc\_context方法，分配除AVIOContext结构体，并将上一步构造出来的URLProtocol传递进来，然后复制给AVFormatContext的属性。

编码步骤其实是解码的一个逆过程，解码过程中的av\_find\_stream\_info对应到编码就是avformat\_new\_stream和av\_format\_write\_header，该步骤会将音频流或视频流的信息填充好，分配出AVStream结构体。read\_header则对应于av\_write\_header，再之后是av\_write\_frame、av\_write\_tailer。

### 代码目录

#### 代码目录结构

> ffmpeg-4.3
> 
> |--compat
> 
> |--configure 配置项
> 
> |--doc 说明文档
> 
> |--ffbuild
> 
> |--fftools
> 
> |--libavcodec 编解码库
> 
> |--libavdevice 输入输出设备库
> 
> |--libavfilter 滤镜库
> 
> |--libavformat 文件格式与协议库
> 
> |--libavresample
> 
> |--libavutil 核心工具库
> 
> |--libpostproc
> 
> |--libswresample 重采样、转换声道数
> 
> |--libswscale 像素格式转换
> 
> |--Makefile 编译规则与命令
> 
> |--presets
> 
> |--README.md 说明
> 
> |--tests
> 
> |--tools
> 
> |--VERSION

#### 主要代码模块说明

##### libavutil

核心工具库，最基础的模块之一，其它模块经常依赖该库做一些基本的音视频处理操作，比如 av\_image\_fill\_arrays（填充原始图像数据到 AVFrame）、av\_image\_get\_buffer\_size（根据图像宽高、格式获取填充该图像需要的字节数）、av\_get\_pix\_fmt\_name（获取像素格式的名称） 等等。

##### libavformat

文件格式和协议库，最重要的模块之一，封装了 Protocol 层和 Demuxer、Muxer 层。常用于读写文件及文件信息，比如 avformat\_write\_header（写文件头）、av\_write\_trailer（写文件尾）、av\_read\_frame （从文件中读取一帧编码后的图像/音频数据）、av\_write\_frame（往文件中写一帧编码后的图像/音频数据）、av\_seek\_frame（给定一个时间戳，移动读指针到对应位置）等等。

##### libavcodec

编解码库，最重要的模块之一。FFmpeg 默认不会添加 libx264、FDK-AAC 等库，但 FFmpeg 可以像一个平台一样，将其它第三方的 Codec 以插件的形式添加进来，并为开发者提供统一的接口。编解码需要用到的函数基本都在该库中，比如 avcodec\_find\_decoder（找到对应的第三方解码器）、avcodec\_decode\_video2（使用对应的解码器解码一帧图像/音频数据）。

## 离线ffmpeg数据结构设计说明

### 概述

#### 简介

FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、转换以及流化音视频的完整解决方案。

#### 读者对象

本文档是对SOX代码流程和相关技术点的整体说明，因此读者最好满足如下几点条件后再读此文档：

  - > 有一定的C和C++语言基础

### 数据结构设计

本节主要介绍AVFrame、AVCodec、AVStream结构体定义说明。

#### AVFrame

AVFrame结构体一般用于存储原始数据（即非压缩数据，例如对视频来说是YUV，RGB，对音频来说是PCM），此外还包含了一些相关的信息。

typedef struct AVFrame {

\#define AV\_NUM\_DATA\_POINTERS 8

uint8\_t \*data\[AV\_NUM\_DATA\_POINTERS\];

int linesize\[AV\_NUM\_DATA\_POINTERS\];

uint8\_t \*\*extended\_data;

int width, height;

int nb\_samples;

int format;

int key\_frame;

enum AVPictureType pict\_type;

AVRational sample\_aspect\_ratio;

int64\_t pts;

\#if FF\_API\_PKT\_PTS

attribute\_deprecated

int64\_t pkt\_pts;

\#endif

int64\_t pkt\_dts;

int coded\_picture\_number;

int display\_picture\_number;

int quality;

void \*opaque;

\#if FF\_API\_ERROR\_FRAME

attribute\_deprecated

uint64\_t error\[AV\_NUM\_DATA\_POINTERS\];

\#endif

int repeat\_pict;

int interlaced\_frame;

int top\_field\_first;

int palette\_has\_changed;

int64\_t reordered\_opaque;

int sample\_rate;

uint64\_t channel\_layout;

AVBufferRef \*buf\[AV\_NUM\_DATA\_POINTERS\];

AVBufferRef \*\*extended\_buf;

int nb\_extended\_buf;

AVFrameSideData \*\*side\_data;

int nb\_side\_data;

\#define AV\_FRAME\_FLAG\_CORRUPT (1 \<\< 0)

\#define AV\_FRAME\_FLAG\_DISCARD (1 \<\< 2)

int flags;

enum AVColorRange color\_range;

enum AVColorPrimaries color\_primaries;

enum AVColorTransferCharacteristic color\_trc;

enum AVColorSpace colorspace;

enum AVChromaLocation chroma\_location;

int64\_t best\_effort\_timestamp;

int64\_t pkt\_pos;

int64\_t pkt\_duration;

AVDictionary \*metadata;

int decode\_error\_flags;

\#define FF\_DECODE\_ERROR\_INVALID\_BITSTREAM 1

\#define FF\_DECODE\_ERROR\_MISSING\_REFERENCE 2

\#define FF\_DECODE\_ERROR\_CONCEALMENT\_ACTIVE 4

\#define FF\_DECODE\_ERROR\_DECODE\_SLICES 8

int channels;

int pkt\_size;

\#if FF\_API\_FRAME\_QP

attribute\_deprecated

int8\_t \*qscale\_table;

attribute\_deprecated

int qstride;

attribute\_deprecated

int qscale\_type;

attribute\_deprecated

AVBufferRef \*qp\_table\_buf;

\#endif

AVBufferRef \*hw\_frames\_ctx;

AVBufferRef \*opaque\_ref;

size\_t crop\_top;

size\_t crop\_bottom;

size\_t crop\_left;

size\_t crop\_right;

AVBufferRef \*private\_ref;

} AVFrame;

重要变量说明：

uint8\_t \*data\[AV\_NUM\_DATA\_POINTERS\]：解码后原始数据（对视频来说是YUV，RGB，对音频来说是PCM）

int linesize\[AV\_NUM\_DATA\_POINTERS\]：data中“一行”数据的大小。注意：未必等于图像的宽，一般大于图像的宽。

int width, height：视频帧宽和高（1920x1080,1280x720...）

int nb\_samples：音频的一个AVFrame中可能包含多个音频帧，在此标记包含了几个

int format：解码后原始数据类型（YUV420，YUV422，RGB24...）

int key\_frame：是否是关键帧

enum AVPictureType pict\_type：帧类型（I,B,P...）

AVRational sample\_aspect\_ratio：宽高比（16:9，4:3...）

int64\_t pts：显示时间戳

int coded\_picture\_number：编码帧序号

int display\_picture\_number：显示帧序号

int8\_t \*qscale\_table：QP表

uint8\_t \*mbskip\_table：跳过宏块表

int16\_t (\*motion\_val\[2\])\[2\]：运动矢量表

uint32\_t \*mb\_type：宏块类型表

short \*dct\_coeff：DCT系数，这个没有提取过

int8\_t \*ref\_index\[2\]：运动估计参考帧列表（貌似H.264这种比较新的标准才会涉及到多参考帧）

int interlaced\_frame：是否是隔行扫描

uint8\_t motion\_subsample\_log2：一个宏块中的运动矢量采样个数，取log的

#### AVCodec

AVCodec是存储编解码器信息的结构体。

typedef struct AVCodec {

const char \*name;

const char \*long\_name;

enum AVMediaType type;

enum AVCodecID id;

int capabilities;

const AVRational \*supported\_framerates; ///\< array of supported framerates, or NULL if any, array is terminated by {0,0}

const enum AVPixelFormat \*pix\_fmts; ///\< array of supported pixel formats, or NULL if unknown, array is terminated by -1

const int \*supported\_samplerates; ///\< array of supported audio samplerates, or NULL if unknown, array is terminated by 0

const enum AVSampleFormat \*sample\_fmts; ///\< array of supported sample formats, or NULL if unknown, array is terminated by -1

const uint64\_t \*channel\_layouts; ///\< array of support channel layouts, or NULL if unknown. array is terminated by 0

uint8\_t max\_lowres; ///\< maximum value for lowres supported by the decoder

const AVClass \*priv\_class; ///\< AVClass for the private context

const AVProfile \*profiles; ///\< array of recognized profiles, or NULL if unknown, array is terminated by {FF\_PROFILE\_UNKNOWN}

const char \*wrapper\_name;

int priv\_data\_size;

struct AVCodec \*next;

int (\*update\_thread\_context)(struct AVCodecContext \*dst, const struct AVCodecContext \*src);

const AVCodecDefault \*defaults;

void (\*init\_static\_data)(struct AVCodec \*codec);

int (\*init)(struct AVCodecContext \*);

int (\*encode\_sub)(struct AVCodecContext \*, uint8\_t \*buf, int buf\_size,

const struct AVSubtitle \*sub);

int (\*encode2)(struct AVCodecContext \*avctx, struct AVPacket \*avpkt,

const struct AVFrame \*frame, int \*got\_packet\_ptr);

int (\*decode)(struct AVCodecContext \*, void \*outdata, int \*outdata\_size, struct AVPacket \*avpkt);

int (\*close)(struct AVCodecContext \*);

int (\*send\_frame)(struct AVCodecContext \*avctx, const struct AVFrame \*frame);

int (\*receive\_packet)(struct AVCodecContext \*avctx, struct AVPacket \*avpkt);

int (\*receive\_frame)(struct AVCodecContext \*avctx, struct AVFrame \*frame);

void (\*flush)(struct AVCodecContext \*);

int caps\_internal;

const char \*bsfs;

const struct AVCodecHWConfigInternal \*\*hw\_configs;

const uint32\_t \*codec\_tags;

} AVCodec;

重要变量说明：

const char \*name：编解码器的名字，比较短

const char \*long\_name：编解码器的名字，全称，比较长

enum AVMediaType type：指明了类型，是视频，音频，还是字幕

enum AVCodecID id：ID，不重复

const AVRational \*supported\_framerates：支持的帧率（仅视频）

const enum AVPixelFormat \*pix\_fmts：支持的像素格式（仅视频）

const int \*supported\_samplerates：支持的采样率（仅音频）

const enum AVSampleFormat \*sample\_fmts：支持的采样格式（仅音频）

const uint64\_t \*channel\_layouts：支持的声道数（仅音频）

int priv\_data\_size：私有数据的大小

#### AVStream

AVStream是存储每一个视频/音频流信息的结构体。

typedef struct AVStream {

int index; /\*\*\< stream index in AVFormatContext \*/

int id;

\#if FF\_API\_LAVF\_AVCTX

attribute\_deprecated

AVCodecContext \*codec;

\#endif

void \*priv\_data;

AVRational time\_base;

int64\_t start\_time;

int64\_t duration;

int64\_t nb\_frames; ///\< number of frames in this stream if known or 0

int disposition; /\*\*\< AV\_DISPOSITION\_\* bit field \*/

enum AVDiscard discard; ///\< Selects which packets can be discarded at will and do not need to be demuxed.

AVRational sample\_aspect\_ratio;

AVDictionary \*metadata;

AVRational avg\_frame\_rate;

AVPacket attached\_pic;

AVPacketSideData \*side\_data;

int nb\_side\_data;

int event\_flags;

\#define AVSTREAM\_EVENT\_FLAG\_METADATA\_UPDATED 0x0001 ///\< The call resulted in updated metadata.

AVRational r\_frame\_rate;

\#if FF\_API\_LAVF\_FFSERVER

attribute\_deprecated

char \*recommended\_encoder\_configuration;

\#endif

AVCodecParameters \*codecpar;

\#define MAX\_STD\_TIMEBASES (30\*12+30+3+6)/

struct {

int64\_t last\_dts;

int64\_t duration\_gcd;

int duration\_count;

int64\_t rfps\_duration\_sum;

double (\*duration\_error)\[2\]\[MAX\_STD\_TIMEBASES\];

int64\_t codec\_info\_duration;

int64\_t codec\_info\_duration\_fields;

int frame\_delay\_evidence;

int found\_decoder;

int64\_t last\_duration;

int64\_t fps\_first\_dts;

int fps\_first\_dts\_idx;

int64\_t fps\_last\_dts;

int fps\_last\_dts\_idx;

} \*info;

int pts\_wrap\_bits; /\*\*\< number of bits in pts (used for wrapping control) \*/

int64\_t first\_dts;

int64\_t cur\_dts;

int64\_t last\_IP\_pts;

int last\_IP\_duration;

int probe\_packets;

int codec\_info\_nb\_frames;

enum AVStreamParseType need\_parsing;

struct AVCodecParserContext \*parser;

struct AVPacketList \*last\_in\_packet\_buffer;

AVProbeData probe\_data;

\#define MAX\_REORDER\_DELAY 16

int64\_t pts\_buffer\[MAX\_REORDER\_DELAY+1\];

AVIndexEntry \*index\_entries; /\*\*\< Only used if the format does not support seeking natively. \*/

int nb\_index\_entries;

unsigned int index\_entries\_allocated\_size;

int stream\_identifier;

int program\_num;

int pmt\_version;

int pmt\_stream\_idx;

int64\_t interleaver\_chunk\_size;

int64\_t interleaver\_chunk\_duration;

int request\_probe;

int skip\_to\_keyframe;

int skip\_samples;

int64\_t start\_skip\_samples;

int64\_t first\_discard\_sample;

int64\_t last\_discard\_sample;

int nb\_decoded\_frames;

int64\_t mux\_ts\_offset;

int64\_t pts\_wrap\_reference;

int pts\_wrap\_behavior;

int update\_initial\_durations\_done;

int64\_t pts\_reorder\_error\[MAX\_REORDER\_DELAY+1\];

uint8\_t pts\_reorder\_error\_count\[MAX\_REORDER\_DELAY+1\];

int64\_t last\_dts\_for\_order\_check;

uint8\_t dts\_ordered;

uint8\_t dts\_misordered;

int inject\_global\_side\_data;

AVRational display\_aspect\_ratio;

AVStreamInternal \*internal;

} AVStream;

重要变量说明：

int index：标识该视频/音频流

AVCodecContext \*codec：指向该视频/音频流的AVCodecContext（它们是一一对应的关系）

AVRational time\_base：时基。通过该值可以把PTS，DTS转化为真正的时间。

int64\_t duration：该视频/音频流长度

AVDictionary \*metadata：元数据信息

AVRational avg\_frame\_rate：帧率（注：对视频来说，这个挺重要的）

AVPacket attached\_pic：附带的图片。

## 离线FFMPEG开发测试环境说明

### 编译环境

#### 硬件环境

|     |      |      |
| --- | ---- | ---- |
| 分类  | 最低配置 | 推荐配置 |
| CPU | 4C   | 16   |
| 内存  | 8G   | 32G  |
| 磁盘  | 64G  | 128G |

#### 软件环境

|          |                   |        |
| -------- | ----------------- | ------ |
| 分类       | 名称                | 版本     |
| 操作系统     | Centos            | 7.x    |
| 数据库      | Redis             | 3.2.0  |
|          | Mysql             | 5.7.30 |
| 能力接口     | Tomcat            | 9.0.35 |
| GCC      | GCC               | 4.8.5  |
| G++      | G++               | 4.8.5  |
| GUN      | make              | 3.82   |
| ffmpeg源码 | ffmpeg-4.3.tar.gz | 4.3    |

#### 编译方式

编译安装

tar -xvjf ffmpeg-4.3.tar.gz

cd ffmpeg-4.3

./configure --disable-yasm --enable-shared --prefix=~/local/ffmpeg

make -j

make install

配置环境变量

echo "export LD\_LIBRARY\_PATH=\\$LD\_LIBRARY\_PATH:$ffmpeg\_dir/lib/"\>\>~/.bash\_profile

echo "export LIBRARY\_PATH=\\$LIBRARY\_PATH:$ffmpeg\_dir/lib/"\>\>~/.bash\_profile

echo "export PATH=\\$PATH:$ffmpeg\_dir/bin/"\>\>~/.bash\_profile

echo "export C\_INCLUDE\_PATH=\\$C\_INCLUDE\_PATH:$ffmpeg\_dir/include/" \>\> ~/.bash\_profile

echo "export CPLUS\_INCLUDE\_PATH=\\$CPLUS\_INCLUDE\_PATH:$ffmpeg\_dir/include/" \>\> ~/.bash\_profile

echo "export PKG\_CONFIG\_PATH=\\$PKG\_CONFIG\_PATH:$ffmpeg\_dir/lib/pkgconfig/" \>\> ~/.bash\_profile

echo "export LD\_LIBRARY\_PATH=\\$LD\_LIBRARY\_PATH:$ffmpeg\_dir/lib/"\>\>~/.bashrc

echo "export LIBRARY\_PATH=\\$LIBRARY\_PATH:$ffmpeg\_dir/lib/"\>\>~/.bashrc

echo "export PATH=\\$PATH:$ffmpeg\_dir/bin/"\>\>~/.bashrc

echo "export C\_INCLUDE\_PATH=\\$C\_INCLUDE\_PATH:$ffmpeg\_dir/include/"\>\>~/.bashrc

echo "export CPLUS\_INCLUDE\_PATH=\\$CPLUS\_INCLUDE\_PATH:$ffmpeg\_dir/include/" \>\> ~/.bashrc

echo "export PKG\_CONFIG\_PATH=\\$PKG\_CONFIG\_PATH:$ffmpeg\_dir/lib/pkgconfig/" \>\> ~/.bashrc

#### 输出结果

编译输出四个目录

bin 可执行文件ffmpeg

include 头文件

lib lib\*.so动态库

### 测试环境部署

#### 系统安装

如上1.3方式已经编译好FFMPEG,无需在安装部署；

#### 运行环境

|      |        |       |
| ---- | ------ | ----- |
| 分类   | 名称     | 版本    |
| 操作系统 | Centos | 7.x   |
| GCC  | GCC    | 4.8.5 |
| G++  | G++    | 4.8.5 |
| GUN  | make   | 3.82  |

### 系统测试

#### 测试工具

ffmpeg可执行文件

#### 测试脚本

无

#### 测试数据

1.mp3单声道语音。

#### 测试方法

执行命令：ffmpeg -i 1.mp3 -f wav 1.wav

#### 测试结果

生成wav格式语音。

# 语音格式转换-SOX

## 离线识别引擎SOX源代码清单

### 概述

#### 编写目的

文档编写目的是为代码维护者能清楚了解代码模块的具体功能及分布位置，本文档的读者对象为开发人员和测试人员。

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件；

### 运行环境

#### 软件环境

| 分类     | 名称   | 版本    |
| -------- | ------ | ------- |
| 操作系统 | Centos | 7.0以上 |
| 数据库   | Redis  | 3.2.0   |
|          | Mysql  | 5.7.6   |
| 能力接口 | Tomcat | 9.0.35  |

#### 硬件环境

<table>
<tbody>
<tr class="odd">
<td>服务器</td>
<td>最低配置</td>
<td>推荐配置</td>
</tr>
<tr class="even">
<td>redis服务器</td>
<td><p>CPU：1</p>
<p>内存：256M</p></td>
<td><p>CPU：1</p>
<p>内存：1G</p></td>
</tr>
<tr class="odd">
<td>识别服务器</td>
<td><p>CPU：4</p>
<p>内存：10G</p>
<p>磁盘：20G</p></td>
<td><p>CPU：10</p>
<p>内存：15G</p>
<p>磁盘：30G</p></td>
</tr>
</tbody>
</table>

### 源代码清单

#### 代码清单

<table>
<tbody>
<tr class="odd">
<td>程序名</td>
<td>程序路径</td>
</tr>
<tr class="even">
<td><p>8svx.c</p>
<p>adpcm.c</p>
<p>adpcm.h</p>
<p>adpcms.c</p>
<p>adpcms.h</p>
<p>aifc-fmt.c</p>
<p>aiff.c</p>
<p>aiff-fmt.c</p>
<p>aiff.h</p>
<p>al-fmt.c</p>
<p>alsa.c</p>
<p>amr.h</p>
<p>amr-nb.c</p>
<p>amr-wb.c</p>
<p>ao.c</p>
<p>au.c</p>
<p>avr.c</p>
<p>band.h</p>
<p>bend.c</p>
<p>biquad.c</p>
<p>biquad.h</p>
<p>biquads.c</p>
<p>caf.c</p>
<p>cdr.c</p>
<p>chorus.c</p>
<p>CMakeLists.txt</p>
<p>compand.c</p>
<p>compandt.c</p>
<p>compandt.h</p>
<p>contrast.c</p>
<p>coreaudio.c</p>
<p>cvsd.c</p>
<p>cvsdfilt.h</p>
<p>cvsd-fmt.c</p>
<p>cvsd.h</p>
<p>dat.c</p>
<p>dcshift.c</p>
<p>delay.c</p>
<p>dft_filter.c</p>
<p>dft_filter.h</p>
<p>dither.c</p>
<p>dither.h</p>
<p>divide.c</p>
<p>downsample.c</p>
<p>dvms-fmt.c</p>
<p>earwax.c</p>
<p>echo.c</p>
<p>echos.c</p>
<p>effects.c</p>
<p>effects.h</p>
<p>effects_i.c</p>
<p>effects_i_dsp.c</p>
<p>example0.c</p>
<p>example1.c</p>
<p>example2.c</p>
<p>example3.c</p>
<p>example4.c</p>
<p>example5.c</p>
<p>example6.c</p>
<p>f4-fmt.c</p>
<p>f8-fmt.c</p>
<p>fade.c</p>
<p>fap.c</p>
<p>fft4g.c</p>
<p>fft4g.h</p>
<p>fifo.h</p>
<p>fir.c</p>
<p>firfit.c</p>
<p>flac.c</p>
<p>flanger.c</p>
<p>formats.c</p>
<p>formats.h</p>
<p>formats_i.c</p>
<p>g711.c</p>
<p>g711.h</p>
<p>g721.c</p>
<p>g723_24.c</p>
<p>g723_40.c</p>
<p>g72x.c</p>
<p>g72x.h</p>
<p>gain.c</p>
<p>getopt.c</p>
<p>gsm.c</p>
<p>gsrt.c</p>
<p>hcom.c</p>
<p>hilbert.c</p>
<p>htk.c</p>
<p>ignore-warning.h</p>
<p>ima-fmt.c</p>
<p>ima_rw.c</p>
<p>ima_rw.h</p>
<p>input.c</p>
<p>ladspa.c</p>
<p>ladspa.h</p>
<p>la-fmt.c</p>
<p>libsox.c</p>
<p>libsox_i.c</p>
<p>loudness.c</p>
<p>lpc10.c</p>
<p>lu-fmt.c</p>
<p>Makefile.am</p>
<p>Makefile.in</p>
<p>mat4.c</p>
<p>mat5.c</p>
<p>maud.c</p>
<p>mcompand.c</p>
<p>mcompand_xover.h</p>
<p>monkey.wav</p>
<p>mp3.c</p>
<p>mp3-util.h</p>
<p>noiseprof.c</p>
<p>noisered.c</p>
<p>noisered.h</p>
<p>nulfile.c</p>
<p>optional-fmts.am</p>
<p>opus.c</p>
<p>oss.c</p>
<p>output.c</p>
<p>overdrive.c</p>
<p>pad.c</p>
<p>paf.c</p>
<p>phaser.c</p>
<p>prc.c</p>
<p>pulseaudio.c</p>
<p>pvf.c</p>
<p>rate.c</p>
<p>rate_filters.h</p>
<p>rate_half_fir.h</p>
<p>rate_poly_fir0.h</p>
<p>rate_poly_fir.h</p>
<p>raw.c</p>
<p>raw-fmt.c</p>
<p>raw.h</p>
<p>remix.c</p>
<p>repeat.c</p>
<p>reverb.c</p>
<p>reverse.c</p>
<p>s1-fmt.c</p>
<p>s2-fmt.c</p>
<p>s3-fmt.c</p>
<p>s4-fmt.c</p>
<p>sd2.c</p>
<p>sf.c</p>
<p>silence.c</p>
<p>sinc.c</p>
<p>skeleff.c</p>
<p>skelform.c</p>
<p>smp.c</p>
<p>sndfile.c</p>
<p>sndio.c</p>
<p>sounder.c</p>
<p>soundtool.c</p>
<p>sox.c</p>
<p>soxconfig.h.cmake</p>
<p>soxconfig.h.in</p>
<p>sox-fmt.c</p>
<p>sox.h</p>
<p>sox_i.h</p>
<p>soxomp.h</p>
<p>sox_sample_test.c</p>
<p>sox_sample_test.h</p>
<p>spectrogram.c</p>
<p>speed.c</p>
<p>sphere.c</p>
<p>splice.c</p>
<p>stat.c</p>
<p>stats.c</p>
<p>stretch.c</p>
<p>sunaudio.c</p>
<p>swap.c</p>
<p>synth.c</p>
<p>tempo.c</p>
<p>testall.bat</p>
<p>testall.sh</p>
<p>test-comments</p>
<p>tests.bat</p>
<p>tests.sh</p>
<p>tremolo.c</p>
<p>trim.c</p>
<p>tx16w.c</p>
<p>u1-fmt.c</p>
<p>u2-fmt.c</p>
<p>u3-fmt.c</p>
<p>u4-fmt.c</p>
<p>ul-fmt.c</p>
<p>upsample.c</p>
<p>util.c</p>
<p>util.h</p>
<p>vad.c</p>
<p>voc.c</p>
<p>vol.c</p>
<p>vorbis.c</p>
<p>vox.c</p>
<p>vox-fmt.c</p>
<p>vox.h</p>
<p>w64.c</p>
<p>wav.c</p>
<p>waveaudio.c</p>
<p>wavpack.c</p>
<p>win32-glob.c</p>
<p>win32-glob.h</p>
<p>win32-ltdl.c</p>
<p>win32-ltdl.h</p>
<p>wve.c</p>
<p>xa.c</p>
<p>xi.c</p>
<p>xmalloc.c</p>
<p>xmalloc.h</p></td>
<td>sox-14.4.2/src</td>
</tr>
</tbody>
</table>

## 离线SOX概要设计说明

### 概述

#### 简介

Sox项目是由Lance Norskog创立的，后来被众多的开发者逐步完善，现在已经能够支持很多种声音文件格式和声音处理效果。基本上常见的声音格式都能够支持。更加有用的是，Sox能够进行声音滤波、采样频率转换。

SoX是Sound eXchange的简称，当ffmpeg不支持某些语音格式的转码时，负责对这些特殊的语音进行转码。

SoX可以读写最流行格式的音频文件，并且可以对音频进行任意操作。它可以将多个输入源合成音频。在许多系统，它可以作为一个大众的音频播放器或者多轨录音机。它也可以进行少量的将输入文件切割成多个文件。

#### 读者对象

本文档的读者对象为离线识别系统的开发人员、测试人员、系统维护人员及接入识别系统的第三方业务人员，通过本文档能够从总体上了解SOX的架构形式及数据流向。

本说明给出FFMPEG的设计说明，包括最终实现的系统必须满足的功能、性能、接口、附属测试工具程序及设计约束等。

目的在于：

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件；

#### 术语定义

语音识别（Automatic Speech Recognition），简称（ASR）。

### 总体设计

#### 总体需求

功能需求：对语音进行转码；

性能需求：转码耗时低；

接口需求：接口参数简单明了，接口中的每个参数都要有实际意义，保证接口调用流程清晰。

系统验证工具：提供系统完整性，功能正确性的验证工具；

#### 运行环境

##### 软件环境

| 分类     | 名称   | 版本    |
| -------- | ------ | ------- |
| 操作系统 | Centos | 7.0以上 |
| 数据库   | Redis  | 3.2.0   |
| 能力接口 | Tomcat | 9.0.35  |

##### 硬件环境

<table>
<tbody>
<tr class="odd">
<td>服务器</td>
<td>最低配置</td>
<td>推荐配置</td>
</tr>
<tr class="even">
<td>redis服务器</td>
<td><p>CPU：1</p>
<p>内存：256M</p></td>
<td><p>CPU：1</p>
<p>内存：1G</p></td>
</tr>
<tr class="odd">
<td>识别服务器</td>
<td><p>CPU：4</p>
<p>内存：10G</p>
<p>磁盘：20G</p></td>
<td><p>CPU：10</p>
<p>内存：15G</p>
<p>磁盘：30G</p></td>
</tr>
</tbody>
</table>

#### 系统总体结构设计

SoX 可以读取和写入常见格式的音频文件，并在此过程中选择性的加入一些声音效果。它可以组合多个输入源及合成音效，在许多系统上也可以作为音频播放器或多轨录音机使用。sox整个流程如下图所示。

### 模块设计

####  sox基本使用

1. libavformat获取音频文件的元数据：
    - soxi 或 sox --i 命令可以通过分析音频文件的文件头，获取其元数据（如通道数、采样率、编码等）。
    - soxi Faded.wav
    - Input File : 'Faded.wav'
    - Channels : 2
    - Sample Rate : 44100
    - Precision : 16-bit
    - Duration : 00:03:32.63 = 9376836 samples = 15947 CDDA sectors
    - File Size : 37.5M
    - Bit Rate : 1.41M
    - Sample Encoding: 16-bit Signed Integer PCM

2.  获取音频的统计信息：
    
    可以使用 sox \<inputfile\> -n stat 命令获取某音频文件的统计信息。示例如下：
    
    - sox Faded.wav -n stat
    - Samples read: 18753672
    - Length (seconds): 212.626667
    - Scaled by: 2147483647.0
    - Maximum amplitude: 0.977417
    - Minimum amplitude: -0.977478
    - Midline amplitude: -0.000031
    - Mean norm: 0.229415
    - Mean amplitude: -0.000006
    - RMS amplitude: 0.302594
    - Maximum delta: 1.765564
    - Minimum delta: 0.000000
    - Mean delta: 0.202369
    - RMS delta: 0.273320
    - Rough frequency: 6339
    - Volume adjustment: 1.023
    
3.  播放与录制：

play 和 rec 命令提供了最基本的播放和录制功能。 

播放：$ play existing-file.wav  
录制：$ rec new-file.wav

上述命令等同于 sox 命令的如下形式： 

$ sox existing-file.wav −d（播放）和 sox −d new-file.wav（录制）  

其中 -d 选项用于指定播放或录制时使用的音频设备，不指定时则表示使用默认设备。

4.  音频格式转换：

    `文件格式类型`

    对于音频数据格式的描述，主要通过以下 4 种属性：

    - 采样率（sample rate）：指声音由模拟信号转换成数字信号的过程中，每秒从连续信号中提取的用于组成离散信号的样本个数。音频CD所用的采样率为 44100 Hz，数字音频磁带和许多计算机系统使用 48000 Hz，专业级音频系统通常使用 96000 Hz。
    - 采样大小（sample size 或 Precision）：音频采样时用于存储每个样本的数据位数（bits）。
    - 编码格式（data encoding）：即每个音频样本的表示（即“编码”）方式。常用的编码类型包括 floating-point、μ-law、ADPCM、singed-integer PCM、MP3 和 FLAC 等。
    - 通道（channel）：即文件中包含的音频通道的数量。其中单声道（mono）和双声道（stereo）是最常见的两种，“环绕声”音频（Surround sound）通常包含六个或更多声道。

    此外，音频文件还使用比特率（Bit Rate）表示一个单位时间内编码音频信号占用的存储空间大小， 它的数值一般取决于所有的上述四个参数。

    MP3 编码的立体声音乐通常具有 128-196kbps 的比特率， FLAC 编码的立体声音乐通常具有 550-760kbps 的比特率。

    `格式转换`

    形式最简单的 sox 命令即使用两个文件名作为参数，如：

    sox Faded.wav Faded.mp3 ：将 Faded.wav 文件的格式由 wav 转为 mp3

    上述命令执行时，SoX 会先从 Faded.wav 文件中读取音频数据，再将其输出到 Faded.mp3 文件中。而 SoX 程序会根据参数中文件名的后缀推断出相应的格式，并在复制音频数据的过程中自动进行转码。

    SoX 可以处理 self-describing 和 raw 格式的音频文件。

    self-describing 格式（如 WAV、FLAC、MP3）的文件包含一个用于描述信号和编码属性的文件头，而 raw 或 headless 格式的音频则不包含这些信息。

    所以当 raw 格式的音频作为输入文件时，需要在 sox 命令的格式选项里指定其信号和编码属性。

    

    **常用的音频格式选项：**

    选项 描述

    \-b, --bits BITS 每个编码样本占用的数据位数

    \-c, --channels CHANNELS 音频文件包含的通道数

    \-e, --encoding ENCODING 音频文件的编码类型

    \-r, --rate RATE 音频文件的采样率

    \-t, --type FILE-TYPE 音频文件的文件类型

    

    上述选项适用于输入或输出文件，主要用于说明 raw（或 headless）文件作为输入时的格式信息，或格式转换时指定输出文件的具体参数。

    sox −r 48k −e float −b 32 −c 2 input.raw output.wav

    将某个特定的 raw 格式的音频文件转换为 wav 格式。

    sox Faded.wav Faded.raw

    将音频文件 Faded.wav 转为 raw 格式。

    play -r 44800 -b 16 -e signed-integer -c 2 Faded.raw

    播放 raw 格式的音频文件。

    sox Faded.wav -c 1 Faded-mono.wav

将 Faded.wav 文件转换成单声道（-c 1）后输出。



#### sox转码流程

Sox具体处理流程如下：

关键函数说明：

sox\_init()：初始化全局参数

sox\_open\_mem\_read：打开文件；

sox\_open\_men\_write：打开输出文件；

sox\_create\_effects\_chain：构建一个效果器链；

sox\_create\_effect：创建一个简单的效果输入文件；

sox\_add\_effect：添加效果器到效果器链；

sox\_flow\_effects：效果器运行；

sox\_delete\_effects\_chain：释放资源；

sox\_close：关闭文件；

sox\_quit：退出；

主要函数介绍：

函数原型：

int LSX\_API sox\_init(void);

参数说明：

返回值：

int类型。取值及说明如下：

0 ：成功

非0 ：失败

功能：

初始化全局参数。

函数原型：

LSX\_RETURN\_OPT sox\_format\_t \* LSX\_API sox\_open\_mem\_read(

LSX\_PARAM\_IN\_BYTECOUNT(buffer\_size) void \* buffer,

size\_t buffer\_size,

LSX\_PARAM\_IN\_OPT sox\_signalinfo\_t const \* signal,

LSX\_PARAM\_IN\_OPT sox\_encodinginfo\_t const \* encoding,

LSX\_PARAM\_IN\_OPT\_Z char const \* filetype

);

参数说明：

LSX\_PARAM\_IN\_BYTECOUNT(buffer\_size) void \* buffer 数据指针

size\_t buffer\_size, 数据大小

LSX\_PARAM\_IN\_OPT sox\_signalinfo\_t const \* signal 信号量

LSX\_PARAM\_IN\_OPT sox\_encodinginfo\_t const \* encoding 编码信息

LSX\_PARAM\_IN\_OPT\_Z char const \* filetype 文件类型

返回值：sox\_format\_t指针

功能：

打开输入文件。

函数原型：

LSX\_RETURN\_OPT sox\_format\_t \* LSX\_API sox\_open\_mem\_write(

LSX\_PARAM\_OUT\_BYTECAP(buffer\_size) void \* buffer,

LSX\_PARAM\_IN size\_t buffer\_size,

LSX\_PARAM\_IN sox\_signalinfo\_t const \* signal,

LSX\_PARAM\_IN\_OPT sox\_encodinginfo\_t const \* encoding,

LSX\_PARAM\_IN\_OPT\_Z char const \* filetype

LSX\_PARAM\_IN\_OPT sox\_oob\_t const \* oob

);

参数说明：

LSX\_PARAM\_OUT\_BYTECAP(buffer\_size) void \* buffer 数据指针

size\_t buffer\_size, 数据大小

LSX\_PARAM\_IN\_OPT sox\_signalinfo\_t const \* signal 信号量

LSX\_PARAM\_IN\_OPT sox\_encodinginfo\_t const \* encoding 编码信息

LSX\_PARAM\_IN\_OPT\_Z char const \* filetype 文件类型

LSX\_PARAM\_IN\_OPT sox\_oob\_t const \* oob 输出数据指针

返回值：sox\_format\_t指针

功能：

打开输出文件。

函数原型：

LSX\_RETURN\_OPT sox\_effects\_chain\_t \* LSX\_API sox\_create\_effects\_chain(

LSX\_PARAM\_IN sox\_encodinginfo\_t const \* in\_enc,

LSX\_PARAM\_IN sox\_encodinginfo\_t const \* out\_enc

);

参数说明：

LSX\_PARAM\_IN sox\_encodinginfo\_t const \* in\_enc 效果器指针

LSX\_PARAM\_IN sox\_encodinginfo\_t const \* out\_enc效果器结果指针

返回值：sox\_effects\_chain\_t指针

功能：

构建效果器链。

函数原型：

LSX\_RETURN\_OPT sox\_effect\_t \* LSX\_API sox\_create\_effect(

LSX\_PARAM\_IN sox\_effect\_handler\_t const \* eh

);

参数说明：

LSX\_PARAM\_IN sox\_effect\_handler\_t const \* eh 效果器信息指针

返回值：sox\_effect\_t指针

功能：

构建简单效果器。

函数原型：

int LSX\_API sox\_add\_effect(

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \* chain,

LSX\_PARAM\_INOUT sox\_effect\_t \* effp,

LSX\_PARAM\_INOUT sox\_signalinfo\_t \* in,

LSX\_PARAM\_IN sox\_signalinfo\_t const \* out

);

参数说明：

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \* chain 效果器链指针

LSX\_PARAM\_INOUT sox\_effect\_t \* effp 效果器指针

LSX\_PARAM\_INOUT sox\_signalinfo\_t \* in Input format

LSX\_PARAM\_IN sox\_signalinfo\_t const \* out Output format

返回值：

int类型。取值及说明如下：

0 ：成功

非0 ：失败

功能：

添加效果器到效果器链。

函数原型：

int LSX\_API sox\_flow\_effects(

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \* chain,

LSX\_PARAM\_IN\_OPT sox\_flow\_effects\_callback callback,

LSX\_PARAM\_IN\_OPT void \* client\_data

);

参数说明：

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \* chain 运行效果器链指针

LSX\_PARAM\_IN\_OPT sox\_flow\_effects\_callback callback 回调

LSX\_PARAM\_IN\_OPT void \* client\_data 回调结果数据

返回值：

int类型。取值及说明如下：

0 ：成功

非0 ：失败

功能：

运行效果器。

函数原型：

void LSX\_API sox\_delete\_effects\_chain(

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \*ecp

);

参数说明：

LSX\_PARAM\_INOUT sox\_effects\_chain\_t \*ecp 效果器链指针

返回值：

功能：

释放效果器链资源。

函数原型：

int LSX\_API sox\_close(

LSX\_PARAM\_INOUT sox\_format\_t \* ft

);

参数说明：

LSX\_PARAM\_INOUT sox\_format\_t \* ft 效果器指针

返回值：

int类型。取值及说明如下：

0 ：成功

非0 ：失败

功能：

关闭效果器。

函数原型：

int LSX\_API sox\_quit(void);

参数说明：

返回值：

int类型。取值及说明如下：

0 ：成功

非0 ：失败

功能：

退出。

### 测试设计

#### 配置文件设计

设置配置文件，方便使用不同控制逻辑，支持不同的功能及结果输出，配置参数实现如下目的：

  - 通过参数控制支持特殊功能

配置主要参数如下表：

|        |     |               |
| ------ | --- | ------------- |
| 参数     | 取值  | 说明            |
| inwav  | 字符串 | 待转码语音         |
| \-b    |     | 每个编码样本占用的数据位数 |
| \-c    |     | 音频文件包含的通道数    |
| \-r    |     | 音频文件的采样率      |
| outwav | 字符串 | 转码后语音         |

#### 测试功能点

根据设计需求，对服务必须满足的功能点进行验证测试。

|             |                 |
| ----------- | --------------- |
| 测试功能        | 期望结果            |
| 使用不同的语音进行转码 | 正确配置参数，转码后语音正常。 |

### 可靠性设计

离线系统SOX设计考虑了实际应用场景的复杂性和输入的多样性的情况，内部加入了大部分实际情况中会出现的异常情况的处理方案，保证稳定性和可靠性。

### 扩展性设计

系统本身遵循模块化设计，可以随时添加定制化功能，满足不同应用场景的需要。

### 维护性设计

离线系统为了方便后期的引擎维护，采用标准c/c++函数同时在较低编译器上进行编译

### 易用性设计

系统安装部署时有一键安装部署脚本，只需要执行脚本即可安装,减少操作量。系统启停均有对应的脚本，实现自动启动、停止服务。

## 离线识别引擎SOX接口设计

### 概述

#### 编写目的

本文档主要描述sox内部接口设计及接口中参数的数据结构，本文档的读者对象为离线识别系统的开发人员、测试人员、系统维护人员及接入识别系统的第三方业务人员，通过本文档能够从总体上了解识别系统内部的数据流向及处理方式。

本说明给出SOX的接口设计说明，包括接口安全、版本兼容性、数据格式、服务端的异常处理等。

目的在于：

  - 为开发人员提供依据；

  - 为代码修改、维护提供条件；

### 总体设计

#### 总体需求

接口需求：

1，接口参数简单明了，参数有实际意义；

2，接口功能定义明确；

3，接口的数据特性明确；

4，接口的规格和技术要求明确；

5，接口程序的数据处理逻辑清晰；

### SOX接口设计

本节主要介绍soxAPI使用。

SoX 处理音频的基本流程如下：

#### 通用 API 

1.sox\_init()：

在使用SOX库之前，必须初始化整个库的全局参数。函数返回一个整数，如果返回的是SOX\_SUCCESS这个枚举值，代码初始化成功；

2.sox\_init()：

退出SOX在。

3.sox\_open\_read()：

初始化输入文件。

4.sox\_open\_write()：

初始化输出文件。

5.sox\_create\_chain()：

构造效果器链。

6.  sox\_create\_cffect()
    
    构建一个输入数据的效果器。

7.  sox\_effect\_options()
    
    输入文件配置到这个效果器。

8.  sox\_add\_effect()
    
    效果器增加到效果器链。

9.  sox\_flow\_effects()
    
    运行效果器链。

### 代码目录

#### 代码目录结构

> sox-14.4.2
> 
> ├── 8svx.c
> 
> ├── adpcm.c
> 
> ├── adpcm.h
> 
> ├── adpcms.c
> 
> ├── adpcms.h
> 
> ├── aifc-fmt.c
> 
> ├── aiff.c
> 
> ├── aiff-fmt.c
> 
> ├── aiff.h
> 
> ├── al-fmt.c
> 
> ├── alsa.c
> 
> ├── amr.h
> 
> ├── amr-nb.c
> 
> ├── amr-wb.c
> 
> ├── ao.c
> 
> ├── au.c
> 
> ├── avr.c
> 
> ├── band.h
> 
> ├── bend.c
> 
> ├── biquad.c
> 
> ├── biquad.h
> 
> ├── biquads.c
> 
> ├── caf.c
> 
> ├── cdr.c
> 
> ├── chorus.c
> 
> ├── CMakeLists.txt
> 
> ├── compand.c
> 
> ├── compandt.c
> 
> ├── compandt.h
> 
> ├── contrast.c
> 
> ├── coreaudio.c
> 
> ├── cvsd.c
> 
> ├── cvsdfilt.h
> 
> ├── cvsd-fmt.c
> 
> ├── cvsd.h
> 
> ├── dat.c
> 
> ├── dcshift.c
> 
> ├── delay.c
> 
> ├── dft\_filter.c
> 
> ├── dft\_filter.h
> 
> ├── dither.c
> 
> ├── dither.h
> 
> ├── divide.c
> 
> ├── downsample.c
> 
> ├── dvms-fmt.c
> 
> ├── earwax.c
> 
> ├── echo.c
> 
> ├── echos.c
> 
> ├── effects.c
> 
> ├── effects.h
> 
> ├── effects\_i.c
> 
> ├── effects\_i\_dsp.c
> 
> ├── example0.c
> 
> ├── example1.c
> 
> ├── example2.c
> 
> ├── example3.c
> 
> ├── example4.c
> 
> ├── example5.c
> 
> ├── example6.c
> 
> ├── f4-fmt.c
> 
> ├── f8-fmt.c
> 
> ├── fade.c
> 
> ├── fap.c
> 
> ├── fft4g.c
> 
> ├── fft4g.h
> 
> ├── fifo.h
> 
> ├── fir.c
> 
> ├── firfit.c
> 
> ├── flac.c
> 
> ├── flanger.c
> 
> ├── formats.c
> 
> ├── formats.h
> 
> ├── formats\_i.c
> 
> ├── g711.c
> 
> ├── g711.h
> 
> ├── g721.c
> 
> ├── g723\_24.c
> 
> ├── g723\_40.c
> 
> ├── g72x.c
> 
> ├── g72x.h
> 
> ├── gain.c
> 
> ├── getopt.c
> 
> ├── gsm.c
> 
> ├── gsrt.c
> 
> ├── hcom.c
> 
> ├── hilbert.c
> 
> ├── htk.c
> 
> ├── ignore-warning.h
> 
> ├── ima-fmt.c
> 
> ├── ima\_rw.c
> 
> ├── ima\_rw.h
> 
> ├── input.c
> 
> ├── ladspa.c
> 
> ├── ladspa.h
> 
> ├── la-fmt.c
> 
> ├── libsox.c
> 
> ├── libsox\_i.c
> 
> ├── loudness.c
> 
> ├── lpc10.c
> 
> ├── lu-fmt.c
> 
> ├── Makefile.am
> 
> ├── Makefile.in
> 
> ├── mat4.c
> 
> ├── mat5.c
> 
> ├── maud.c
> 
> ├── mcompand.c
> 
> ├── mcompand\_xover.h
> 
> ├── monkey.wav
> 
> ├── mp3.c
> 
> ├── mp3-util.h
> 
> ├── noiseprof.c
> 
> ├── noisered.c
> 
> ├── noisered.h
> 
> ├── nulfile.c
> 
> ├── optional-fmts.am
> 
> ├── opus.c
> 
> ├── oss.c
> 
> ├── output.c
> 
> ├── overdrive.c
> 
> ├── pad.c
> 
> ├── paf.c
> 
> ├── phaser.c
> 
> ├── prc.c
> 
> ├── pulseaudio.c
> 
> ├── pvf.c
> 
> ├── rate.c
> 
> ├── rate\_filters.h
> 
> ├── rate\_half\_fir.h
> 
> ├── rate\_poly\_fir0.h
> 
> ├── rate\_poly\_fir.h
> 
> ├── raw.c
> 
> ├── raw-fmt.c
> 
> ├── raw.h
> 
> ├── remix.c
> 
> ├── repeat.c
> 
> ├── reverb.c
> 
> ├── reverse.c
> 
> ├── s1-fmt.c
> 
> ├── s2-fmt.c
> 
> ├── s3-fmt.c
> 
> ├── s4-fmt.c
> 
> ├── sd2.c
> 
> ├── sf.c
> 
> ├── silence.c
> 
> ├── sinc.c
> 
> ├── skeleff.c
> 
> ├── skelform.c
> 
> ├── smp.c
> 
> ├── sndfile.c
> 
> ├── sndio.c
> 
> ├── sounder.c
> 
> ├── soundtool.c
> 
> ├── sox.c
> 
> ├── soxconfig.h.cmake
> 
> ├── soxconfig.h.in
> 
> ├── sox-fmt.c
> 
> ├── sox.h
> 
> ├── sox\_i.h
> 
> ├── soxomp.h
> 
> ├── sox\_sample\_test.c
> 
> ├── sox\_sample\_test.h
> 
> ├── spectrogram.c
> 
> ├── speed.c
> 
> ├── sphere.c
> 
> ├── splice.c
> 
> ├── stat.c
> 
> ├── stats.c
> 
> ├── stretch.c
> 
> ├── sunaudio.c
> 
> ├── swap.c
> 
> ├── synth.c
> 
> ├── tempo.c
> 
> ├── testall.bat
> 
> ├── testall.sh
> 
> ├── test-comments
> 
> ├── tests.bat
> 
> ├── tests.sh
> 
> ├── tremolo.c
> 
> ├── trim.c
> 
> ├── tx16w.c
> 
> ├── u1-fmt.c
> 
> ├── u2-fmt.c
> 
> ├── u3-fmt.c
> 
> ├── u4-fmt.c
> 
> ├── ul-fmt.c
> 
> ├── upsample.c
> 
> ├── util.c
> 
> ├── util.h
> 
> ├── vad.c
> 
> ├── voc.c
> 
> ├── vol.c
> 
> ├── vorbis.c
> 
> ├── vox.c
> 
> ├── vox-fmt.c
> 
> ├── vox.h
> 
> ├── w64.c
> 
> ├── wav.c
> 
> ├── waveaudio.c
> 
> ├── wavpack.c
> 
> ├── win32-glob.c
> 
> ├── win32-glob.h
> 
> ├── win32-ltdl.c
> 
> ├── win32-ltdl.h
> 
> ├── wve.c
> 
> ├── xa.c
> 
> ├── xi.c
> 
> ├── xmalloc.c
> 
> └── xmalloc.h

#### 主要代码模块说明

##### 转码模块

g72x.c该文件主要实现g72x格式文件转换。

mp3.c该文件主要实现mp3格式文件转换。

##### 控制模块

sox.c该文件主要实现流程处理函数的实现。

## 离线sox数据结构设计说明

### 概述

#### 简介

Sox项目是由Lance Norskog创立的，后来被众多的开发者逐步完善，现在已经能够支持很多种声音文件格式和声音处理效果。基本上常见的声音格式都能够支持。更加有用的是，Sox能够进行声音滤波、采样频率转换。

Sox是Sound eXchange的简称，当ffmpeg不支持某些语音格式的转码时（如vox、V3格式），负责对这些特殊的语音进行转码。

#### 读者对象

本文档是对SOX代码流程和相关技术点的整体说明，因此读者最好满足如下几点条件后再读此文档：

  - > 有一定的C和C++语言基础

### 数据结构设计

本节主要介绍sox\_format\_t 、sox\_effect\_handler\_t、sox\_effect\_t结构体定义说明。

#### sox\_format\_t

struct sox\_format\_t {

char \* filename; /\*\*\< File name \*/

sox\_signalinfo\_t signal;

sox\_encodinginfo\_t encoding;

char \* filetype; /\*\*\< Type of file, as determined by header inspection or libmagic. \*/

sox\_oob\_t oob; /\*\*\< comments, instrument info, loop info (out-of-band data) \*/

sox\_bool seekable; /\*\*\< Can seek on this file \*/

char mode; /\*\*\< Read or write mode ('r' or 'w') \*/

sox\_uint64\_t olength; /\*\*\< Samples \* chans written to file \*/

sox\_uint64\_t clips; /\*\*\< Incremented if clipping occurs \*/

int sox\_errno; /\*\*\< Failure error code \*/

char sox\_errstr\[256\]; /\*\*\< Failure error text \*/

void \* fp; /\*\*\< File stream pointer \*/

lsx\_io\_type io\_type; /\*\*\< Stores whether this is a file, pipe or URL \*/

sox\_uint64\_t tell\_off; /\*\*\< Current offset within file \*/

sox\_uint64\_t data\_start; /\*\*\< Offset at which headers end and sound data begins (set by lsx\_check\_read\_params) \*/

sox\_format\_handler\_t handler; /\*\*\< Format handler for this file \*/

void \* priv; /\*\*\< Format handler's private data area \*/

};

重要变量说明：

char \* filename; 文件名

sox\_signalinfo\_t signal; 信号

sox\_encodinginfo\_t encoding; 编码信息

char \* filetype; 文件类型，由头检查或libmagic确定

sox\_oob\_t oob; 循环信息

sox\_bool seekable; 是否查找

char mode; 模式

sox\_uint64\_t olength; 写入文件长度

sox\_uint64\_t clips; 递增clips

int sox\_errno; 错误码

char sox\_errstr\[256\]; 错误信息

void \* fp; 文件指针

lsx\_io\_type io\_type; 储存类型

sox\_uint64\_t tell\_off; 文件内当前偏移量

sox\_uint64\_t data\_start; 声音数据开始的偏移量

sox\_format\_handler\_t handler; 文件格式处理方式

void \* priv; 私有数据区域

#### sox\_effect\_handler\_t

struct sox\_effect\_handler\_t {

char const \* name;

char const \* usage;

unsigned int flags;

sox\_effect\_handler\_getopts getopts;

sox\_effect\_handler\_start start;

sox\_effect\_handler\_flow flow;

sox\_effect\_handler\_drain drain;

sox\_effect\_handler\_stop stop;

sox\_effect\_handler\_kill kill;

size\_t priv\_size;

};

重要变量说明：

char const \* name; Effect name

char const \* usage; effect参数接受效果

unsigned int flags; effect标志

sox\_effect\_handler\_getopts getopts; 调用命令解析参数

sox\_effect\_handler\_start start; 初始化效果器

sox\_effect\_handler\_flow flow; 调用处理结果

sox\_effect\_handler\_drain drain; 在输入完成后调用以完成输出

sox\_effect\_handler\_stop stop; 调用关闭effect

sox\_effect\_handler\_kill kill; 调用关闭effect

size\_t priv\_size; 预分配大小

#### sox\_effect\_t

struct sox\_effect\_t {

sox\_effects\_globals\_t \* global\_info;

sox\_signalinfo\_t in\_signal;

sox\_signalinfo\_t out\_signal;

sox\_encodinginfo\_t const \* in\_encoding;

sox\_encodinginfo\_t const \* out\_encoding;

sox\_effect\_handler\_t handler;

sox\_uint64\_t clips;

size\_t flows;

size\_t flow;

void \* priv;

sox\_sample\_t \* obuf;

size\_t obeg;

size\_t oend;

size\_t imin;

};

重要变量说明：

sox\_effects\_globals\_t \* global\_info; effect全局变量信息

sox\_signalinfo\_t in\_signal; 输入信号

sox\_signalinfo\_t out\_signal; 输出信号

sox\_encodinginfo\_t const \* in\_encoding; 输入数据编码信息

sox\_encodinginfo\_t const \* out\_encoding; 输出数据编码信息

sox\_effect\_handler\_t handler; effect句柄

sox\_uint64\_t clips; 递增

size\_t flows; MCHAN值

size\_t flow; flow数量

void \* priv; Effect的私有数据区域

sox\_sample\_t \* obuf; 输出buf

size\_t obeg; 输出缓冲区:有效数据段的开始

size\_t oend; 输出缓冲区:有效数据段的结束

size\_t imin; 最小输入缓冲区

sox\_error\_t一般用于返回错误码。

enum sox\_error\_t {

SOX\_SUCCESS = 0, /\*\*\< Function succeeded = 0 \*/

SOX\_EOF = -1, /\*\*\< End Of File or other error = -1 \*/

SOX\_EHDR = 2000, /\*\*\< Invalid Audio Header = 2000 \*/

SOX\_EFMT, /\*\*\< Unsupported data format = 2001 \*/

SOX\_ENOMEM, /\*\*\< Can't alloc memory = 2002 \*/

SOX\_EPERM, /\*\*\< Operation not permitted = 2003 \*/

SOX\_ENOTSUP, /\*\*\< Operation not supported = 2004 \*/

SOX\_EINVAL /\*\*\< Invalid argument = 2005 \*/

};

## 离线SOX开发测试环境说明

### 编译环境

#### 硬件环境

|     |      |      |
| --- | ---- | ---- |
| 分类  | 最低配置 | 推荐配置 |
| CPU | 4C   | 16   |
| 内存  | 8G   | 32G  |
| 磁盘  | 64G  | 128G |

#### 软件环境

|        |            |        |
| ------ | ---------- | ------ |
| 分类     | 名称         | 版本     |
| 操作系统   | Centos     | 7.x    |
| 数据库    | Redis      | 3.2.0  |
|        | Mysql      | 5.7.30 |
| 能力接口   | Tomcat     | 9.0.35 |
| GCC    | GCC        | 4.8.5  |
| G++    | G++        | 4.8.5  |
| GUN    | make       | 3.82   |
| sox源代码 | sox-14.4.2 | 14.4.2 |

#### 编译方式

编译安装

tar -xvf sox-14.4.2.tar.gz

cd sox-14.4.2

./configure --prefix=~/local/sox

Make -j && make install

配置环境变量

echo "export LD\_LIBRARY\_PATH=$sox\_dir/lib/:\\$LD\_LIBRARY\_PATH"\>\>~/.bash\_profile

echo "export LIBRARY\_PATH=$sox\_dir/lib/:\\$LIBRARY\_PATH"\>\>~/.bash\_profile

echo "export PATH=$sox\_dir/bin/:\\$PATH"\>\>~/.bash\_profile

echo "export C\_INCLUDE\_PATH=$sox\_dir/include/:\\$C\_INCLUDE\_PATH"\>\>~/.bash\_profile

echo "export CPLUS\_INCLUDE\_PATH=$sox\_dir/include/:\\$CPLUS\_INCLUDE\_PATH"\>\>~/.bash\_profile

echo "export PKG\_CONFIG\_PATH=$sox\_dir/lib/pkgconfig/:\\$PKG\_CONFIG\_PATH"\>\>~/.bash\_profile

echo "export LD\_LIBRARY\_PATH=$sox\_dir/lib/:\\$LD\_LIBRARY\_PATH"\>\>~/.bashrc

echo "export LIBRARY\_PATH=$sox\_dir/lib/:\\$LIBRARY\_PATH"\>\>~/.bashrc

echo "export PATH=$sox\_dir/bin/:\\$PATH"\>\>~/.bashrc

echo "export C\_INCLUDE\_PATH=$sox\_dir/include/:\\$C\_INCLUDE\_PATH"\>\>~/.bashrc

echo "export CPLUS\_INCLUDE\_PATH=$sox\_dir/include/:\\$CPLUS\_INCLUDE\_PATH"\>\>~/.bashrc

echo "export PKG\_CONFIG\_PATH=$sox\_dir/lib/pkgconfig/:\\$PKG\_CONFIG\_PATH"\>\>~/.bashrc

#### 输出结果

编译输出四个目录

bin 可执行文件sox

include 头文件

lib libsox.so动态库

### 测试环境部署

#### 系统安装

如上1.3方式已经编译好SOX,无需在安装部署；

#### 运行环境

|      |        |       |
| ---- | ------ | ----- |
| 分类   | 名称     | 版本    |
| 操作系统 | Centos | 7.x   |
| GCC  | GCC    | 4.8.5 |
| G++  | G++    | 4.8.5 |
| GUN  | make   | 3.82  |

### 系统测试

#### 测试工具

sox可执行文件

#### 测试脚本

无

#### 测试数据

in.wav单声道语音。

#### 测试方法

执行命令：ffmpeg -i in.wav -b 16 -r 8000 out.wav

#### 测试结果

查看生成out.wav是否为8k16bitpcm。

|                    |          |             |                 |                                                               |
| ------------------ | -------- | ----------- | --------------- | ------------------------------------------------------------- |
| 模块                 | 分类       | 源码          | 简单说明            |                                                               |
| 场景分割源码             | 离线       | 说话人聚类       | 说话人聚类           | 利用语音识别的分段结果，将不同说话人（坐席和用户）的语音和时间点进行提取                          |
|                    |          | 角色分类        | 角色分类源码+war包+文档  | 利用不同说话人的语音转写文本，利用角色分类模型确定其角色类型（坐席还是用户）                        |
| 端到端架构语音识别引擎(解码器)源码 | 离线       | 解码器内核       | 离线解码器内核         | 包含端到端声学模型推理计算和语音识别令牌传递，提供解码库实现输入语音特征，输出识别文本。                  |
|                    |          | 引擎封装TBNR    | 离线语音识别引擎-总模块    | 语音识别引擎工程前端封装包括：端点检测、特征提取、后处理匹配和多线程封装等子模块。完成离线语音数据进行转写功能。      |
|                    | 在线       | 解码器内核       | 在线解码器内核         | 包含端到端声学模型推理计算和语音识别令牌传递，提供解码库实现输入语音特征流，输出识别文本。                 |
|                    |          | 引擎封装TBNR    | 在线语音识别引擎-总模块    | 语音识别引擎工程前端封装包括：端点检测、特征提取、后处理匹配和多线程封装等子模块。完成输入实时输入语音进行实时转写的功能。 |
| 叠音检测源码             | 离线       | 叠音检测        | 叠音检测源码          | 自动检测出用户和坐席同时说话的语音段（叠音），并自动给出其起始点位置。                           |
|                    |          |             |                 |                                                               |
| 离线转写结果融合源码         | 离线转写结果融合 | 转写结果融合源码    | 转写结果融合源码        | 基于离线语音识别引擎的结果，增加静音、语速、能量的统计结果，将结果进行合并，输出xml格式结果。              |
|                    |          | xml格式文件转换工具 | XML格式文件转换Q1格式工具 | 将xml结果格式进行转换，得到Q1.xml格式的结果。                                   |
