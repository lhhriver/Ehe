# 第01章 PSTN与VoIP基础
# 第02章 PSTN、PBX及呼叫中心业务
# 第03章 初识FreeSWITCH
# 第04章 运行FreeSWITCH
# 第05章 FreeSWITCH架构
# 第06章 拨号计划
# 第07章 SIP协议
# 第08章 媒体
# 第09章 SIP模块
# 第10章 基本技能
# 第11章 基本功能与实现
# 第12章 高级功能与配置实例
# 第13章 FreeSWITCH与FreeSWITCH对接
# 第14章 FreeSWITCH与其他设备或系统对接
# 第15章 其他技巧与实例

在前面的章节中，我们讲过一些基本的和比较高级一些的实例，涵盖了大部分常用的功能。但是，FreeSWITCH功能非常多，还有一些常用的功能，如企业通信中常用的电话转接、代接等，我们还没来得及讲。另外，对于一些不常用的功能，以及生产环境中关心的压力测试、安全等话题，我们也将在本章简单介绍，以方便感兴趣的读者进一步研究。

## 转接和代接

来电转接和代接是企业PBX中的常用功能。来电转接分为盲转（Blind Transfer）和协商转（Attended Transfer）两种 [1]，代接实现起来也很简单。下面我们分别加以介绍。

### 盲转

顾名思义，盲转就是将来电直接转到某一分机。该业务一般用于电话已经接听的情况，举例来说，转接的步骤一般是这样：A呼叫B，B接听，A与B通话，A要求转C，B通过一个操作将来电转接到C，C开始振铃，B挂断，C接听，A与C通话。

FreeSWITCH默认的Dialplan实现了这种转接，方法是B在通话中按“*1”两个键，听到拨号音后，拨叫C的号码，B挂机，A与C通话。

这种转接魔术的根本原因在于下面这一行，在默认的Dialplan中的Local_Extensions中可以找到：

```xml
<action application="bind_meta_app" data="1 b s execute_extension::dx XML features"/>
```

首先，有电话打入后，如果是最终路由到一个内部分机，就会执行到这一行。至此，来话是a-leg，现在还没有b-leg。

bind_meta_app是一个App，它会在本次通话上绑定参数中指定的“1”这个按键，这个可以后续可由“\*1”两个键激活。注意，上述代码中，“1”后面的“b”表示这个功能要绑定到b-leg上，虽然b-leg现在还没有。但是到有了以后，b-leg可以按“\*1”激活该项功能，而不是a-leg。想想为什么 [2]？

接着说，“b”后面的“s”表示什么呢？它表示，如果b按键激活该功能后，要在哪条腿上执行这个动作。这里的s表示same，就是说，在哪条腿上接收到按键就在哪条腿上执行。

后面的“execute_extension”表示去Dialplan中找一个extension去执行一下，这里指到XML features（它是一个Context）中去找dx这个extension。在默认的配置中可以在features.xml文件中找到。

总之，这一行执行完毕后只是相当于设了这么一个“套”，指出后面该怎么执行，直到b-leg按“\*”才能激活该功能。接下来，Dialplan最终会执行到后面的bridge(user/B)，A与B桥接并开始通话。

通话后，b-leg就有了，它就是用户B所在的那条腿。在通话中，B按下“\*1”，就会执行到“dx”，我们到features.xml中去看具体的实现：

```xml
<extension name="dx">
  <condition field="destination_number" expression="^dx$">
    <action application="answer"/>
    <action application="read" data="11 11 'tone_stream://%(10000,0,350,440)' digits 5000 #"/>
    <action application="execute_extension" data="is_transfer XML features"/>
  </condition>
</extension>
```

这里的answer只是保证电话是应答的状态。后面的read表示等待用户按键，也就是等待用户输入一个分机号（如C的号码）。参数“11 11”是自动收号位数，表示最少接收11位，最大接收11位。如果在收号近程中用户按了“#”（最后一个参数）号，则会立即停止接收（而不管最小和最大收号位数）。tone_stream会产生一个拨号音，以提示B可以拨号了。B拨完号之后，拨号的数据就存到了digits这个通道变量中。电话流程继续往下执行，接着又是execute_extension，它的参数is_transfer是另一个extension，我们可以在同一个文件中继续往下找到，其内容如下：

```xml
<extension name="is_transfer">
  <condition field="destination_number" expression="^is_transfer$"/>
  <condition field="${digits}" expression="^(\d+)$">
    <action application="transfer" data="-bleg ${digits} XML default"/>
    <anti-action application="eval" data="cancel transfer"/>
  </condition>
</extension>
```

可以看到，到了“is_transfer”以后，通过正则表达式“^(\d+)$”判断收到的数字是不是合法的号码，如果是，则执行transfer App进行转移。

先说上述正则表达式不匹配的情况，即用户B输入的不是一个合法的分机号，那么Dialplan就会执行到“anti-action”一行，取消本次操作。最终结果就是——B在听了一会拨号音并瞎按了半天后继续与A通话。

再说B按对了C号码的情况。执行到transfer App后，该App的参数中有一个“-bleg”，它什么意思呢？实际上，它的意思并不是绝对的b-leg，而是一个相对的概念，即与当前那条腿桥接的另外一条腿。如果这么说还不明白，可以这样考虑：现在是B做了这么多操作，因而这些操作都是在原来的b-leg上执行的。而transfer这里是要把A转走，由于当前的是b-leg，再加上“-bleg”后就相当于“负负得正”，因而意思是把a-leg转走。转到哪儿呢？转到“digits”变量所代表的值，即刚才B输入的C的号码。

这时C开始振铃，如果C接听，A就可以与C通话了。同时，A被转走后，B就没事干了，电话自己就挂掉了。

当然，上面绕了这么一大圈才完成这个转接功能，看起来挺复杂的。实际上，聪明的读者也许已经注意到了，在“dx”那个extension中有这么一句注释：

```xml
<!-- In call Transfer for phones without a transfer button -->
```

它的意思是，该功能是给那些没有Transfer键的话机用的（也就是一般的模拟话机，由于没有Transfer按键，因此一般需要靠DTMF按键执行这些功能）。对于SIP话机而言，通常都会有一个Transfer键，一按就转了，很方便。那么这是怎么实现的呢？答案是SIP REFER。

REFER是在RFC3515 [3]中定义的，它规定了SIP中电话转接的几种实现方式，具体协议流程的实现跟具体话机终端有关，图15-1描述了一种典型的实现方式。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-177855-1703349274686-1411.png)

<center>图15-1　使用Refer进行呼叫转接</center>

首先A与B已建立通话，这时候B想把A转接给C。这里B称为Transferor，它是转接的发起者；而A称为Transferee，它是被转接的一方；C称为Target，是转接的目的地。转接成功后A与C通话。

B首先发re-INVITE请求给FS（FreeSWITCH），请求将B的电话置为Hold（保持）状态，FS收到请求后就给A播放保持音乐。同时，B的话机放拨号音，以提示用户输入被叫号码。B输入C的号码后，B给FS发REFER请求。FS收到后会释放B，并同时呼叫C。如果C正常接听，则A与C通话，转接完成。

### 协商转

读者读到这里可能会发现一个问题：在上述盲转的情况下，如果C长时间不接听（久叫不应）或C占线，则转接会失败，A的电话会被挂断。A可能会重新呼叫B要求转接，这对A的体验是很不好的。

FreeSWITCH通过att_xfer这App支持协商转。在默认的拨号计划中也是可以实现的，与盲转不同的是，在进行转移时，B按“*4”激活“att_xfer”功能，配置如下：

```xml
<action application="bind_meta_app" data="4 b s execute_extension::att_xfer XML features"/>
```

同样，我们在features.xml中找到“att_xfer”条件：

```xml
<condition field="destination_number" expression="^att_xfer$">
  <action application="read" data="3 4 'tone_stream://%(10000,0,350,440)' digits 30000 #"/>
  <action application="set" data="origination_cancel_key=#"/>
  <action application="att_xfer" data="user/${digits}@$${domain}"/>
</condition>
```

它照样使用read播放拨号音并等待3~4位按键，如果输入正确，则使用att_xfer这个App处理呼叫转移。att_xfer会呼叫C的号码，同时让A听等待音乐。如果呼叫C失败，则B仍然可以与A通话；如果C长时间不应答，则B可以按“#”（由origination_cancel_key设置）号键取消呼叫，继续与B通话；如果C接听后，B与C通话，此时B可以询问C是否愿意接听电话 [4]，如果C不愿意，则C挂机，B仍然可以跟A通话；如果C接受通话，则B挂机，A与C通话；如果B不挂机，并按3，则可以形成三方通话，大家一起说。还有更有意思的，B还可以随时按1与A通，按2与C通，而让A与C永远不通……

上述功能是在FreeSWITCH中通过DTMF按键实现的。某些话机支持多路通话，因而可以在话机端（通过Refer）实现协商转。典型的，话机终端B可以把第一路电话置于Hold状态，然后再发起另外一路通话到C，C接听后B可以任意切换与A和C之间的通话，并可以通过本地会议桥进行混音以支持三方通话（也叫会议）。

此时B如果想退出A与C的通话，则可以发送REFER消息，让服务器把通话中的B替换为C。该消息与盲转不同，它带了Replaces参数：

```
Refer-To: sip:1002@192.168.1.118?Replaces=1388923627@192.168.1.110;to-tag= NDj261X80jpKF;from-tag=1013380895>
```

为了阅读方便，上面的消息是经过“urldecode”后的，实际的消息内容是用“urlencode”编码的字符串。它是这样产生的：A（1000）呼叫B（1004），此处B是亿联话机，B接听后，按下话机上的Conf软键（代表Conference，会议）然后呼叫C（1002）。C接听后，B与C通话。B可以通过话机上的Swap按钮进行切换并与A或与C通话，也可以再次按Conf键启用本地混音实现A、B、C三方的电话会议。与我们上面讲的例子不同，上面的例子三方通话是由att_xfer实现的，参与方只有三方，即三个Channel；而本例中是4个Channel，因为B话机同时有两个Channel连接到FreeSWITCH。

如果B想退出会议，但保持A与C的通话，则B发送REFER消息让FreeSWITCH把它替换掉，即让FreeSWITCH把A与C桥接起来，释放掉与B的两路通话。

完整的REFER消息如下：

```
------------------------------------------------------------------------
recv 594 bytes from udp/[192.168.1.110]:5063 at 05:59:43.368543:
------------------------------------------------------------------------

REFER sip:mod_sofia@192.168.1.118:5060 SIP/2.0
Via: SIP/2.0/UDP 192.168.1.110:5063;branch=z9hG4bK1882546254
From: <sip:1004@192.168.1.110:5063>;tag=485693841
To: "Extension 1000" <sip:1000@192.168.1.118>;tag=H9cZZNttcFX8g
Call-ID: affaa293-566c-1231-e2ba-79a3b2b753b0
CSeq: 45647480 REFER
Contact: <sip:1004@192.168.1.110:5063>
Max-Forwards: 70
User-Agent: Yealink SIP-T22P 7.70.0.140
Refer-To: <sip:1002@192.168.1.118?Replaces=1388923627%40192.168.1.110%3Bto-tag%3DNDj261X80jpKF%3Bfrom-tag%3D1013380895>
Referred-By: <sip:1004@192.168.1.110:5063>
Event: refer
Content-Length: 0
```

有兴趣的读者可以自行跟踪SIP消息看一下，详细的流程（及流程图）就不赘述了。

### 代接

代接是指（别人给A打电话时）A电话振铃后，在B话机上进行接听（代替A来接听）。一般用于办公室中某工位上没人其他工位上的人代为接听的场景。

FreeSWITCH默认的Dialplan中就有与代接相关的例子。其中，886为全局代接。即当有分机振铃时，在另外的话机上直接按886就能接听，同时原先振铃的话机结束振铃。“*8”为组内代接，也就是同组代答，即在上述情况下按“*8”只能代接本组内的正在振铃的分机。以上两种方式在有多个分机同时振铃时只能接听最后振铃的那一个。此外，还有一个“\*\*”前缀码，拨打“\*\*”加上指定的分机号就能直接代接指定分机，如拨“\*\*1001”就可以接听正在振铃的1001分机上的电话。

代接是使用intercept App实现的，具体的Dialplan我们在此就不详细解释了，有兴趣的读者可以参考默认的Dialplan（dialplan/default.xml）中的相关内容（搜索intercept），结合我们本书中讲过的知识是很容易理解的。

[1] 也有人分别叫一步转、两步转，或直接转移、出席转移等。 

[2] 因为aleg可能是外部来话，你肯定不想外面的人乱按按键执行各种功能。 

[3] 参见www.ietf.org/rfc/rfc3515.txt。 

[4] B与C协商，这是也协商转的来源。

## 共享线路呈现

共享线路呈现（Shared Lines Appearence，SLA）也是企业应用中一个非常有用的功能。该功能在模拟话机中是没有的，只有SIP话机才能实现该功能。使用该功能可以在自己的话机上监视其他话机的状态，从而知道另一个电话是否处于忙或闲的状态。比如说在老板-秘书的场景中，如果有人打秘书的电话想找老板，而秘书转电话时碰巧老板的电话正在占线，就会导致转接不成功，耽误时间。而如果秘书事先知道老板的电话是否在忙，就可以直接判断是否要将电话转给老板，或者告诉主叫用户先等一会。FreeSWITCH就支持这种功能。在使用时应确认Profile中的设置开启了以下两项：

```xml
<param name="manage-presence" value="true"/>
<param name="manage-shared-appearance" value="true"/>
```

下面以Seven Du（607）和Sonic Gao（608）为例。607使用XLite注册。注册完毕后通过菜单项“Contacts”→“Add Contact”添加一个联系人608，并确保开启了Presence功能，如图15-2所示。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-192856.png)

<center>图15-2　在XLite中添加Presence联系人</center>

添加完成后，主界面上就能显示联系人的状态了，如图15-3a所示，现在608处于注册状态，显示是绿色的Available状态（见图15-3a）。如果608正在通话，则会变为红色的Talk状态，图15-3b显示608（Sonic Gao）正在跟9196通话。

账号608是从一个亿联话机上注册的，该话机也支持线路共享功能。打开话机的Web设置界面，依次顺着菜单走到“话机设置”→“可编程按键”→“账号键”，如图15-4所示。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-207855.png)

<center>图15-3　XLite上的联系人状态</center>

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-221855.png)

<center>图15-4　在亿联话机上配置SLA</center>

在图15-4中所示的页面上，选择账号键“1”，把类型由“线路”改为SLA，“值”里输入你想监视的话机账号，这里是“sip:607@192.168.1.9”，在注册“线路”一栏也选择账号1，保存设置后，话机上账号1对应的灯就会常亮，表示607是正常空闲的。如果607正在通话，该灯就会闪烁。如果15-5所示，话机上第一个灯是常亮或闪烁。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-237855.png)

<center>图15-5　话机灯的状态</center>

## 使用组播功能做网络广播

在某些特殊的场景下，拿起电话拨打一个号码，就可以对一大群人喊话，广播功能可以大大提高工作效率。

广播功能可以使用会议实现，简单地发起N路通话加入一个会议也可以做到广播的效果。不过，那样实现要建立N路通话，需要消耗很多的网络资源；另外，也无法保证对方能及时接听，影响信息的送达。实现该业务模式最经济的方式就是使用组播（Multicast，或称多播）。组播只向组播地址发送一个RTP流，而监听该组播地址的所有主机就都能收到。

FreeSWITCH有一个mod_esf（Extra SIP Functionality）模块，它提供一个esf_page_group的App可以支持组播。

esf_page_group有三个参数，分别是：

- 组播地址，默认为224.168.168.168。
- 端口号，默认为35467。
- 控制端口号，默认为6001。

要能收到组播包并播放声音，也需要配置亿联话机以启用这项功能 [1]，配置界面如图15-6所示。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-251853.png)

<center>图15-6　配置亿联话机接受组播包</center>

该配置项比较难找，依次找到菜单“电话簿”→“组播”，在第一个IP地址框里填入224.168.168.168:34567，标签栏可以任意填，起一个好记的名字就行。

在FreeSWITCH默认的配置中，拨打号码7243就直接向该地址发送组播，所以现在你可以拿电话拨打7243试一下了。

默认的Dialplan配置如下：

```xml
<extension name="rtp_multicast_page">
  <condition field="destination_number" expression="^pagegroup$|^7243$">
    <action application="answer"/>
    <action application="esf_page_group"/>
  </condition>
</extension>
```

如果你想发到其他的地址，可以配置相关参数，如下列配置可以将RTP包发到组播地址224.0.0.100：

```xml
<action application="esf_page_group" data="esf_page_group 224.0.0.100 34567 6001"/>
```

与普通的IP地址不同，组播需要配置组播地址。众所周知，在IPv4中，组播地址的范围是从224.0.0.0到239.255.255.255，由于实际用到组播的业务却很少，因而好多人可能不是很熟悉。在有的系统上需要配置组播路由，如以下命令可以在Linux系统的eth0上配置组播路由：

```
ip route add 224.0.0.0/4 dev eth0 src 192.168.5.2
```

使用上述命令还需要iproute2软件包支持。另外，在实际应用中为避免组播风暴及潜在的冲突，可能需要把具有组播功能的话机都划分到一个VLAN上。再者，组播包一般不能穿越路由器，如果要跨路由器组播的话，需要支持组播的路由器，并进行适当的配置，这些都超出了本书的范围，有兴趣的读者可以自行参考相关资料。

[1] 笔者不知道其他话机是否具有这样的功能，最初亿联也没有，是笔者帮助FreeSWITCH的作者Anthony Minessale联系到亿联的工程师后他们才实现的。

## DTMF

DTMF（Double Tone Multiple Frequecy，双音多频）是一种通话过程中的号码传输方式，特别是在IVR类的应用中，一般的电话菜单都是通过按键控制的。在传统的TDM电话网络中，如果通话中的用户按下了话机上的一个键，话机就会产生一个DTMF的音频信号送到远端的交换机上，交换机会将该信号送到对端的用户那里，如果对端也是一个用户，则他就能听到一些“嘀嘀”的按键音；如果对端是一个IVR，它就能检测这种信号，并还原成用户按键的数字，进而知道用户选择了哪个菜单。

在SIP通话中，传输按键信息的方式相对较多。虽然有些信息可以完全不用双音多频的信号来表示，但沿用传统的叫法，我们仍然把按键信息称为DTMF。

### 带内DTMF

在基于SIP/RTP的通话中，如果跟传统的TDM电话对接，直接把TDM电话设备产生的双音频信号按与音频编码同样的方式进行编码并放到RTP数据中传输，则这种DTMF称为带内DTMF（Inband）。FreeSWITCH默认不使用带内DTMF。因为，检测带内DTMF必须要实时检测RTP包中的内容，会多耗费很多CPU。不过，传统的TDM设备只支持这种方式，因而如果要跟传统的PSTN网络的交换机进行SIP对接，则往往默认会使用这种方式。由于PSTN网络上的交换机一般不会使用到DTMF，它们只需要对DTMF信号进行简单的透传，而不需要进行深入检测，因而对它们来说无所谓是否耗费资源。

如果在FreeSWITCH中使用带内DTMF，则需要在对应的Profile中（如“internal”或“external”）中设置如下参数：

```xml
<param name="dtmf-type" value="inband"/>
```

或者在通话时，在Dialplan中通过设置如下的通道变量实现：

```xml
<action application="set" data="dtmf_type=inband"/>
```

当然，设置了上述变量并不能使FreeSWITCH检测到带内的DTMF，还必须在Dialplan中明确使用start_dtmf这个App打开DTMF检测。比如，对于来话而言，就需可以使用如下的Dialplan：

```xml
<action application="set" data="dtmf_type=inband"/>
<action application="start_dtmf"/>
<action application="ivr" data="some_ivr"/>
```

对于去话，则可以通过设置一个钩子通道变量 [1]“execute_on_answer”实现，如：

```xml
<action application="export" data="nolocal:execute_on_answer=start_dtmf"/>
<action application="bridge"data="sofia/gateway/pstn/${destination_number}"/>
```

在上述Dialplan中，我们使用“export”设置了一个变量“execute_on_answer”，该变量是以“nolocal:”开头的，因此，它将只在b-leg上生效。在执行到“bridge”时，将产生b-leg。本例中的b-leg通过一个pstn网关呼叫被叫号码，当对端接听后，FreeSWITCH就会执行execute_on_answer钩子变量所指定的App，即start_dtmf，它用于开启带内DTMF检测。

当然，如果对export”这个App以及其原理比较熟悉的话（参见6.1.9节），便知道上述Dialplan跟如下的写法是等价的：

```xml
<action application="bridge"
data="{execute_on_answer=start_dtmf}sofia/gateway/pstn/${destination_number}"/>
```

### RFC2833

RFC2833 [2]中定义了在RTP中传输DTMF信息的另一种方式。该方式通过特殊的RTP Payload进行标志，标志出包含DTMF信息的RTP包，因而不需要对所有的RTP包进行深度的频率检测就可以很容易认出包含DTMF信息的包，而这种包里的DTMF信息是以文本表示的，因而也不需要计算。与Inband检测相比，RFC2833方式大大节省了CPU。这种方式是现行的VoIP通话中比较常用的方式，也是FreeSWITCH中默认的方式。

RTP包中DTMF的Payload Type值是在SDP消息中使用“telephone-event”协商的，如下面的SDP消息中，表示Payload Type为101的RTP包为包含DTMF消息的包。

```
v=0
o=FreeSWITCH 1371848118 1371848119 IN IP4 192.168.1.9
s=FreeSWITCH
c=IN IP4 192.168.1.9
t=0 0
m=audio 31988 RTP/AVP 8 101
a=rtpmap:8 PCMA/8000
a=rtpmap:101 telephone-event/8000
a=fmtp:101 0-16
a=silenceSupp:off - - - -
a=ptime:20
m=video 19008 RTP/AVP 123
a=rtpmap:123 H264/90000
```

如果在媒体协商时看不到“telephone-event”，则证明它不支持DTMF2833模式。 

`注意`：

由于RTP底层使用了不可靠的UDP传输协议，因此RFC2833规定包含同一DTMF信息的包要按一定的规则重发，以减少可能的丢包带来的影响。而且，DTMF的RTP包跟音频RTP包是在一个媒体流（相同的“IP地址:端口号”）中传输的，因此包含DTMF的RTP包中的时间戳以及Marker标志还需要跟普通音频正确配合才能使用。这就带来了该协议的一些复杂性。比较令人遗憾的是，有很多设备的DTMF2833实现都有Bug，而且几年甚至十几年都不改。为了能够跟这些“顽固”的设备对接，FreeSWITCH内部也进行了相应的妥协，针对某些设备提供了一些专门的配置参数。当然，如何使用这些具体的参数超出了本书的范围，如果在与这样的设备对接时发现不符合RFC2833规定的实现，可以查阅有关资料尝试在FreeSWITCH中设置相关参数进行解决 [3]。

### SIP INFO

DTMF也可以在SIP的INFO消息中传送。INFO消息跟一路通话有关，用于通话中的双方传送一些消息，其中一种消息就是传输DTMF消息。

使用SIP INFO消息甚至比使用RFC2833更有效，但是，有一个缺点是由于SIP消息跟用于传送声音的RTP流使用不同的UDP IP地址和端口，在实际传输中可以经过完全不同的路由设备，因而用SIP INFO传送的DTMF可能会与实际听到的声音不同步。

如果在SDP协商时没有找到“telephone-event”（即不能使用RFC2833），则FreeSWITCH就会默认启用INFO来收发DTMF。当然，也可以在Profile中使用如下参数明确指定使用INFO来传送DTMF：

```xml
<param name="dtmf-type" value="info"/>
```

或者在Dialplan中针对某一路通话决定是否使用INFO：

```xml
<action application="set" data="dtmf_type=info"/>
```

关于DTMF的知识我们就介绍这么多，请读者根据自己的需要多加练习。

[1] FreeSWITCH中有一系列的以execute_on_开头的通道变量，这些变量在系统中设置一些钩子，当Channel执行到一定状态时，便会执行这些钩子指定的App，比如此处的execute_on_answer就会在相关的Channel被应答时执行指定的App。 

[2] 参见http://tools.ietf.org/html/rfc6455。 

[3] 参见http://wiki.freeswitch.org/wiki/RTP_Issues。

## 号码连选

虽然有些运营商也开始尝试开放SIP号码，但大部分还是谨慎的、试探性的。因此一般不提供SIP对开中继的方式，而是开放单个的接入号码。虽然这不是理想的方式，但有总比没有好。在此，假设我们从运营商那里获得10个SIP账号，号码范围是xxxxxx30～xxxxxx39。我们来看一下如何有效地使用这些号码。

### 注册到运营商服务器

我们可以在FreeSWITCH中添加一些网关，以便注册到运营商的SIP服务器上去（应该是一个SBC）。

网关的配置文件如下，为了使用方便，我们让网关名称（name）的后两位与号码的最后两位相同：

```xml
<gateway name="gw30">
    <param name="realm" value="218.56.x.x"/>
    <param name="username" value="xxxxxx30"/>
    <param name="password" value="xxxx"/>
    <param name="register" value="true"/>
</gateway>
<gateway name="yt31">
    <param name="realm" value="218.56.x.x"/>
    <param name="username" value="xxxxxx31"/>
    <param name="password" value="xxxx"/>
    <param name="register" value="true"/>
</gateway>
......
```

上面我们仅列出了两个网关账号的配置，其他账号依此类推。

### 通过单个号码呼出

15.5.1节配置的网关注册成功后，我们就可以通过这个号码（又称为线路）打入打出电话了。我们可以使用如下命令快速试一下是否能通过某一条线路（如gw30）成功呼出：

```
freeswitch> originate sofia/gateway/gw30/1860535xxxx &echo
```

测试成功后，就可以设置如下的Dialplan让所有分机都可以通过该网关呼出了：

```xml
<extension name="Outbound Call">
  <condition field="destination_number" expression="^(1[358].*)$">
    <action application="bridge" data="sofia/gateway/gw30/$1"/>
  </condition>
</extension>
```
`注意`

出于简单起见，本例中使用的正则表达式仅匹配手机号。上述配置将统一使用网关gw3 （即通过号码xxxxxx3 ）呼出。很容易想到，如果有第二个人同时进行呼叫时，由于该网关对应的号码占线，会导致呼叫失败。

### 使用随机数做号码连选

为了能自动选择一个网关呼出，我们想办法从这10个网关中自动选择一个进行呼出。这种选择的过程就称为选线，也称为号码连选。当然，号码连选最简单的实现方法是使用一个随机数。见下面的Dialplan：

```xml
<action application="set" data="gw=gw${expr(randomize(&x);ceil(random(30,39,&x)))"/>
<action application="bridge" data="sofia/gateway/${gw}/$1"/>
```

其中，“expr”是一个API，我们用它的randomize方法产生一个从30到39之间的随机数（如33），在该随机数前面加上“gw”字符（变为gw33），并把它赋值给一个“gw”通道变量（使用“set”）实现。有了该通道变量后，在“bridge”的参数中就可以使用“${gw}”引用该变量（在本例中它的值就是gw33），实现动态选择一个随机的网关。

当然，这种选线算法有一个缺点，就是它不记录实际号码的忙闲状态，如果选到正在通话的号码时，通话还是会失败。通过下面的方式，我们可以做一个改进的算法：

```xml
<action application="set"    data="gw1=gw${expr(randomize(&x);ceil(random(30,39,&x)))"/>
<action application="set"    data="gw2=gw${expr(randomize(&x);ceil(random(30,39,&x)))"/>
<action application="bridge"    data="sofia/gateway/${gw1}/$1|sofia/gateway/${gw2}/$1"/>
```

该方法的思路是，同时选择两个网关（gw1和gw2），如果一个失败，则走另一个（该方法不能从根本上解决选到正在通话的线路问题，但可以大大减少失败的概率）。

### 使用mod_distributor进行连选

除随机数外，FreeSWITCH也提供了一个mod_distributor模块模块，专门实现这种连选功能。首先，要安装该模块，进入FreeSWITCH的源代码目录，执行如下命令：

```
make mod_distributor-install
```

然后，在conf/autoload_configs/distributor.conf.xml中进行如下设置：

```xml
<list name="dist1" total-weight="10">
<node name="30" weight="1"/>
<node name="31" weight="1"/>
<node name="32" weight="1"/>
<node name="33" weight="1"/>
<node name="34" weight="1"/>
<node name="35" weight="1"/>
<node name="36" weight="1"/>
<node name="37" weight="1"/>
<node name="38" weight="1"/>
<node name="39" weight="1"/>
</list>
```

其中，我们配置了一个列表（list），它的名字是“dist1”，总体的权重（total-weight）是“10”。该列表有好多节点（node）组成，其中每个节点的权重（weight）为“1” [1]。可以看出，这些节点的名字跟我们线路号码的最后两位相同。

FreeSWITCH加载该模块后，我们就可以先用如下的命令进行一下测试：

```
freeswitch> distributor dist1
32
freeswitch> distributor dist1
35
```

distributor是该模块提供的一个API命令，它可以用于从预定义的列表中根据权重选择一个节点，并返回该节点的名称。然后，我们就可以在Dialplan中使用它来帮助我们选线了：

```xml
<extension name="gw">
  <condition field="destination_number" expression="^(01[358].*)$">
    <action application="bridge"data="sofia/gateway/gw${distributor(dist1)}/$1" loop="2"/>
  </condition>
</extension>
```

其中，我们使用${distributor(dist1)}让mod_distributor帮我们选择一个节点，并使用它作为网关的名字向外呼出。当然，与上一节使用的随机数的方案相比，它也聪明不了许多，因为，该模块也没有记录线路是空闲还是忙的。因此，我们使用了Dialplan Action中的loop属性，如果第一次呼叫失败，它将再试一次（重新执行该Action）。

当然，与上一节的随机数方案比起来，它还是聪明一点的。例如，虽然我们配置了10个网关，但并不一定所有时间所有的网关都能正常注册上。通过如下方法，就可以让distributor在生成选择节点时，排除掉处于down状态（即不可用状态）的网关：

```xml
<action application="bridge"
data="sofia/gateway/gw${distributor(dist1 ${sofia(profile internal gwlist down)})}/$1"/>
```

### 其他

上述的几种方案在一般话务量不是很高的情况下，问题应该不大。不过在很繁忙的场合（如线路占用率90%以上），可能就会出现较高的呼损（即呼叫失败，我们这里更多的是指在还有空闲线路的情况下的呼叫失败）。因此，为了提高线路的利用率，降低呼损，我们需要更好的算法。

当然，没有现成的方案来解决该问题，这里我们仅探讨一下实现的思路。首先，实现该算法的时候，应该能检测并记住线路的状态，避免选到坏线（如网关注册失败的线路）或忙线；其次，应该有冲突解决方案，即能够解决同抢的情况（如刚刚选择了一个空间闲的线路，但在呼出前的瞬间忽然来了一通呼入的电话）。

当然，实现这种算法比较复杂，而且如果实现不好，也不一定能减少呼损。所以有时候，多开一些网关线路，利用减少线路利用率来换取更低的呼损，选择一个折中的值还是可以接受的。

另外，在这些网关线路也会有大量呼入的情况下，呼损率肯定会更高。这时候，可以采取将呼入和呼出分开的方法，即一部分线路只允许呼入，另一部分仅用于呼出（最好能在运营商的交换机上做限制，让该号码永远呼叫不进来）。具体两部分的比例应该根据实际情况设置，当然使用这种办法也会更进一步降低线路利用率。

[1] 如果某条线路支持多线呼出，我们也可以增加它的权重。

## 收发传真

无论社会如何发展，老技术永远有它特殊的生命力，生生不息。传真技术也是如此。在互联网技术飞速发展的今天，电子邮件、即时通信以及基于移动互联网的各种应用，如微博、微信等，铺天盖地地发展，但我们在企业应用中，还是离不开传真机。当然，现代的传真机大多数都集打印、扫描等功能于一体了，但还是使用TDM通信的方式收发传真。

为了将这些老旧的技术及设备融入SIP世界里，很多人也进行了各种努力，因而我们也可以非常方便地使用它。连接TDM传真机最简单的方式是使用一个模拟转SIP的网关，将它变成SIP后在FreeSWITCH中收发传真就变得容易了。如我们可以使用如下命令，呼叫一个号码，并开始收传真。

```
freeswitch> originate sofia/gateway/gw1/xxxx &rxfax(/tmp/test.tiff)
```

传真功能是在mod_spandsp [1]中实现的。它实现了一个rxfax的App用于收传真。普通的传真机是这样工作的，A呼叫B，首先建立正常的通话，电话打通以后A告诉B它想发一个传真，因此B会按下一个按钮将传真机切换到传真模式，这时A这一端将听到“吱吱”的传真音，然后A端按下传真机上的“发送键”（或传真开始键）发送传真。

有SIP参与的传真过程也是类似的。它们首先先建立正常的SIP连接，然后如果一方想发传真或收传真，则它的终端就会给另一方发送SIP“re-INVITE”消息，与对方协商将RTP媒体流切换到T.38（或T.30）传真图像模式，协商完成后开始发送传真。

上面我们讲到的“rxfax”是收传真的App，它会将接收到的传真存到本地的一个TIFF [2]格式的文件中。

发送传真与与此类似，只是需要预先将欲发送的内容转成TIFF格式的文件。如下命令可以呼叫一个号码并发送传真：

```
freeswitch> originate sofia/gateway/gw1/xxxx &txfax(/tmp/test.tiff)
```

可以使用Gostscript或Imagemagick图像处理工具将欲发送的传真内容从原来的格式（如PDF）转换成TIFF格式。如，下列gs（即Gostscript）命令可以将fax.pdf转换成fax.tiff：

```
gs -q -r204x98 -g1728x1078 -dNOPAUSE -dBATCH -dSAFER -sDEVICE=tiffg3 -sOutputFile=fax.tiff -- fax.pdf
```

注意，其中“204x98”表示分辨率。传真文件的分辨率就是比较奇怪——横向和纵向的分辨率是不同的。另外，传真页面也需要有特定的大小，大部分传真机都能接收页面大小为“1728x1078”的传真，其他尺寸的因传真机而异。

上面我们只讨论了收发两端均是SIP的情况。如果在FreeSWITCH内部也使用如ftdm这样的Endpoint（配合模拟或数字板卡），那么FreeSWITCH也可以通过t38gateway这个App进行传真媒体的转换 [3]。

最后，我们再来看一下默认的Dialplan的配置。配置的Dialplan配置了两个Extension，“9178”用于收传真，“9179”用于发传真。具体内容如下：

```xml
<extension name="fax_receive">
  <condition field="destination_number" expression="^9178$">
    <action application="answer" />
    <action application="playback" data="silence_stream://2000"/>
    <action application="rxfax" data="/tmp/rxfax.tif"/>
    <action application="hangup"/>
  </condition>
</extension>
<extension name="fax_transmit">
  <condition field="destination_number" expression="^9179$">
    <action application="txfax" data="/tmp/txfax.tif"/>
    <action application="hangup"/>
  </condition>
</extension>
```

读者可以自行拨打测试一下。Dialplan的内容很简单，我们就不详细解释了。

[1] 基于Spandsp库，当然除了传真之外它还实现了一些语音编解码。参考http://wiki.freeswitch.org/wiki/Mod_spandsp。 

[2] 传真常用的格式，与常见的JPEG或PNG格式不同，但类似于PDF，它主要的特点是支持多页，而这一点在传真文件中非常重要。 

[3] 详情参考http://wiki.freeswitch.org/wiki/Mod_spandsp。

## 多租户

很多人将FreeSWITCH用于云计算平台，而VoIP云计算除了要支持大规模的并发呼叫外，更重要的是要支持多租户 [1]技术。简单来讲，多租户就是在一个系统中（或更简单点，一台FreeSWITCH服务器上），支持多个彼此相互独立的PBX（如属于不同公司的）应用，这些不同的PBX中可能有相同的分机号，而不会产生冲突。

FreeSWITCH在设计之初就考虑到了这一点，它是用Domain实现的。

### Domain简介

说起Domain，大家一般都会联想到域名，或者更精确一点说，联想到一个FQDN [2]。但FreeSWITCH中的Domain是指一个域，或者在这里我们说到多租户的时候，可以说它指一个租户。实际上，它就是唯一标志一个域的字符串。当然，由于它可以是任意的字符串，那么用实际的域名和IP地址也是没有问题的。但是，要记住，虽然你可以使用域名或实际的IP地址作为Domain，但并不表示Domain跟域名或IP地址以及DNS有任何关系，FreeSWITCH也永远不会把Domain通过DNS解析成域名，反之亦然。

讲到这里，读者可能听得一头雾水，那么为什么把问题搞这么复杂呢？答案很简单，为了支持多租户。

我们首先来看一下conf/vars.xml中如下的配置：

```xml
<X-PRE-PROCESS cmd="set" data="domain=$${local_ip_v4}"/>
<X-PRE-PROCESS cmd="set" data="domain_name=$${domain}"/>
```

其中，上述配置配置了两个全局变量domain和domain_name，前者用作一个核心变量——当系统需要一个Domain值，而通过当前的环境又找不到这么一个值时，就用该变量的值顶替；而后者用作一个Dialplan中的变量，它只是跟每一通电话相关的。当然默认两者的值都等于local_ip_v4的值。而local_ip_v4是一个动态计算出的变量值，它一般是当前能上网的网卡的IP地址（在取不到的情况下可能为127.0.0.1）。通过将local_ip_v4的值设成两个变量的默认值是因为这样的话在默认安装后不需要任何配置就可以在所有环境中都正常使用。

为了说明Domain跟实际的FQDN域名没有任何关系，我们来做如下实验。首先，如图15-7所示，在Domain中填入“dujinfang.com”。注册时选择“Send outbound via Proxy”，并在Proxy中输入FreeSWITCH的IP地址。在本例中，笔者试验的客户端和服务器的IP地址都是192.168.7.5。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-266854.png)

<center>图15-7　通过Proxy注册</center>

经过这样配置后，我们在FreeSWITCH中开启SIP trace可以看到如下的注册消息（为了方便讲解我们加了行号）：

```
01 --------------------------------------------------------------
02 recv 789 bytes from udp/[192.168.7.5]:28812 at 15:36:21.277729:
03 --------------------------------------------------------------
04 REGISTER sip:dujinfang.com SIP/2.0
05 Via: SIP/2.0/UDP 192.168.7.5:28812;branch=z9hG4bK-d8754z-...
06 Max-Forwards: 70
07 Contact: <sip:1007@192.168.7.5:28812;rinstance=af02322f2d5c82ba>
08 To: "1007"<sip:1007@dujinfang.com>
09 From: "1007"<sip:1007@dujinfang.com>;tag=a3e90a4e
10 Call-ID: ZTBhNGVkMTJlOGQzMDZlNjJjN2E2MjQ5NGEzZTZmM2U
11 CSeq: 2 REGISTER
12 Expires: 3600
13 Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO
14 User-Agent: Bria 3 release 3.5.0b stamp 69410
15 Authorization: Digest username="1007",realm="dujinfang.com",
    nonce="40dbf2e3-e5f6-4ee3-badf-855253b12c02",uri="sip:dujinfang.com",
    response="14337381cc0302574b6c39948fbea98f",
    cnonce="0c61ee029710dbf6b740dce279c651fa",
    nc=00000001,qop=auth,algorithm=MD5
16 Content-Length: 0
```

该消息不是第1个注册消息，而是在收到401响应后，计算出带有Authorization头的第2个注册消息。其中，我们可以看到，该消息确定发送到了我们在客户端上设置的SIP Proxy的IP地址上，而与我们以前经常使用的Domain中的“dujinfang.com”没有任何关系。在这时，“dujinfang.com”是一个合法的域名，但它没有在DNS中解析到192.168.7.5这个IP地址上。由此你可以看到，在此处的客户端上的Domain中，你在练习的时候可以填入任意值，当然填写不属于你自己的域名（如“apple.com”或“microsoft.com”，以及本例子中属于笔者的域名等）是非常不明智的。

第4行称为Request Line，可以看到“dujinfang.com”也出现在这里，同理，它也出现在第8行、第9行以及第15行等。

关于Domain我们就先介绍到这里，事实上，如果读者没有亲身的实践，在这里笔者是很难讲清楚的。就连FreeSWITCH的作者Anthony Minessale也花了一小时在邮件列表中讲这个问题，当然，他讲得是非常有参考意义的。参见http://lists.freeswitch.org/pipermail/freeswitch-users/2013-August/099131.html。下面我们通过实际的例子来看一下如何通过Domain设置多租户，希望读者最终能够理解这里的意思。

### 配置与实例

上面讲到的注册是可以成功的，而且我们在SIP消息中看到到处都是我们设置的Domain（dujinfang.com）。但是是否注册成功了就说明这支持多租户了呢？答案是否定的。我们还需要做一些工作。首先，我们用以下Dialplan测试一下，看domain及domain_name两个变量能告诉我们什么。

```xml
<extension name="Domain">
<condition field="destination_number" expression="^1234$">
  <action application="log" data="INFO domain=${domain}"/>
  <action application="log" data="INFO domain_name=${domain_name}"/>
</condition>
</extension>
```

通过上述Dialplan的设置，在拨打1234后，我们在日志中可以看到如下输出：

```
[INFO] mod_dialplan_xml.c:558 Processing 1007 <1007>->1234 in context default
[INFO] mod_dptools.c:1595 domain=192.168.7.5
[INFO] mod_dptools.c:1595 domain_name=192.168.7.5
```

可以看出，由于domain是一个核心的变量，它继续保持192.168.7.5这个IP地址值倒也罢了，但domain_name也不变，我们根据什么来做多租户的路由呢？即我们根据凭什么说这是某某域里的1007发起的呼叫而不是另一个域中的1007发起的呢？

其实，这是由于FreeSWITCH默认安装要在所有环境下都有运行的根本宗旨决定的，要达到我们的要求，需要检查Profile（internal）中的如下参数：

```xml
<param name="force-register-domain" value="$${domain}"/>
<param name="force-subscription-domain" value="$${domain}"/>
<param name="force-register-db-domain" value="$${domain}"/>
```

可以看出，在默认的配置中，上述参数都是生效的，也就是说，不管你的Domain怎么配置，都让它强制（force）成了默认的Domain。因此，在此我们需要删除这些参数（或者在配置文件中注释掉这些行）。然后，重启该Profile，再次注册时就会看到如下的警告，而且，我们的SIP客户端再也注册不上了。

```
[WARNING] sofia_reg.c:2679 Can't find user [1007@dujinfang.com] from 192.168.7.5
You must define a domain called 'dujinfang.com' in your directory
and add a user with the id="1007" attribute
and you must configure your device to use the proper domain
in it's authentication credentials.
```

虽然是个警告，但是个好的警告，它至少告诉我们它在配置文件中找不到这个Domain和这个用户了。我们看一看默认的用户目录配置文件conf/directory/default.xml，它里面定义了一个Domain，是默认的“$${domain}”值，具体如下：

```xml
<include>
<!--the domain or ip (the right hand side of the @ in the addr-->
<domain name="$${domain}">
<params>
    ......
```
找到它后，我们只需要照着它复制一份新的就好了（这里当然也可以把“$${domain}”改成我们想要的“dujinfang.com”，但我们除此之外还要加别的Domain，因而到后面总是要复制的）。

将上述文件复制到conf/directory/dujinfang.com.xml，然后修改其中的domain_name为如下的值：

```
<domain name="dujinfang.com">
```

在FreeSWITCH控制台中执行reloadxml使之生效，然后，重新注册客户端，就发现能注册成功了。通过如下的命令也能列出注册信息：

```
freeswitch> sofia_contact 1007@dujinfang.com
sofia/internal/sip:1007@192.168.7.5:34088;rinstance=d3ba18cdf1903f17
freeswitch> sofia status profile internal reg 1007

Registrations:
==============================================================================

Call-ID:        ZWRhZjA3NjI0NjYxODA1MDdkOGI0YzYxZWVkNGRmZjA
User:           1007@dujinfang.com
Contact:        "1007" <sip:1007@192.168.7.5:34088;rinstance=d3ba18cdf1903f17>
Agent:          Bria 3 release 3.5.0b stamp 69410
Status:         Registered(UDP)(unknown) EXP(2013-10-20 00:56:40) EXPSECS(94)
Host:           seven.local
IP:             192.168.7.5
Port:           34088
Auth-User:      1007
Auth-Realm:     dujinfang.com
MWI-Account:    1007@dujinfang.com
```

接着，拨打1234进行测试，就可以看到如下的输出了：

```
[INFO] mod_dialplan_xml.c:558 Processing 1007 <1007>->1234 in context default
[INFO] mod_dptools.c:1595 domain=192.168.7.5
[INFO] mod_dptools.c:1595 domain_name=dujinfang.com
```

从中可以看出，这里的domain_name变量也变成我们期望的值了。

### 进阶

当然，我们新建的dujinfang.com.xml与原来的default.xml都装入了conf/directory/default目录下的用户配置文件。既然是不同的租户，我们就需要把它们分开，因此我们也把整个default目录复制一份，放到到新的dujinfang.com目录中，并且将dujinfang.com.xml中的“include”一行改为：

```xml
<users>
  <X-PRE-PROCESS cmd="include" data="dujinfang.com/*.xml"/>
</users>
```

还没有完，我们要让自己域中的用户使用单独的Dialplan进行路由，因此进入dujinfang.com目录，将里面所有的用户配置文件（如1007.xml）中的user_context参数全部改成如下的值：

```xml
<variable name="user_context" value="dujinfang.com"/>
```

执行reloadxml命令后再拨打1234发现打不通了，原因很显然，我们还没有在Dialplan中设置dujinfang.com这个Context。当然，设置它也很简单。进入conf/dialplan/目录，将default.xml复制为dujinfang.com.xml，并将里面的Context的名称修改为我们需要的值，如：

```xml
<include>
<context name="dujinfang.com">
```

再一次执行reloadxml命令并拨打测试，就可以看到，我们这里的路由也跟默认的配置完全分离了。这就基本上达到了我们想要的效果。读者接下来可以参照这里的步骤再配置几个新的域以对比测试。

### 其他

使用多Domain（及多Directory、多Dialplan）支持多租户以后，有以下几个事情是需要注意的：

- Dialplan中的呼叫字符串不能再使用类似“user/1000”这样的缩写形式了，而要写成如“user/1000@\${domain_name}”的形式。
- 在使用会议、fifo等类的应用时，注意不要像本书中的例子一样图省事 [3]把会议的名称写成“3000”或把fifo的名称写成“book”，一定要写成如“3000-${domain_name}”或“book@${domain_name}”之类带Domain的长名字。
- 在实际应用中Domain可以与实际的FQDN相同，最好能使用DNS的SRV记录进行解析。不同的机构可以使用不同的域，如dujinfang.com、microsoft.com等；同一个机构不同的分支机构间也可以使用不同的域，如beijing.dujinfang.com、shanghai.dujinfang.com等。
- 如果需要计费，话单等也是需要特别注意的。
- 除此之外，还可以进一步细分，将不同的租户分到不同的Sofia Profile中去。即每个租户都有自己的的Profile（分别占用不同的端口号），它们的Profile中的信息及各种参数都可以不同。当然，若所有的租户都想使用5060这样的端口号，则可以使用DNS的SRV记录来解决。关于SRV记录的用法超出了本书的范围，读者可以自行研究。

[1] Multitenancy。参见http://en.wikipedia.org/wiki/Multitenancy。 

[2] Fully qualified domain name，译作完全资格域名，或绝对域名。参见http://en.wikipedia.org/wiki/Fully_qualified_domain_name。 

[3] 当然，也不完全是为了省事，有时候是因为太长的行在书中不容易排版。

## 使用loopback Endpoint外呼

如果要在FreeSWITCH中向外发起呼叫，需要一个呼叫字符串。在前面的章节中，我们学习过几种呼叫字符串，如user/1000、sofia/gateway/gw1/xx、ftdm/1/a/1000等。

但有些情况下，找到呼叫字符串不是那么容易。比方说，我们做了一套企业应用，该企业比较大，有很多分支机构，而且由于历史原因号码分配比较乱，因此我们需要在Dialplan中设置了几百个Extension，以匹配不同号码段正确路由，比如下面的代码：

```xml
<condition field="destination_number" expression="^0(.*)$">
<condition field="destination_number" expression="^11(2.*)$">
<condition field="destination_number" expression="^1234(852.*)$">
<condition field="destination_number" expression="^1234(52.*)$">
<condition field="destination_number" expression="^1234(.*)$">
......
```

如果在我们的应用中，在某些场合下（如自动传真、催缴费等）需要在FreeSWITCH中主动呼叫这些号码，则我们可以使用originate进行外呼，但在外呼时需根据不同的号段我们生成不同的呼叫字符串。这样我们的程序中就需要另外一套路由数据，这不仅与Dialplan中的数据重复，而且不利于维护。因此，我们就考虑能否在用originate外呼的时候也使用Dialplan呢？答案是肯定的，这里我们使用一个新的Endpoint，称为loopback。在理解它的实用原理之前，我们先来看一个简单的例子。

我们知道，路由到9664后会播放保持音乐，而路由到9196后会执行echo。以前只有有了一个Channel以后才能进入Dialplan，并路由到9664，而现在我们可以使用loopback提前进入Dialplan进行路由。如下面的命令：

```
freeswitch> originate loopback/9664 &bridge(loopback/9196)
```

这些Channel都是在FreeSWITCH内部发生的，运行完毕后可以使用下列命令看到，上述命令建立了4个Channel（由于输出行太长，我们简单了输出，仅列出有代表性的字段）：

```
freeswitch> show channels
22937c99-7710-4f64-869f-4f441cc15b54,inbound,loopback/9664-b ...
66f83997-5115-43e9-b1b1-b786ac64a9d2,outbound,loopback/9664-a ...
d91f7824-b314-4996-acc4-e27fb846e66a,outbound,loopback/9196-a ...
57416b98-702b-4d38-bc1b-084966fd04e3,inbound,loopback/9196-b ...
```

那么为什么它有4个Channel呢？我们知道在普通情况下，如果执行如下呼叫，将只产生两个Channel：

```
freeswitch> originate user/1000 &bridge(user/1001)
```

loopback这个Endpoint的关键就在这里，当然它的实现原理很简单但讲起来却很复杂。为了能让让呼叫先到达Dialplan查找路由，它首先创建一个假的腿（即Channel，称为loopback-a，我们称为第一条腿），然后让该腿进入Dialplan进行路由，执行playback播放保持音乐，然后再创建另一条腿（称为loopback-b，我们称为第二条腿），以继续下一步的动作。在此，它执行bridge。我们在bridge中也使用了loopback，因而会发生同样的事情，先创建一条假腿（另一个loopback-a，第三条腿）到Dialplan中找到适当的路由，执行echo，然后又创建一条腿（第四条腿）再与原先的那个腿bridge起来。如果还是不理解的话，可以查看一下刚才呼叫的日志，就能比较清楚了：

```
[NOTICE] switch_channel.c:1044 New Channel loopback/9664-a [66f83997-...
[NOTICE] switch_channel.c:1042 Rename Channel loopback/9664-a->loopback/9664-a
[NOTICE] switch_channel.c:1044 New Channel loopback/9664-b [22937c99-...
[NOTICE] mod_loopback.c:946 Channel [loopback/9664-a] has been answered
[NOTICE] mod_dptools.c:1225 Channel [loopback/9664-b] has been answered
[NOTICE] switch_channel.c:1044 New Channel loopback/9196-a [d91f7824-...
[NOTICE] switch_channel.c:1042 Rename Channel loopback/9196-a->loopback/9196-a
[NOTICE] switch_channel.c:1044 New Channel loopback/9196-b [57416b98-...
[NOTICE] mod_loopback.c:946 Channel [loopback/9196-a] has been answered
[NOTICE] mod_dptools.c:1225 Channel [loopback/9196-b] has been answered
```

从日志中可以看到，一共有4条腿（4个Channel）参与到该通话中，它们的名字分别是loopback/9664-a、loopback/9664-b、loopback/9196-a、loopback/9196-b。

当然，你也可以执行以下的例子，它将先呼叫1000，再呼叫1002，仍然会产生4条腿：

```
freeswitch> originate loopback/1000 &bridge(loopback/1001)
```

下面的命令的效果是一样的，但只会产生3条腿。

```
freeswitch> originate loopback/1000 1001
```

这是因为，1001那一端没有使用loopback，在1001那一端产生了两条腿以后，呼叫进入Dialplan进行路由，然后又“bridge”到1001，产生了第三条腿。

理解了这些之后，就可以对本节最开始的时候提出的那些号码进行呼叫了，而不用管它们是具体怎么路由的，如呼叫某个号码并自动发送传真：

```
freeswitch> originate loopback/123485234xxx &txfax(/tmp/test.tiff)
```

需要注意的是，由于使用loopback将比普通的呼叫多产生一条腿，因而话单可能受影响。为此，所有的loopback的Channel中都设置了一个is_loopback变量，以方便其他程序（如计费等）进行后续处理。

为了最大限度地减少因额外的腿产生的影响，也可以通过一个通道变量让这条额外的腿在完成它的使命之后尽快释放（或者说两条腿合并为一条），如下：

```
freeswitch originate {loopback_bowout=true}loopback/1000 &echo
```

上述命令将先建立两条腿，呼叫1000，在成功执行echo命令时，两条腿将条合并为一条。读者可以使用show Channels命令进行查看。

本节我们花了很大篇幅给大家讲解了loopback，之所以这么做除了因为它在某些场合确实有用外，还因为我们为了给大家讲清楚默认Dialplan中的Local_Extension部分的路由。在6.1.9节中，我们为了方便讲解，把默认Dialplan中呼叫失败后自动入进入Voicemail的Dialplan Action改写成了如下的形式：

```xml
<action application="voicemail" data="default ${domain_name} ${dialed_extension}"/>
```

但实际上，它是如下的形式：

```xml
<action application="bridge" data="loopback/app=voicemail:default ${domain_name} ${dialed_extension}"/>
```

后面这种方式使用了loopback。在大多数情况下，两者的效果是一样的。只不过，后者因为能在进入Voicemail后能产生一个Channel，因而还可以配合att-xfer（见第15.1.2节）一起使用。

在这里，与前面讲的loopback会先进入Dialplan进行路由不同，它直接使用“app=”这样的语法执行一个App，相当于loopback Dialplan的inline形式（关于inline Dialplan参见6.2节）。

## 在Web浏览器中打电话

多年来，随着互联网的发展，能在网页上打电话已经成为人们的一个梦想。当然，这些年来，人们也实现了一些方案，这些方案一般都是基于浏览器的插件实现的，如基于IE浏览器的ActiveX插件、Java Applect插件以及Flash插件等。其中，基于Flash插件的产品和解决方案由于其跨平台性和兼容性比较好，使用比较广泛，如比较著名的Red5 Media Server [1]及Wowza Media Server [2]等。

然而，随着HTML5技术的发展以及几年前苹果公司声明在iOS设备中不再支持Flash，Flash的使用量开始下滑，并且普遍认为前景不好。而此时，谷歌提出的基于HTML5的WebRTC实时通信技术却受到了大家的关注，各在线通信平台也纷纷推出支持WebRTC的实时通信方案。

但无论如何，现在的IE浏览器不支持WebRTC还是铁定的事实，所以我们还是需要Flash。下面我们就来看一下FreeSWITCH对Flash和WebRTC的支持是如何实现的。

### Flash

基于Flash的实时多媒体通信是基于Adobe的RTMP协议进行的。FreeSWITCH中通过mod_rtmp实现了一个基于RTMP协议的Endpoint，可以支持用Flash实现的软电话。如我们经常讲的一样，虽然Flash前景不再被看好，但是在一定范围内它还将顽强地存在。而且，作为有别于SIP模块（“mod_sofia”）的另外一个Endpoint，也很有参考和借鉴意义。

在FreeSWITCH源代码目录中使用如下命令即可安装该模块：

```
# make mod_rtmp-install
```

在FreeSWITCH控制台上使用load mod_rtmp命令加载该模块后，它将监听RTMP协议默认的1935端口，并等待客户端连接，使用如下命令将可以显示该模块的有关状态：

```
freeswitch> rtmp status
default tcp:0.0.0.0:1935    profile
```

上面的命令显示了有一个RTMP的Profile运行在1935端口上。

FreeSWITCH源代码中也实现了一个Flash版的软电话，并提供了客户端的例子。客户端及例子页面的源代码在FreeSWITCH源代码目录的clients/flex/目录中。要运行该例子，我们首先要进行一些修改，将freeswitch.html中的rtmp_url参数改为指向我们自己的RTMP服务器。如原来的参数值如下：

```
rtmp_url: 'rtmp://my.ip.address.here/phone'
```

笔者在测试时修改后的值如下（它指向笔者本机上的RTMP服务，即我们上面打开的1935端口上的服务）：

```
rtmp_url: 'rtmp://127.0.0.1/phone'
```

当然，为了能访问该HTML页面，我们还需要把这些相关的Web资源都放到一个Web服务器上运行。Python语言提供了一个简单的方案用于运行一个简单的Web服务器，我们可以在客户端的源代码目录中使用下载命令启动一个简单的HTTP Server，它将默认运行在8000端口上。

```
# python -m SimpleHTTPServer
```

然后，打开浏览器，访问与该服务器对应的网址，如http://localhost:8000/freeswitch.html，就可以看到图15-8所示的界面了。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-282869.png)

<center>图15-8　Flash测试页面初始界面</center>

其中，可以看到在最左上角有Connected字样，表示我们已经跟RTMP服务器（即FreeSWITCH）连接上了。但是，由于该网页上的Flash软电话需要访问本地的麦克风，由于网页的安全性考虑，系统弹出一个窗口以提示用户是否允许访问这些设备。这里我们选择允许（Allow）就可以了。

接下来，单击Login链接，输入用户及密码进行登录（即注册），笔者的输入如图15-9所示。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-296855.png)

<center>图15-9　将Flash软电话登录到FreeSWITCH上</center>

其中，“1008@192.168.7.5”为默认用户目录的配置，相当于“user@domain”，密码也是默认的“1234”。即“mod_rtmp”也跟“mod_sofia”一样使用用户目录中的配置对用户进行验证。

注册成功后，我们就可以单击“New Call”按钮输入一个号码拨打电话了，作为第一个测试我们可以拨打9196。

当然，Flash电话注册后，它是一个真正的电话，所以你也可以呼叫它。

回忆一下SIP中的注册，FreeSWITCH将记住客户端的Contact地址。在RTMP中也类似，每当有RTMP客户端向FreeSWITCH注册时，FreeSWITCH也记录该客户端的地址，如类似mod_sofia中的sofia_contat，mod_rtmp提供了一个rtmp_contact命令可以查询客户端的注册情况：

```
freeswitch rtmp_contact default/1008@192.168.7.5
rtmp/127c2026-bc81-437a-bfd0-2bca1bbcea35/1008@192.168.7.5
```

其中，default是RTMP Profile的名称。我们看到一个rtmp的呼叫字符串，然后就可以尝试呼叫它了：

```
freeswitch> originate rtmp/127c2026-bc81-437a-bfd0-2bca1bbcea35/1008@192.168.7.5 &echo
```

执行上述命令后，就会在浏览器中听到来话的提示音，并且可以看到如图15-10的来电提示页面。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-311854.png)

<center>图15-10　RTMP来电提示页面</center>

测试成功后，就可以编辑如下的Dialplan让别的Flash电话或SIP电话呼叫到1008了：

```xml
<extension name="RTMP">
  <condition field="destination_number" expression="^(1008)$">
    <action application="bridge"  data="${rtmp_contact(default/$1@$${domain})}"/>
  </condition>
</extension>
```

该Flash电话客户端提供源代码，也提供JavaScript API用于在HTML网页中调用，因而可以很方便地集成到其他Web系统中去。

### WebRTC

WebRTC [3]的全称是Web RealTime Communication，即基于Web的实时通信。实际上WebRTC提供了在浏览器中使用JavaScript API访问本地的声音和视频设备的手段。由于保护隐私和安全性的原因，浏览器在每次使用用户的声音或视频设备时都会询问是否允许。

`注意`：目前Chrome、FireFox以及Opera等浏览器实现了WebRTC。

值得注意的是，WebRTC仅提供了访问音视频设备这些媒体资源的方法，并没有规定信令是怎么走的。现有的例子大部分都使用了Google App Engine Channel API传输信息控制协议。另外一个可以传输信令的就是WebSocket [4]。

WebSocket是HTML5最初提供的一种浏览器与服务器间进行双向全双工通讯的网络技术。大家熟知的HTTP协议仅能用于通过浏览器单向请求服务器资源，而为了能使服务器主动向浏览器客户端推送资源，人们想尽了办法，如使用Ajax轮循、HTTP长连接、Flash提供的Socket功能及IE中的ActiveX控件等。WebSocket的出现解决了这些连接的混乱，它可以直接使用浏览器提供的功能和API与后端建立双向的Socket连接，包括IE9在内的现代浏览器都支持WebSocket。

有了WebSocket以后，SIP的承载方式就又多了一个选择。大家都已经知道，SIP一般通过UDP承载，也可以通过TCP或TLS承载，而出现了WebSocket以后，它也可以承载SIP，这种技术就称为SIP over WebSocket [5]，它目前还是一个IETF的草案。

信令和媒体都有了，我们就可以进行通信了。需要注意的是，浏览器中的视频编码有两个阵营。一个是以Google Chrome为代表的，它支持的视频格式是VP8；另一个是以Apple Safari为代表的，支持H264，而FireFox也支持H264。由于FreeSWITCH不支持转码，目前这两种视频还是不能互通。

另外，在写作本书时，JsSIP对FireFox的支持也不是很好，因而在以下的例子中我们都使用Chrome浏览器。

1. JsSIP

JsSIP [6]是一个开源的社区项目。FreeSWITCH官方提供了基于JsSIP的WebRTC的例子，地址为https://webrtc.freeswitch.org/。

读者访问以上地址可以看到网页提示输入一个名字或分机号进行登录，实际上就是向FreeSWITCH注册。FreeSWITCH后台开启了accept-blind-auth，因而任何用户名均可以成功注册。

登录成功后就可以在“To”一栏输入号码进行呼叫了。如输入888就可以进行FreeSWITCH默认的会议系统；输入mcu可以进入一个由第三方MCU提供的视频会议系统等。

2. sipML5

sipML5 [7]是由Doubango团队做出的SIP Over Websocket的开源实现。该项目可以在线试用，也可以在自己本地试用。sipML5的源代码是他们SVN维护的，使用以下命令可以将该项目检（checkout）到本地：

```
svn checkout http://sipml5.googlecode.com/svn/trunk/ sipml5-read-only
```

如果你使用Apache或Nginx Web服务器，可以把这些代码放到你的Web服务器目录下，然后在浏览器上访问。如果你的机器上有Python的话，可以使用它的SimpleHTTPServer模块很简单地启动一个Web服务器，如以下命令将启动一个简单的Web服务器 [8]，默认使用8000端口：

```
cd sipml5-read-only
python -m SimpleHTTPServer
```

如果你想改变端口，如改到8888，则可以使用如下命令：

```
python -m SimpleHTTPServer 8888
```

打开你的浏览器，访问该服务器对应的端口，就能看到与sipml5.org同样的界面 [9]。然后，单击“Enjoy our live demo”按钮就可以看到WebRTC电话的页面了。当然也可以尝试直接访问下面这个地址：http://localhost:8000/call.htm

由于你是在自己的服务器上使用的，因此要先进入“Expert mode”，将“WebSocket Server URL”修改为你服务器WebSocket的监听地址，修改完毕后单击“Save”按钮保存。这些值将保存到本地浏览器的Local Storage里，因而也可以直接通过浏览器的调试模式修改这些值，如图15-11所示。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-326878.png)

<center>图15-11　在Expert模式进行设置</center>

保存完上述设置后，即可以返回原先的call.htm页面。输入相关信息就可以注册（Login）了。图15-12显示了笔者填写的注册信息，并演示了注册后测试呼叫9196的情况。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-341854.png)

<center>图15-12　使用sipML5进行WebRTC视频呼叫</center>

另外，FreeSWITCH官方也提供了sipml5的例子，设置起来比较简单。请参考：https://webrtc.freeswitch.org/sipml5/。

[1] 参见http://www.red5.org/。 

[2] 参见http://www.wowza.com/。 

[3] http://www.webrtc.org/。 

[4] 参见http://zh.wikipedia.org/wiki/WebSocket http://tools.ietf.org/html/rfc6455。 

[5] 注意，不要把WebSocket跟WebRTC混了，它们是完全不同的东西。参见http://datatracker.ietf.org/doc/draft-ietf-sipcore-sip-websocket/。 

[6] 参见http://jssip.net/。 

[7] 参见sipml5.org/。 

[8] 本例是使用Python2的例子，如果使用的是Python3，则可以使用下列命令：“python3-m http.server”。 

[9] 不过，作者在测试中发现，由于index.html页面引用了一个外部的JavaScript，而该地址在国内是打不开的，因而会导致打开这个页面很慢。要解决这个问题，可以在index.html中找到包含下面地址的行并把它删掉：https://apis.google.com/js/plusone.js。

## HA

HA（High Availability）即高可用（可靠）性。在对稳定性要求非常高的场合，需要一定的机制来保证服务的稳定。一般的HA都是用双机（或多机）实现的，它的理论是，根据概率来计算，如果一台机器的稳定性（不出故障的概率）为99%，则两台机器的稳定性就是99.99%。

FreeSWITCH对HA有内置的支持，如果相互配对的两个FreeSWITCH中有一个崩溃或因硬件故障宕机，则另一台能在几秒内迅速接替它的工作，保证正在进行的通话不断话（正在接续的通话可能受影响）。下面我们先来做一个实验。

### 崩溃恢复实验

为了使用实验简单，我们先用一个FreeSWITCH实例来做实验。首先，我们配置好一个FreeSWITCH实例，用一个SIP客户端发起一路通话呼叫9664听保持音乐；然后让FreeSWITCH崩溃，这时候客户端会短暂地听不到声音；接着，我们重启FreeSWITCH并恢复崩溃前的通话，客户端上就又重新听到的声音。

为了让FreeSWITCH能在崩溃后恢复，FreeSWITCH需要将当前通话的信息写到数据库中。默认的SQLite数据库就可以使用，我们只需要配置Sofia Profile（internal）中如下一个参数：

```xml
<param name="track-calls" value="true"/>
```

配置好该参数后，FreeSWITCH会将通话的当前状态实时写到数据库里，我们先重启一下该Profile使该参数生效：

```
freeswitch> sofia profile internal restart
```

然后，用一个SIP客户端呼叫9664，听到保持音乐后，我们用下面的命令让FreeSWITCH崩溃：

```
freeswitch> fsctl crash
```

当然，上述命令是一个测试的命令，与“kill-9<pid>”是类似的。总之，至此FreeSWITCH就崩溃了。然后，我们重启FreeSWITCH，重启完成后，再执行：

```
freeswitch> sofia recover
Recovered 1 call(s)
```

该命令是最关键的。通过它，FreeSWITCH就会从数据库中读出崩溃前的通话信息，并恢复。

当然，该实验能成功的前提是你做得足够快（通过几秒或几十秒），因为有些SIP客户端在长时间收不到RTP流后，就会自己挂机，客户端挂机了，当然在FreeSWITCH端再恢复也没什么用了。

其实这里能恢复的原理很简单。由于在SIP会话建立后，电话进入正常通话中，一般在挂机之前再没有SIP消息交互了，只有RTP用于传送媒体数据。如果FreeSWITCH崩溃，则RTP数据只是短暂不能收发，而由于RTP是UDP的，因此客户端感觉不到FreeSWITCH崩溃而仍然发送RTP流（也许有一点点感觉就是暂时收不到RTP流了，而短时间内收不到RTP流的话客户端也不会抱怨）。因而在FreeSWITCH恢复后，电话马上就恢复了。当然，FreeSWITCH在恢复通话后，会重新发一个re-INVITE消息，以确定对方是否还在。

`注意`：我们这里讨论的崩溃恢复是假设SIP采用UDP的情况。如果SIP采用TCP方式连接，由于TCP是面向连接的协议，就不能保证总是能够恢复成功（跟对端和网络环境有关）。

### HA简介

上一节我们讲了FreeSWITCH中崩溃恢复的原理和一些细节，严格上来说还不算HA，但它为HA的实现打下了基础。其实，HA一般是为了解决硬件问题的。因为，如果软件有问题，如FreeSWITCH崩溃后，可以用另外一个监控程序迅速重启并恢复通话。但如果硬件发生问题，上述方式就不能解决了，因而需要配置另外一台机器，在检测到其中一个失败后便立即接替服务。

为了能使一台主机能完全接替另一台主机提供同样的服务，两台主机必须完全相同。下面我们以两台FreeSWITCH主机为例来说明一下。

如图15-13所示，有两个FreeSWITCH节点，分别为节点1和节点2，它们分别具有IP地址10.0.0.11和10.0.0.12。其中，节点1为主用节点，因此它绑定了一个浮动IP 10.0.0.10。对于SIP终端来讲，它们不知道节点1和节点2的存在，只知道它在跟一个IP地址是10.0.0.10的SIP服务器进行通信。现在，IP地址10.0.0.10绑定在节点1上，如果任何时候节点2发现节点1故障，它就会将IP地址10.0.0.10绑定到自己的网卡上，并接替节点1继续进行工作。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-357855.png)

<center>图15-13　FreeSWITCH HA拓扑结构示意图</center>

为了能使节点2能实时监测到节点1的健康状态，两者之间使用心跳线连接，并定期交换心跳（Heartbeat）消息。如果节点2在规定的时间内（通常几秒内）收不到对方的心跳，则认为节点1故障，并触发倒换过程，自己变为主节点。在物理上，心跳线可以用串口线，也可以用以太网线。

如果节点1在一段时间内恢复，这时候一般有两种选择：①它自动变为备用节点，下次节点2再出故障时它再变为主节点；②它依然作为主节点，节点2则变回从节点。具体的倒换策略视具体应用情况而定。

为了能使节点2能恢复节点1上正在进行的通话，两个节点需要连接到一个共享的数据库 [1]。

可以想象，节点2对节点1健康状况的判断仅依靠心跳线，如果心跳线出现故障，则可能引起错误的判断，造成不必要的主备切换。更严重的是，网络上会出现两个主机具有相同的IP地址（即浮动IP为10.0.0.10），两台主机也可能同时访问数据库中的共享资源引起数据混乱。这种可能的错误称为脑裂 [2]。为了预防脑裂的发生，一般有以下两种解决办法：

- 再增加一条心跳线，以降低由于心跳故障引起的错判；
- 增加STONITH [3]设备，强制关闭另一台设备的电源。

当然，到这里读者也可以看到，如果节点1真的发生故障了，那么节点2检测到以后便会启动倒换过程。如使用STONITH工具关掉对方节点的电源、将浮动IP绑定到本机上、启动FreeSWITCH、恢复通话等。这些工作可以使用一些脚本来解决，也可以使用专用的CRM [4]软件解决。FreeSWITCH可以很好地配合各种CRM软件工作，不过，在本书中，限于篇幅，我们就不涉及了。

需要指出，本节讲的是通用的HA的基本知识，我们以FreeSWITCH作为例子进行讲解只是为了能方便直观一些，其他的系统HA也与之类似，如在数据库HA系统中，可以把这里的FreeSWITCH节点看做是数据库节点，而这里的共享数据库资源就可以看作是数据库HA系统中的共享存储（磁盘阵列、SAN存储等）。

### 双机HA实现细节及需要注意的问题

由于搭建实际的演示环境颇为复杂，而且把各项步骤都讲明白也需要很大的篇幅，因此笔者就不在这里带领大家做具体的实验了，而是仅讨论一下双机HA的实现细节及需要注意的问题。如果读者有其他系统的HA实施经验，应该能很容易的实现；如果没有其他系统的HA实施经验的话，最好多学习和参考一下其他系统的HA，再来做FreeSWITCH的实验。

首先，我们需要两台一模一样的主机，安装操作系统（我们仅讨论Linux）和必要的软件，并安装FreeSWITCH。然后安装心跳软件。一般来说，可选的心跳软件有Keepalived和Heartbeat，前者比较古老，后者比较新，它们都能在检测到心跳失败时调用相关的脚本切换IP和FreeSWITCH。

当发生主备机切换时，需要在备机上启动FreeSWITCH，然后执行sofia recover命令，以恢复话务。这些过程都可以写一个简单的Shell脚本来实现，也可以直接配置FreeSWITCH（在vars.xml中）在系统启动时自动执行sofia recover，如：

```xml
<X-PRE-PROCESS cmd="set" data="api_on_startup=sofia recover"/>
```

当然，FreeSWITCH的过程可能会比较慢，因而会延长总体切换的时间。为了节省启动时间，我们可以使用FreeSWITCH的StandBy模式，即先在备机上启动FreeSWITCH，让其什么也不干，等到IP切换过来后就可以立即执行sofia recover以恢复业务。为了能支持这种模式，需要修改操作系统内核参数，允许FreeSWITCH监听在“不存在”的IP地址上（因为以后要使用的浮动IP现在还绑定在主用节点上，备用节点上还没绑定）。在Linux上可以使用如下命令实现：

```
echo 1 > /proc/sys/net/ipv4/ip_nonlocal_bind
```

上述命令会动态更改内核参数，但如果想使该参数在系统重启后也生效，需要将配置选项写到系统配置文件中，如：

```
echo 
“net.ipv4.ip_nonlocal_bind=1

\>\>/etc/sysctl.conf
```

当然，为了能正常恢复话务，还需要在FreeSWITCH的Sofia Profile中配置ODBC（或PGSQL）数据库支持以及开启track_calls参数。除此之外，还要注意配置文件中domain的值，注意这需配一个公共的值（如使用浮动IP或一个域名）而不是使用默认的、本机的固定IP地址。

其实FreeSWITCH的HA没有什么神秘的，相信如果读者有一些Linux经验并参照本节中所讲的知识应该都能配置出来。只是在实际应用中更需要注意以下几个问题：

- 性能降低。为了能实现HA，需要把通话数据实时写到数据库中，这无形地就增加了资源占用，降低了系统的吞吐量。
- 成本增加。增加的另一台配对主机以及需要增加的网络设备至少需要2倍的硬件成本，也需要增加维护成本，并且收效不是那么明显——如果一台永远不出故障，钱就白花了；而且，如我们在15.10节讲的，它提高的可靠性却有限（从99%增加到99.99%只是增加了0.99%的可靠性 [5]，显然与投入的成本不成正比）。
- 人为原因。并不是配置好HA就能放心睡大觉了，一个成熟的系统需要大量的测试以及长时间的优化；另外，HA也并不是解决一切问题的良药，更多的系统故障都是人为原因造成的。
- 带来的好处。当然，它带来的好处就是稳定性确实提高了。其实，更常用的功能就是系统升级时可以先升级备用的主机，然后进行主备倒换，再升级另一台主机而不会影响业务。
- 其他。FreeSWITCH在底层实现了从崩溃中快速恢复通话的机制，剩下的就要靠在使用过程中应用层的发挥了。最典型的，在大规模的集群中使用N+M [6]的策略应该是对投入和产出最好的平衡。

[1] 当然，数据库也可能需要实现HA，不过那超出了我们讨论的范围，在此我们认为数据库是可靠的。 

[2] 参见http://linux-ha.org/wiki/Split_Brain。 

[3] Shout the Other Node In the Head，可以翻译为“拍死它”。这种设备一般可以通过串口进行控制。 

[4] CRM是Cluster Resource Management的缩写，即资源管理软件，与常见的客户关系管理系统（Customer Relationship Management）完全不同。 

[5] 当然，这个问题分怎么看。其实故障率是从1%下降到0.01%，相当于故障率下降了100倍。 

[6] 即N台主机运行业务，M台备用，我们本节讨论的HA其实是N=M=1的特殊情况。

## 集群及分布式部署

在上一节我们讨论了HA，与HA相对的另一个概念是HP（High Performance），即高性能。它原先主要指大规模的并行计算，现在延伸到互联网域，就是大规模的集群。大规模的集群也是当下一个更时毛的词——“云”——的基础。由于这种方式一般采用多节点负载分担的方式工作，因而又称为负载均衡（Load Balance，LB）。

### 大规模集群的总体结构

图15-14显示了一个基于互联网的大规模的集群的拓扑结构。一般来说，用户通过客户端（Client）访问网络上的服务。客户端会使用DNS查询找到它要访问的主机。DNS服务一般使用轮循的方法，通过返回多个IP地址，将客户端的访问流量分散到不同的IP地址上。另外，有的DNS服务也可以根据用户的来源（地理位置）返回不同的IP，以将用户分配到就近的数据中心的服务器上。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-371854.png)

<center>图15-14　大规模集群总体结构示意图</center>

当客户的请求到达某一数据中心后，前端的路由器设备（或以太网交换机）会根据访问的服务进行合理的分发，将请求发到后端的代理服务器（Proxy）上。这些路由器比较有代表性的有硬件的F5或软件的LVS [1]等，它们都是在IP层（或应用层）进行转发分配的。

当请求到达某一个代理服务器后，它会检查本地的设置，将请求数据再转发到某一个计算节点（Node）上。而后端的计算节点间也可以通过内部的网络进行通信，或访问共享的数据等。最后，计算节点将执行相关的服务程序对收到的请求进行服务，有必要的话，它也可能查询数据库或与其他系统交互。

总之，互联网上海量用户的请求就是这样通过前端的DNS、路由器以及代理服务器分配到不同的计算节点上，并由其对用户进行服务的。

具体来讲，对于支撑整个互联网基础的Web应用，比较典型的代理服务器有HA-Proxy、Nginx、Apache等；后端的计算节点可以认为是Apache/PHP、Tomcat（Java）、Thin/Mongrel/Unicorn（Ruby/Rails）、Python等（当然，实际的情况还涉及后面的数据库、消息队列、大型存储等，比这里讲的要复杂得多）；而对于我们关心的VoIP应用来说，常用的代理服务器有OpenSIPS和Kamailio等，后端的节点可能是FreeSWITCH或Asterisk。当然，VoIP通信与Web服务不同的是，VoIP对于实时性的要求也比较高，而且信令跟媒体也是可以分离的（因而也有专门代理媒体的代理服务器，如RTPProxy）。

在实际的应用中，这些代理服务器应该足够“聪明”，即首先它能够比较智能地分配客户端的请求，力求使后端的计算节点负载比较均衡；其次，如果后端的计算节点出现故障，它也能很快探测到，并停止向其分发客户端的请求 [2]。当然，为了最大程度地保持稳定，代理服务器甚至前端的路由器及网交换机等都可以进行成对配置。

### 负载均衡配置实例

上一节，我们讲了大规模的集群的总体结构。具体到FreeSWITCH，它最典型的应用就是作为集群中的一个节点提供具体的服务，而前面的DNS、路由器以及各种代理服务等则主要是负责将相应的注册和呼叫等请求分配到相应的FreeSWITCH服务器上进行处理。

下面我们来做一个负载均衡的实验。如图15-15所示，以一台OpenSIPS和两个FreeSWITCH（A、B）节点为例 [3]。OpenSIPS位于前端，做Proxy；FreeSWITCH在后端，进行话务处理；它们都共享同一个数据库。OpenSIPS用于分发SIP请求，而后面的FreeSWITCH节点负责处理实际的通话，RTP媒体流仍然在用户UA和FreeSWITCH之间直接传送 [4]。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-387855.png)

<center>图15-15　OpenSIPS与FreeSWITCH负载均衡示意图</center>

OpenSIPS是著名的SIP Proxy，它的前身是OpenSER，而OpenSER的前身是SER（SIP Express Router）。后来，由于版权的原因OpenSER更名为OpenSIPS，而同时开发团队中的一部分人则开发出了另外一个分支，这一分支称为Kamailio。我们无意讨论它们之间的差别与优劣，总之它们的根是一样的，配置使用起来也差不多。

1. 配置FreeSWITCH

在配置OpenSIPS之前，我们应该配置两台一样的FreeSWITCH（A和B），分别测试注册和打电话并保证都没问题。然后，两个FreeSWITCH要连接一个共享的数据库，数据库可以参照12.3.2节中的ODBC配置，也可以使用原生的PostgreSQL驱动。简单起见，我们把数据库放到跟OpenSIPS相同的机器上，当然数据库也可以放到独立的数据库服务器上。

重要的一点是，两台FreeSWITCH要连接同一个数据库，并且设置vars.xml中的domain参数为一个同一个名称，如sip.example.com，将该DNS指向OpenSIPS服务器的IP地址。

修改domain，将vars.xml中的

```xml
<X-PRE-PROCESS cmd="set" data="domain=$${local_ip_v4}"/>
```

改为：

```xml
<X-PRE-PROCESS cmd="set" data="domain=sip.example.com"/>
```

所以，这里需要用到DNS服务器支持。如果没有DNS服务器，也可以尝试将这里的domain设为OpenSIPS服务器的IP地址，或者使用15.7.1节介绍的Domain知识进行相关配置。

2. 安装配置OpenSIPS

笔者在实验的时候用的是OpenSIPS 1.8.2版，如果版本号不同，配置文件也略有出入，其中“#”是注释起始符。

OpenSIPS的安装应该很简单，笔者在这里使用的是PostgreSQL数据库，如果你使用MySQL，也可以进行相应的替换。

使用如下命令进行OpenSIPS的安装：

```bash
cd opensips-1.8.2-tls
make all include_modules="db_postgres"
make include_modules="db_postgres" prefix="/usr/local" install
```

（1）创建数据库

可以使用opensipsctl命令创建数据库。在使用之前需要修改如下配置文件/usr/local/etc/opensips/opensipsctlrc，以提供相应的参数。参数名称都很直观，在此就不多讲了，如：

```
# SIP_DOMAIN=opensips.org

DBENGINE=PGSQL
DBHOST=localhost
DBNAME=opensips
DBRWUSER=opensips
DBRWPW="opensips"
DBROOTUSER="opensips"
```

然后运行以下命令创建数据库：

```
# opensipsdbctl create
```

在配置好所有参数之前，我们先将OpenSIPS启动到前台，这样便于调试。配置文件及解释如下，首先是基本的参数：

```
debug=5                        # 输出详细的日志memlog=1
fork=no                        # 启动到前台，fork=yes则启动到后台
children=2                     # 在前台不起作用，如果fork=yes，则控制启动多个进程
log_stderror=yes               # 将LOG输出到标准错误（控制台）

log_facility=LOG_LOCAL0        # 日志输出，后台模式有用
disable_tcp=yes                # 简单起见，我们只用udp
disable_dns_blacklist = yes
auto_aliases=no
check_via=no
dns=off
rev_dns=off
listen=udp:192.168.1.118:7060   # 监听的IP地址和端口，可以是多行，但前台模式只支持第一行
```

然后是加载模块配置，在这里，我们使用OpenSIPS中的两个模块来做负载均衡，一个是dispatcher，它用于均衡注册消息；另一个是load_balancer，它用于均衡呼叫相关的消息。其他模块的详细说明参见相关文档。

```
mpath="/usr/local/lib64/opensips/modules/" # 加载模块的路径
loadmodule "maxfwd.so"
loadmodule "sl.so"
loadmodule "db_postgres.so"
loadmodule "tm.so"
loadmodule "uri.so"
loadmodule "rr.so"
loadmodule "dialog.so"
loadmodule "mi_fifo.so"
loadmodule "signaling.so"
loadmodule "textops.so"
loadmodule "siptrace.so"
loadmodule "sipmsgops.so"                   # 1.8 版本以后才有
loadmodule "dispatcher.so"                  # 注册消息均衡(REGISTER)
loadmodule "load_balancer.so"               # 呼叫相关消息均衡(INVITE)
```

下面的模块的配置参数。模块参数配置一般是用modparam来指定的，其中第一个参数是模块名，第二个是参数名，不同的模块有不同的参数，具体如下：

```xml
# 默认的数据库的连接参数
db_default_url="postgres://opensips:opensips@localhost/opensips"
# fifo模块的配置参数，其他模块类似
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("dialog", "db_mode", 1)
<!-- modparam("dialog", "db_url", "postgres://opensips:opensips@localhost/opensips") -->
modparam("rr","enable_double_rr",1)
modparam("rr","append_fromtag",1)
modparam("siptrace", "trace_on", 1)
<!-- modparam("load_balancer", "db_url","postgres://opensips:opensips@localhost/opensips") -->
<!-- modparam("dispatcher", "db_url", "postgres://opensips:opensips@localhost/opensips") -->

# dispatcher模块的配置参数
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_interval", 5)
modparam("dispatcher", "ds_probing_threshhold", 2)
modparam("dispatcher", "ds_probing_mode", 1)
```

下面是路由的配置。路由的配置策略使用了类似C语言的脚本语言，看起来也比较直观，在此我们就不多解释了。路由配置内容如下：

```c++
route{
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }
    if (!has_totag()) { # 初始请求
        record_route();
    } else { # 后续请求—遵循指定的路由
        loose_route();
        t_relay();
        exit;
    }
    if ( is_method("CANCEL" )) { # 处理CANCEL及重传
        if ( t_check_trans() ) t_relay();
        exit;
    }
    # 从现在开始，我们就只有初始请求了
    if (is_method("INVITE")) {
        # 如果是 INVITE 消息，则将调用load_balance函数选择一个可用的后端节点
        if (!load_balance("1","pstn","1")) {
            send_reply("503","Service Unavailable");
            exit;
        }
    } else if (is_method("REGISTER")) {
        # 如果是注册消息，则调用dispatcher模块的ds_select_dst函数分发请求
        # record_route();
        if (!ds_select_dst("1", "0")) {
            send_reply("503","Service Unavailable");
            exit;
        }
    } else { # 我们暂时不转发其他消息
        send_reply("405","Method Not Allowed");
        exit;
    }
    if (!t_relay()) { # 转发请求
        sl_reply_error();
    }
}
```

将上面的配置文件存为lb.conf（名字和路径可以任意，反正我们是测试），然后运行如下命令启动OpenSIPS：

```
# opensips -f lb.conf
```

接着就可以看到很多日志，启动另一个终端，在数据库中增加分发的目的服务器。opensipsctl程序可以动态控制各模块的行为，如可以用如下命令在dispatcher中增加服务器：

```
# opensipsctl dispatcher addgw 1 sip:192.168.1.118 0 'FS1'

# opensipsctl dispatcher addgw 1 sip:192.168.1.119 0 'FS2'
```

然后启动一个SIP客户端注册到sip.example.com上，如果一切顺利则可以在FreeSWITCH A或B上收到注册消息。使用如下命令可以列出已注册的分机：

```
freeswitch> sofia status profile internal reg
```

由于两个FreeSWITCH都使用了同一个数据库，因此可以看到，在两台服务器上显示的信息都是一样的，就如同是在一台上一样 [5]。
另外，上面我们说到，对于呼叫相关的消息，由load_balancer这个模块来处理，这里可以直接将负载均衡配置数据直接写入数据库：

```sql
psql> insert into load_balancer (group_id, dst_uri, resources, description)
values (1,'sip:192.168.1.118', 'pstn=32', 'FS1');
psql> insert into load_balancer (group_id, dst_uri, resources, description)
values (1,'sip:192.168.1.119', 'pstn=32', 'FS1');
```

其中，pstn=32为服务器所能提供的资源，可以写成'pstn=32;conf=20'等，与lb.conf中load_balance()函数的第二个参数对应。

假设有1000和1001两个分机都已经成功注册。我们可以做一个测试，呼叫流程如下：

1）1000发INVITE请求到OpenSIPS，OpenSIPS转发INVITE到A，A查询数据库，找到1001的Contact地址，由于A是一个B2BUA，因此重新发起一个新的INVITE请求直接到1001所在的地址，1001接听后电话接通。

2）如果又有1002呼叫1003，则load_balance模块会将INVITE路由到B（因为A上已经有一路通话了），B呼叫1003，呼叫接通。

这样就达到了负载均衡的目的。

所有配置都测试无误后可以把lb.conf改到/usr/local/etc/opensips.conf，并把其中的fork参数改为yes以使OpenSIPS启动到后台。

另外一个好处是，如果我们使用这种配置，可以随时添加或去掉一台FreeSWITCH服务器，而不影响使用。比方说在系统升级的时候，我们可以把所有的话务都定向到其中一台上，等待另一台负载为0后，进行升级。升级完成后，再将所有新的话务指到升级后的机器上，待旧机器话务降到0后即可升级旧的FreeSWITCH。

在本例中，我们只是简单地介绍了OpenSIPS与FreeSWITCH配合使用的原理及基本配置，更多的示例可以参考http://wiki.freeswitch.org/wiki/Enterprise_deployment_OpenSIPS，在此不再赘述。

[1] LVS的全称是Linux Virtual Server，它是一个在Linux内核中实现的高度可伸缩、高可用的负载均衡服务器，详见http://www.linuxvirtualserver.org/。 

[2] 不过，这里一般不能像HA那样，如果一个计算节点失败，则将它正在计算的任务转给另外的服务器。对于Web服务来讲，如果客户在上浏览网页时不幸遇到这么一个坏的节点，则重新刷新一下页面就行了，对于VoIP应用来讲，则可以重新打一次电话。当然，对于FreeSWITCH来讲，比较终极的应用还可以是对于后端的每个节点都改成两台机器配对的HA方案，或者配置N+M方案。 

[3] 典型的，在生产应用中，OpenSIPS也应该用双机做HA，以避免单点故障。同理，后面的数据库也应该有相应的HA机制保证可靠。关于OpenSIPS及数据库的HA超出了本书的范围，在此我们假设这些服务是可靠的。 

[4] 当然OpenSIPS也有配合RTPProxy的RTP代理方案，在此我们就不讨论了。 

[5] SIP注册的流程是：SIP客户端发REGISTER到OpenSIPS，然后OpenSIPS发到A或B，A或B将SIP客户端的Contact地址写入数据库。由于数据库是共享的，因此在A和B上看起来都一样。

## 压力测试

如果将FreeSWITCH应用于生产系统，一般需要经过一定的压力测试。下面我们讨论几种针对FreeSWITCH进行压力测试的方法以及相关参数和性能指标。

### 参数和指标

我们先来讨论一下我们关心的指标。当我们拿到一台FreeSWITCH服务器时，一般只关心两个问题——它最大支持多少用户？最大支持多少用户同时通话？

与传统的TDM交换机相比，FreeSWITCH支持的最大用户数量几乎是无限的。因为，传统的TDM交换机中，每个用户（即每个电话）都会占用一个物理的硬件端口，这是一个绕不开的限制；而FreeSWITCH是IP的，所以基本上它仅受服务器内存及网络带宽的限制，可以很轻松地支持很大数量的用户。一般来说，FreeSWITCH的本地用户即使不打电话也会周期性地发送SIP注册（REGISTER）请求，因而支持的最大用户的数量就可以认为是跟FreeSWITCH所能处理的注册消息正相关的。一般来说，SIP客户端的注册失效（EXPIRE）时间是1小时，而根据SIP协议，客户端应该在半小时内重新发送注册消息，所以FreeSWITCH在1小时内仅需要处理一个用户的两次注册请求。假设FreeSWITCH在1秒内能处理100个注册请求的话，即它1秒就能服务50个用户，那么1小时就能服务3600×50=18000个用户。

当然，在NAT环境中，有的客户端为了保持NAT畅通，可能每十几秒就重发一次注册请求（实际上最好是重发OPTION）。同样，FreeSWITCH也可能1秒内能处理成千上万的用户注册。同时，具体的服务器以及网络环境也千差万别，因而，这些指标需要经过具体的测试才知道。

下一个指标就是最大并发数，也就是说一个系统最大可以支持多少人同时打电话。FreeSWITCH是一个典型的B2BUA，因而一般两个终端之间的通话就需要两个Channel，而像会议或IVR之类的应用就是每个终端一个Channel。简单起见，我们以系统并发的Channel的数量作为我们的并发指标。

与最大并发数相关的另一个指标是每秒能处理的呼叫数。一般来说，处理通话比较消耗资源的地方在于通话的建立和释放阶段——通话建立阶段需要处理Session的建立，媒体协商等；通话释放阶段需要处理Session的释放、写话单、清理现场等。而一旦通话建立后，双方互相收发媒体流，对系统资源的占用就可以认为是个常数了。

如果说系统每秒能处理30个呼叫（Channel）的建立与释放，每个呼叫持续30秒，那么系统的最大并发数就是30×30=900，而系统每小时能处理的呼叫数就是30×3600=108000。系统每小时所能处理的呼叫称为小时呼，又称BHCA（Busy Hour Call Attempt，即最大忙时试呼次数），每秒能处理的呼叫称为CPS（Call Per Second）。增加呼叫时长和增加每秒发起的呼叫数可以增加并发数。

在FreeSWITCH中，有两个参数可以限制系统能达到的最大呼叫量，以防止资源耗尽。其中，max_sessions控制最大并发数，它的默认值是1000；sps控制最大的每秒呼叫量，默认值是30。在系统中可以使用status命令查看这两个值（参见4.4节）。也可以使用如下命令修改这两个值：

```
freeswitch> fsctl max_sessions 5000
freeswitch> fsctl sps 100
```

上述命令仅在当前环境中生效，如果要使修改永远生效，则可以修改配置文件conf/autoload_configs/switch.conf.xml中如下的参数：

```xml
<param name="max-sessions" value="1000"/>
<param name="sessions-per-second" value="30"/>
```

### 呼叫测试

一般来说，大家比较关注呼叫测试。下面我们就来做两个实验。

1. FreeSWITCH对呼测试

首先，最简单的测试方法就是用两台FreeSWITCH对着呼。设置两台FreeSWITCH服务器，如A和B，它们的IP地址分别为192.168.1.A和192.168.1.B，则可以在B上使用如下命令呼叫A，并在本端执行echo App：

```
freeswitch> originate sofia/external/service@192.168.1.A:5080 &echo
```

注意，我们这里直接呼叫A的5080端口，以避免认证。当然，在A上的Public Dialplan中我们需要设置一个路由播放音乐：

```xml
<extension name="Load Test">
<condition field="destination_number" expression="^service$">
  <action application="answer"/>
  <action application="playback" data="local_stream://moh"/>
</condition>
</extension>
```

如果对于两台FreeSWITCH对呼的部署方式不熟悉的读者可以回过头去再看一下第13章的内容。

为了能方便的发起大量呼叫，我们在B上简单地写一个Shell脚本，具体如下：

```bash
#!/bin/bash
IP=192.168.1.A
CMD="bgapi originate sofia/external/service@$IP:5080 &eccho"
for f in `seq 1 10`; do
    for f in `seq 1 30`; do
       fs_cli -x $CMD
    done
    sleep 1
done
```

上述脚本使用两个for循环，内循环执行30次发起30个呼叫，然后停顿1秒，再次发起30个呼叫；外循环则控制总的循环次数。

这仅仅是一个简单的脚本，通话一旦建立便会一直处理通话状态，如果要控制通话的时长，可以在A的Dialplan中播放一个特定长度的文件，也可以在playback之前使用sched_hangup App设置多长时间后挂机，如：

```xml
<action application="sched_hangup" data="+60"/>
```

上述配置表示从现在开始，60秒后挂断通话。当然，如果仅仅测最大呼叫量的话，也可以不要让它自动挂机，而是在测试完成后手工使用hupall命令挂机。

2. 使用SIPP进行测试

SIPP [1]是一个很好的SIP测试工具，它可以对SIP协议及服务器性能进行比较全面测试。这里我们仅讨论最简单的情况。

首先，我们还是对上一节的FreeSWITCH服务器A进行测试，SIPP可以运行在A上，也可以运行在B上。它的使用方法很简单，只需要运行以下命令就可以了：

```
$ sipp -sn uac -r 1 -d 10000 -rtp_echo 192.168.1.A:5080
```

上述命令中，“-sn uac”表示使用SIPP默认的场景文件（它将作为一个UAC，即SIP客户端）；“-r 1”表示每秒发一个呼叫请求；“-d 10000”表示每个请求持续10000毫秒（即10秒）；“-rtp_echo”表示将收到的RTP流原样发回去（相当于FreeSWITCH中的echo App）；最后的参数表示发到FreeSWITCH服务器A的5080端口 [2]。

上述命令运行后，可以通过键盘上的1、2、3、4等按键控制界面上显示的统计信息，包含呼叫次数，成功、失败次数及各种时长信息等。图15-16是笔者在一次测试过程中的截图，图中显示了在20cps的情况下，当前有2001个并发呼叫，目前已成功进行了2137176次呼叫。

![](./images/第15章 其他技巧与实例/FreeSwitch权威指南-20211225-182224-401886.png)

<center>图15-16　SIPP测试截图</center>

SIPP使用XML描述的场景文件来描述何时该收、发什么样的SIP消息。不过其默认的配置文件少了点配置，因此FreeSWITCH社区推荐使用以下配置文件进行测试：http://www.freeswitch.org/eg/load_test/dft_cap.xml。下载完上述文件后，可以通过-sf参数指定使用该场景文件，如：

```
sipp -sf dft_cap.xml -r 1 -d 10000 -rtp_echo 192.168.1.A:5080
```

其中，“-r”表示每秒发一个请求，“-d 10000”表示每个呼叫持续10000毫秒（即10秒）；“192.168.1.21:5080”即FreeSWITCH的IP和端口；“-rtp_echo”表示我们把收到的RTP信息原样送回去，跟FreeSWITCH中的echo App类似。

SIPP默认使用的被叫号码为service，因此我们在上一节的Dialplan中就使用了service，当然，也可以使用-s参数指定一个其他的被叫号码，如下列代码指定被叫号码为load_test：

```
sipp -sf dft_cap.xml -s load_test -r 1 -d 10000 -rtp_echo 192.168.1.A:5080
```

当然，SIPP还有好多选项，读者也可以研究一下，自己来写场景文件。更多的测试方法请参阅SIPP的有关资料，在此我们就不多讲了。

### 注册测试

SIPP有一个场景文件可以支持注册测试，该文件可以在http://sipp.sourceforge.net/doc/branchc.xml处下载。有了该场景文件后，还需要配置一个数据文件，该文件提供注册用户的用户名密码等。如笔者使用的数据配置文件内容如下：

```
SEQUENTIAL
1001;[authentication username=1001 password=1234]
1002;[authentication username=1002 password=1234]
1003;[authentication username=1003 password=1234]
```

其中，“SEQUENTIAL”表示顺序执行。将上述文件存为users.csv，然后就可以使用如下的SIPP进行测试了：

```
sipp -aa -sf branchc.xml -inf users.csv -r 10 -p 6060 192.168.7.102
```

其中，我们使用了“-inf users.csv”指定我们使用的数据文件；“-r 10”表示每秒注册10个；“-p 6060”指定SIPP监听的本地的端口号，它的默认值是5060，明确指定端口号是为了防止当SIPP与FreeSWITCH在同一台主机上运行时产生冲突；最后的IP地址为FreeSWITCH的地址。

运行上述命令后，可以在SIPP中看到相关的统计信息，在FreeSWITCH中也可以使用“sofia status profile internal reg”命令查看客户端是否已正确注册。

### 编解码测试

FreeSWITCH支持很多语音编码，不同编码的性能也不同。比如G711（PCMU/PCMA）编解码基本上只要靠查表就行，所以是最高效的，而G729或iLBC之类的编码就需要比较高的CPU。测试编解码的性能也很简单，如笔者在测试时在FreeSWITCH的external Profile中使用如下参数设置语音编码为G729：

```xml
<param name="inbound-codec-prefs" value="G729"/>
```

然后在另一个（或几个）FreeSWITCH服务器上向该被测试的FreeSWITCH上发起呼叫，或者使用SIPP对它进行呼叫。当有测试到来时，进入相关的Dialplan播放一个声音文件即可。

笔者曾在一台虚拟机上简单进行过测试，编解码的性能从高到低依次是：PCMU/A、G729（FreeSWITCH官方商业版）、SILK、iLBC、iSAK，后面的几种编码需要比PCMU多使用几倍的CPU。限于当时的环境没有测试其他编解码。当然，笔者的测试结果仅供参考，读者如果感兴趣可以使用这里的方法自己测试一下。

### 测试结果

在本例中，我们讨论了压力测试的一些相关指标并实验了几种测试方法。大多数的测试都没有标准答案，FreeSWITCH官方也一直不正面回应压力测试的问题，理由是每个人的系统都是不一样的，业务场景也不同，操作系统以及软硬件环境也不一样，因此，测试的最终结果可能会差异很大。而且，压力测试能测试的呼叫流程和各种应用场景毕竟有限，所以最好也最准确的测试就是将FreeSWITCH应用到生产中去用实际的场景进行实地测试。

[1] 参见http://sipp.sourceforge.net/。 

[2] 因为5080端口无需认证，所以测试起来比较方便。对5060端口进行测试需要配置认证支持，这比较复杂，在此我们就不多介绍了。

## 生产环境下的稳定性和安全性

如果将FreeSWITCH用于生产环境，或者用于公网上，那么稳定性和安全性是必须考虑的。一般来说，FreeSWITCH是比较稳定的，其默认的配置也是比较安全的。但真正的应用中肯定需要考虑稳定性的问题，而且仅使用其默认的配置也肯定不能满足应用要求。在此我们来简单介绍一下这两个问题。

### 稳定性

FreeSWITCH本身是比较稳定的。它是很优秀的开源软件，全世界有很多人将它用于各种应用场景，因此，如果它有导致不稳定的地方，总会有人将问题反馈到社区，而且一般也会很快有人修复该问题。

另一方面来讲，FreeSWITCH又是比较激进的，它的开发分支里很快会有大量的新特性加入，因此在测试不全面的情况下出现不稳定的情况也是难免的。

所以，如果用于生产环境，使用一个稳定的分支是有必要的。在本书截稿时，最新的稳定版是1.2.22，最新的稳定分支是1.2.stable。最新的1.4版目前还处于Beta阶段，相信很快就见到正式版了。

另外，即使稳定版也可能会崩溃。一旦出现这种情况，最好的解决方案就是立即恢复系统运行。在UNIX类系统上，可以使用monit [1]等监控工具监控FreeSWITCH进程，并在崩溃后快速恢复FreeSWITCH运行。在对稳定性要求更高的场合，可以考虑使用我们前面讲过到双机HA方案或多机集群。

### 安全性

对于安全性而言，我们来考虑以下几个方面：

- FreeSWITCH默认所有用户的密码都是1234，这个一定是需要改的。可以修改vars.xml中的default_password全局变量，也可以针对每个用户在conf/directory/default/*.xml中修改。
- Event Socket（就是使用fs_cli）默认监听在本地Loopback IP 127.0.0.1上，因此应该是安全的。但如果开了远程访问（如在其他主机上使用Event Socket与它连接）就记得修改一下这个密码。ESL连接的密码传输都是明文的，因此不建议在公网上使用，除非在专用的VPN或加密隧道中。
- 默认情况下，mod_xml_rpc是不加载的。如果你需要加载它，也应记住修改该模块的密码。它使用HTTP Basic来认证，因为密码都是明文传输的，不建议在公网上使用。如果需要使用的话建议在前面加HTTPS代理服务器。
- 默认的5080端口是允许任何人呼入的，因此需要确认它对应的public Dialplan里是否有最少的路由规则。
- 如果有黑客攻击，一般会发送大量的注册或呼叫请求暴力尝试所有可能的密码，可以考虑使用Fail2ban [2]功能来抵御这种攻击。
- 在操作系统层，可以使用考虑使用iptables来设置合适的防火墙。另外，配合使用Snort [3]或AIDE [4]等防止入侵检测系统 [5]也非常有用。
- 最后，最可怕的是DDOS [6]攻击。这是一个世界性的难题，不过，如果你不幸遇到这种攻击了，那说明别人可能是找错了门，或者你的业务已经是世界级的大了。那时候你将可以有更多的资源来解决这一问题。不过为了防患于未然，一般来说选择一个好的数据中心能在一定程度上帮你解决这个问题。

总之，达到一定稳定性和安全性的同时肯定会带来一定的系统复杂性，另外也会增加一定的实施和维护成本，这是不可避免的。在本小节中，我们仅点出了一些应注意的问题，并提到了一些常用的软件和工具，希望对读者有所帮助。如果将FreeSWITCH真正应用于生产环境，肯定还有更多的问题需要考虑。更深入的讨论超出了本书的范围，在此我们就不再展开了。

[1] 一个系系统监控工具，可以在检测到进程失败时迅速恢复运行，参见http://mmonit.com/。 

[2] 失败即禁止，参见http://wiki.freeswitch.org/wiki/Fail2ban。 

[3] 一个开源的网络入侵防御和检测系统，参见http://www.snort.org/。 

[4] Advanced Intrusion Detection Environment，即高级入侵检测环境，参见http://en.wikipedia.org/wiki/Advanced_Intrusion_Detection_Environment。 

[5] 简称IDS，即Intrusion Detection System，参见http://zh.wikipedia.org/wiki/入侵检测系统。 

[6] Distributed Denial of Service，分布式阻断服务攻击，又称洪水攻击，参见http://zh.wikipedia.org/zh-cn/分布式阻断服务攻击。

## 小结

本章的内容比较广泛（主要是FreeSWITCH的功能确实比较多），从简单的企业通信应用，到传真、DTMF、电话连选功能、多租户配置等都有涉及。这些内容实现用起来比较有用，也通常是读者比较关心的问题。

通过使用组播方式进行通话的例子，让我们看到了通信功能的延伸，看到了FreeSWITCH功能的另一面，它不仅仅能打电话！

接下来，我们看到，通过与Flash及WebRTC技术的融合，FreeSWITCH完全融入互联网了。

再后面，我也讨论了一些将FreeSWITCH应用于生产环境中需要考虑的HA、大规模集群或分布式部署，以及相关的压力测试、稳定性及安全性问题。虽然我们没有将所有问题都给出答案，但对于想将FreeSWITCH应用于生产环境中的读者来说，这些内容肯定很有指导意义。

