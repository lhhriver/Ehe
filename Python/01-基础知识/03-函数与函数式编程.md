# 函数

## 实参和形参

- 形参：函数完成其工作所需要的一项信息。
- 实参：调用函数时专递给给函数的信息。

## 传递参数

　　函数定义中可能包含多个形参，因此函数调用时也可能包含多个实参。向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。

> 位置实参

 - 你调用函数时，Python必须将函数调用中的每个实参都关联到函数定义中的一个形参。简单的关联方式是基于实参的顺序。这种关联方式被称为位置实参。
 - 在函数中，可根据需要使用任意数量的位置实参，Python将按顺序将函数调用中的实参关联到函数定义中相应的形参。
- 使用位置实参来调用函数时，如果实参的顺序不正确，输出也不会正确。

>关键字实参和关键字参数

 - 关键字实参是传递给函数的（名称—值）对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。
 - 关键字实参让你无需考虑函数调用中的实参顺序，还清楚地指出了函数调用中各个值的用途。
- 可以传入任意个数的关键字参数：

```python
person('Bob', 35, city='Beijing')

>>> name: Bob age: 35 other: {'city': 'Beijing'}

person('Adam', 45, gender='M', job='Engineer')

>>> name: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}
```

>默认值

- 编写函数时，可给每个形参指定默认值 。在调用函数中给形参提供了实参时，Python将使用指定的实参值；否则，将使用形参的默认值。因此，给形参指定默认值后，可在函数调用中省略相应的实参。使用默认值可简化函数调用，还可清楚地指出函数的典型用法。最大的好处是能降低调用函数的难度。
- 默认参数必须指向不变对象！
```python
def add_end(L=None):
    if L is None:
        L = []
    L.append('END')
    return L
```

>可变参数

- 定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个 \* 号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。

```python
def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum

>>> calc(1, 2)
5
>>> calc()
0
```
- Python允许你在list或tuple前面加一个\*号，把list或tuple的元素变成可变参数传进去：

```python
# *nums表示把nums这个list的所有元素作为可变参数传进去。

nums = [1, 2, 3]
calc(*nums)

>>> 14
```

>命名关键词参数

-  对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。
-  如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：
```python
def person(name, age, *, city, job):
    print(name, age, city, job)
```
- 和关键字参数\*\*kw不同，命名关键字参数需要一个特殊分隔符\*，\*后面的参数被视为命名关键字参数。
- 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符\*了：

```python
def person(name, age, *args, city, job):
    print(name, age, args, city, job)
```
- 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：

```python
person('Jack', 24, 'Beijing', 'Engineer')

>>>
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: person() takes 2 positional arguments but 4 were given
```
- 由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。
- 命名关键字参数可以有缺省值（默认值），从而简化调用：

```python
def person(name, age, *, city='Beijing', job):
    print(name, age, city, job)
```
- 由于命名关键字参数city具有默认值，调用时，可不传入city参数：

```python
person('Jack', 24, job='Engineer')

>>>Jack 24 Beijing Engineer
```

- 定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符\*，否则定义的将是位置参数。



## 递归

```python
# 建立一个基于目标行业的database
# 比如 这里我们用python自带的graph
graph = {'上海': ['苏州', '常州'],
         '苏州': ['常州', '镇江'],
         '常州': ['镇江'],
         '镇江': ['常州'],
         '盐城': ['南通'],
         '南通': ['常州']}

# 明确如何找到从A到B的路径
def find_path(start, end, path=[]):
    path = path + [start]
    if start == end:
        return path
    if start not in graph:
        return None
    for node in graph[start]:
        if node not in path:
            newpath = find_path(node, end, path)
            if newpath: 
                return newpath
    return None

print(find_path('上海', "常州"))
```



# 推导式

## 列表推导式

```python
multiples = [i for i in range(30) if i % 3 is 0]
print(multiples)

[0, 3, 6, 9, 12, 15, 18, 21, 24, 27]
```



## 字典推导式


```python
mcase = {'a': 10, 'b': 34, 'c': 20, 'd': 35}
mcase_frequency = {v: k for k, v in mcase.items() if v > 30}
mcase_frequency
```

    {34: 'b', 35: 'd'}



## 集合推导式


```python
squared = {x**2 for x in [1, 1, 2, 5, 8]}
print(squared)
```

    {64, 1, 4, 25}

# 函数式编程

## lambda

```python
f = lambda x, y: x+y
print(f(10, 20))

list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))

>>>[1, 4, 9, 16, 25, 36, 49, 64, 81]
```


## map


```python
def formating(name):
    return name.title()


L = list(map(formating, ['adam', 'LISA', 'barT']))
print(L)
```

    ['Adam', 'Lisa', 'Bart']



```python
list(map((lambda x: x + 1), [1, 2, 3]))
```


    [2, 3, 4]



## reduce

```python
from functools import reduce
nums = [1,2,3,4]
a = reduce(lambda x,y:x*y,nums)
print(a)
# 输出：24
```



```python
from functools import reduce
chars = ['a','p','p','l','e']
a = reduce(lambda x,y:x+y,chars)
print(a)
# 输出：apple
```




```python
from functools import reduce

key_words_disease = {
    '多囊卵巢综合症': ['卵巢'],
    '妇科炎症': ['妇科'],
    '高血压': ['血压'],
    '高血脂': ['血脂', '脂血'],
    '甲状腺疾病': ['甲亢', '甲减', '结节', '甲状腺']
}

# 获取关键词
key_words_set = set(
    reduce(lambda x, y: x + y, list(key_words_disease.values())))

key_words_set
```

    {'卵巢', '妇科', '甲亢', '甲减', '甲状腺', '结节', '脂血', '血压', '血脂'}




```python
from functools import reduce


def fn(x, y):
    return x * 10 + y


a = reduce(fn, [1, 3, 5, 7, 9])

print("reduce结果为:", a)
```

    reduce结果为: 13579



```python
reduce((lambda x, y: x * y), [2, 3, 4])
```


    24


```python
reduce((lambda x, y: x + y), range(1, 100 + 1, 1))
```

    5050



## filter


```python
def not_empty(s):
    return s and s.strip()


L2 = list(filter(not_empty, ['A', '', 'B', None, 'C', '  ']))
L2
```

    ['A', 'B', 'C']




```python
list(filter(lambda x: x > 0, list(range(-4, 5))))
```


    [1, 2, 3, 4]



# 生成器

　　大多数生成器是以函数来实现的，然而，它并不返回（return）一个值，而是生成（yield）一个值，并挂起程序。然后，通过next()方法生成并马上返回一个元素，或者通过for循环，逐一生成和返回全部元素。

　　生成器表达式与列表生成式极其形似，只是把[]改成了()，但背后的原理大不相同。

　　要创建一个generator，有很多种方法。

　　第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：


```python
l = [x * 2 for x in range(5)]  # 列表生成式，4以内整数的2倍数
g = (x * 2 for x in range(5))  # 生成器表达式

type(l), type(g)

>>>(list, generator)


g = (x * x for x in range(10))
next(g), next(g), next(g)

>>>(0, 1, 4)
```

```python
# 计算斐波那契数列的生成器
def fibon(n):
    a = b = 1
    for i in range(n):
        yield a  # 使用yield
        a, b = b, a + b


# 计算前1000000个数，通过next()函数，按顺序每次生成一个数

g = fibon(1000000)
next(g), next(g), next(g), next(g), next(g)

>>>(1, 1, 2, 3, 5)

# 以此类推，但若调用超过1000000次，就会报异常StopIteration
```


# 迭代器

>什么是迭代器

　　迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。

>可迭代对象

　　以直接作用于 for 循环的数据类型有以下几种：

- 一类是集合数据类型，如 list 、 tuple 、 dict 、 set 、 str 等；

- 一类是 generator ，包括生成器和带 yield 的generator function。

  这些可以直接作用于 for 循环的对象统称为可迭代对象： Iterable 。

>判断是否可以迭代

  可以使用 isinstance() 判断一个对象是否是 Iterable 对象：
```python
from  collections import Iterable

print(isinstance([], Iterable))
print(isinstance({}, Iterable))
print(isinstance('123',Iterable))
print(isinstance((x for x in range(5)),Iterable))
print(isinstance(100,Iterable))
```

>iter()

　　可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。

　　生成器都是 Iterator 对象，但 list 、 dict 、 str 虽然是 Iterable ，却不是 Iterator 。

　　把 list 、 dict 、 str 等 Iterable 变成 Iterator 可以使用 iter() 函数：

```python
from  collections import Iterable

a=[1,2,4,6,8,6,10]
a=iter(a)
print(next(a))
print(next(a))
print(next(a))
```

>小结

- 凡是可作用于 for 循环的对象都是 Iterable 类型；
- 凡是可作用于 next() 函数的对象都是 Iterator 类型
- 集合数据类型如 list 、 dict 、 str 等是 Iterable 但不是 Iterator ，不过可以通过 iter() 函数获得一个 Iterator 对象



# 装饰器

　　Python是一种对新手很友好的语言。但是，它也有很多较难掌握的高级功能，比如装饰器（decorator）。很多初学者一直不理解装饰器及其工作原理，在这篇文章中，我们将介绍装饰器的来龙去脉。

　　在Python中，函数是一种非常灵活的结构，我们可以把它赋值给变量、当作参数传递给另一个函数，或者当成某个函数的输出。装饰器本质上也是一种函数，它可以让其它函数在不经过修改的情况下增加一些功能。

　　这也就是「装饰」的意义，这种「装饰」本身代表着一种功能，如果用它修饰不同的函数，那么也就是为这些函数增加这种功能。

　　一般而言，我们可以使用装饰器提供的 @ 语法糖（Syntactic Sugar）来修饰其它函数或对象。如下所示我们用 @dec 装饰器修饰函数 func ()：

```python
@dec
def func():
  pass
```

　　理解装饰器的最好方式是了解装饰器解决什么问题，本文将从具体问题出发一步步引出装饰器，并展示它的优雅与强大。

>设置问题

　　为了解装饰器的目的，接下来我们来看一个简单的示例。假如你有一个简单的加法函数 dec.py，第二个参数的默认值为 10：

```python
# dec.py

def add(x, y=10):
  return x + y

```

　　我们来更认真地看一下这个加法函数：

```python
>>> add(10, 20)
30
>>> add
<function add at 0x7fce0da2fe18>
>>> add.__name__
'add'
>>> add.__module__
'__main__'
>>> add.__defaults__ # default value of the `add` function
(10,)
>>> add.__code__.co_varnames # the variable names of the `add` function
('x', 'y')
```

　　我们无需理解这些都是什么，只需要记住 Python 中的每个函数都是对象，它们有各种属性和方法。你还可以通过 inspect 模块查看 add() 函数的源代码：

```python
from inspect import getsource
print(getsource(add))

def add(x, y=10):
  return x + y
```

　　现在你以某种方式使用该加法函数，比如你使用一些操作来测试该函数：

```python
# dec.py
from time import time

def add(x, y=10):
  return x + y

print('add(10)',         add(10))
print('add(20, 30)',     add(20, 30))
print('add("a", "b")',   add("a", "b"))
Output: i

add(10) 20
add(20, 30) 50
add("a", "b") ab
```

　　假如你想了解每个操作的时间，可以调用 time 模块：

```python
# dec.py
from time import time


def add(x, y=10):
  return x + y

before = time()
print('add(10)',         add(10))
after = time()
print('time taken: ', after - before)
before = time()
print('add(20, 30)',     add(20, 30))
after = time()
print('time taken: ', after - before)
before = time()
print('add("a", "b")',   add("a", "b"))
after = time()
print('time taken: ', after - before)
Output:

add(10) 20
time taken:  6.699562072753906e-05
add(20, 30) 50
time taken:  6.9141387939453125e-06
add("a", "b") ab
time taken:  6.9141387939453125e-06
```

　　现在，你作为一个编程人员是不是有些手痒，毕竟我们不喜欢总是复制粘贴相同的代码。现在的代码可读性不强，如果你想改变什么，你就得修改所有出现的地方，Python 肯定有更好的方式。

　　我们可以按照如下做法，直接在 add 函数中捕捉运行时间：

```python
# dec.py
from time import time

def add(x, y=10):
  before = time()
  rv = x + y
  after = time()
  print('time taken: ', after - before)
  return rv

print('add(10)',         add(10))
print('add(20, 30)',     add(20, 30))
print('add("a", "b")',   add("a", "b"))
```


　　这种方法肯定比前一种要好。但是如果你还有另一个函数，那么这似乎就不方便了。当我们有多个函数时：

```python
# dec.py
from time import time

def add(x, y=10):
  before = time()
  rv = x + y
  after = time()
  print('time taken: ', after - before)
  return rv

def sub(x, y=10):
  return x - y

print('add(10)', add(10))
print('add(20, 30)', add(20, 30))
print('add("a", "b")', add("a", "b"))
print('sub(10)', sub(10))
print('sub(20, 30)', sub(20, 30))
```

　　因为 add 和 sub 都是函数，我们可以利用这一点写一个 timer 函数。我们希望 timer 能计算一个函数的运算时间：

```python
def timer(func, x, y=10):
  before = time()
  rv = func(x, y)
  after = time()
  print('time taken: ', after - before)
  return rv
```

　　这很不错，不过我们必须使用 timer 函数包装不同的函数，如下所示：

```python
print('add(10)', timer(add,10)))
```

　　现在默认值还是 10 吗？未必。那么如何做得更好呢？

　　这里有一个主意：创建一个新的 timer 函数，并包装其他函数，然后返回包装后的函数：

```python
def timer(func):
  def f(x, y=10):
    before = time()
    rv = func(x, y)
    after = time()
    print('time taken: ', after - before)
    return rv
  return f
```

　　现在，你只需用 timer 包装一下 add 和 sub 函数 ：

```python
add = timer(add)
```

　　这样就可以了！以下是完整代码：

```python
# dec.py
from time import time

def timer(func):
  def f(x, y=10):
    before = time()
    rv = func(x, y)
    after = time()
    print('time taken: ', after - before)
    return rv
  return f

def add(x, y=10):
  return x + y

add = timer(add)


def sub(x, y=10):
  return x - y

sub = timer(sub)

print('add(10)',         add(10))
print('add(20, 30)',     add(20, 30))
print('add("a", "b")',   add("a", "b"))
print('sub(10)',         sub(10))
print('sub(20, 30)',     sub(20, 30))

Output:

time taken:  0.0
add(10) 20
time taken:  9.5367431640625e-07
add(20, 30) 50
time taken:  0.0
add("a", "b") ab
time taken:  9.5367431640625e-07
sub(10) 0
time taken:  9.5367431640625e-07
sub(20, 30) -10
```


　　我们来总结一下这个过程：我们有一个函数（比如 add 函数），然后用一个动作（比如计时）包装该函数。包装的结果是一个新函数，能实现某些新功能。

　　当然了，默认值还有点问题，稍后我们会解决它。


> 装饰器

　　现在，上面的解决方案以及非常接近装饰器的思想了，使用常见行为包装某个具体的函数，这种模式就是装饰器在做的事。使用装饰器后的代码是：

```python
def add(x, y=10):
  return x + y
add = timer(add)
You write:

@timer
def add(x, y=10):
  return x + y
```


　　它们的作用是一样的，这就是 Python 装饰器的作用。它实现的作用类似于 add = timer(add)，只不过装饰器把句法放在函数上面，且句法更加简单：@timer。

```python
# dec.py
from time import time

def timer(func):
  def f(x, y=10):
    before = time()
    rv = func(x, y)
    after = time()
    print('time taken: ', after - before)
    return rv
  return f

@timer
def add(x, y=10):
  return x + y

@timer
def sub(x, y=10):
  return x - y

print('add(10)',         add(10))
print('add(20, 30)',     add(20, 30))
print('add("a", "b")',   add("a", "b"))
print('sub(10)',         sub(10))
print('sub(20, 30)',     sub(20, 30))
```

> 参数和关键字参数

　　现在，还有一个小问题没有解决。在 timer 函数中，我们将参数 x 和 y 写死了，即指定 y 的默认值为 10。有一种方法可以传输该函数的参数和关键字参数，即 *args 和 **kwargs。参数是函数的标准参数（在本例中 x 为参数），关键字参数是已具备默认值的参数（本例中是 y=10）。代码如下：

```python
# dec.py
from time import time

def timer(func):
  def f(*args, **kwargs):
    before = time()
    rv = func(*args, **kwargs)
    after = time()
    print('time taken: ', after - before)
    return rv
  return f

@timer
def add(x, y=10):
  return x + y

@timer
def sub(x, y=10):
  return x - y

print('add(10)',         add(10))
print('add(20, 30)',     add(20, 30))
print('add("a", "b")',   add("a", "b"))
print('sub(10)',         sub(10))
print('sub(20, 30)',     sub(20, 30))
```



　　现在，该 timer 函数可以处理任意函数、任意参数和任意默认值设置了，因为它仅仅将这些参数传输到函数中。

> 高阶装饰器

　　你们可能会疑惑：如果我们可以用一个函数包装另一个函数来添加有用的行为，那么我们可以再进一步吗？我们用一个函数包装另一个函数，再被另一个函数包装吗？

　　可以！事实上，函数的深度可以随你的意。例如，你想写一个装饰器来执行某个函数 n 次。如下所示：

```
def ntimes(n):
  def inner(f):
    def wrapper(*args, **kwargs):
      for _ in range(n):
        rv = f(*args, **kwargs)
      return rv
    return wrapper
  return inner
```

　　然后你可以使用上述函数包装另一个函数，例如前文中的 add 函数：

```python
@ntimes(3)
def add(x, y):
  print(x + y)
  return x + y
```

