# 多进程和多线程

1. 发展背景
2. 进程与线程的区别
3. python多线程模块threading 
4. python多进程模块multiprocessing 
5. 队列模块queue

##  多线程

### 单线程

依次逐个执行


```python
#-*- conding:utf-8 -*-

import time
import threading

def music(name,loop):
    for i in range(loop):
        print('listen music %s %s'%(name,time.ctime()))
        time.sleep(1)

def movie(name,loop):
    for i in range(loop):
        print('look movie %s %s'%(name,time.ctime()))
        time.sleep(1)


if __name__ == '__main__':
    music('爱的故事上集',3)
    movie('晓生克的救赎',4)
    print('end time %s'%time.ctime())
```

    listen music 爱的故事上集 Sat Jan  5 13:36:35 2019
    listen music 爱的故事上集 Sat Jan  5 13:36:36 2019
    listen music 爱的故事上集 Sat Jan  5 13:36:37 2019
    look movie 晓生克的救赎 Sat Jan  5 13:36:38 2019
    look movie 晓生克的救赎 Sat Jan  5 13:36:39 2019
    look movie 晓生克的救赎 Sat Jan  5 13:36:40 2019
    look movie 晓生克的救赎 Sat Jan  5 13:36:41 2019
    end time Sat Jan  5 13:36:42 2019


### 多线程


```python
def music(name,loop):
    for i in range(loop):
        print('listen music %s %s %s\n'%(name,time.ctime(),threading.Thread.getName(t1)))
        time.sleep(1)

def movie(name,loop):
    for i in range(loop):
        print('look movie %s %s %s\n'%(name,time.ctime(),threading.Thread.getName(t2)))
        time.sleep(1)

#1.创建多线程
# 线程1
t1 = threading.Thread(target= music,args=('爱的故事上集',4))
t1.setName('musicThread')  # 线程名称，方法一

# 线程2
t2 = threading.Thread(target= movie,args=('肖生克的救赎',4),name = 'movieThread')  # 线程名称，方法二

if __name__ == '__main__':
    #4.守护主线程，主线程结束杀死子线程
    t1.setDaemon(True)
    t2.setDaemon(True)

    #2.启动线程
    t1.start()
    t2.start()
    # print('end time %s'%time.ctime())
    print('主线程：%s========================\n'%time.ctime())
```

    listen music 爱的故事上集 Sat Jan  5 13:45:23 2019 musicThread
    
    主线程：Sat Jan  5 13:45:23 2019========================
    look movie 肖生克的救赎 Sat Jan  5 13:45:23 2019 movieThread
        
    listen music 爱的故事上集 Sat Jan  5 13:45:24 2019 musicThread
     
    look movie 肖生克的救赎 Sat Jan  5 13:45:24 2019 movieThread
    
    listen music 爱的故事上集 Sat Jan  5 13:45:25 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:25 2019 movieThread
    
    listen music 爱的故事上集 Sat Jan  5 13:45:26 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:26 2019 movieThread



​    


```python
def music(name,loop):
    for i in range(loop):
        print('listen music %s %s %s\n'%(name,time.ctime(),threading.Thread.getName(t1)))
        time.sleep(1)

def movie(name,loop):
    for i in range(loop):
        print('look movie %s %s %s\n'%(name,time.ctime(),threading.Thread.getName(t2)))
        time.sleep(1)

#1.创建多线程
# 线程1
t1 = threading.Thread(target= music,args=('爱的故事上集',4))
t1.setName('musicThread')  # 线程名称，方法一

# 线程2
t2 = threading.Thread(target= movie,args=('肖生克的救赎',4),name = 'movieThread')  # 线程名称，方法二

if __name__ == '__main__':
    #4.守护主线程，主线程结束杀死子线程
    t1.setDaemon(True)
    t2.setDaemon(True)

    #2.启动线程
    t1.start()
    t2.start()
    # print('end time %s'%time.ctime())

    # print(t1.ident)
    # print(t2.ident)

    # 3.join 可以对主线程进行阻塞，等所有的子线程运行结束在运行主线程
    t1.join()
    t2.join()

    print('主线程：%s========================\n'%time.ctime())
```

    listen music 爱的故事上集 Sat Jan  5 13:45:30 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:30 2019 movieThread
    
    listen music 爱的故事上集 Sat Jan  5 13:45:31 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:31 2019 movieThread
    
    listen music 爱的故事上集 Sat Jan  5 13:45:32 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:32 2019 movieThread
    
    listen music 爱的故事上集 Sat Jan  5 13:45:33 2019 musicThread
    
    look movie 肖生克的救赎 Sat Jan  5 13:45:33 2019 movieThread
    
    主线程：Sat Jan  5 13:45:34 2019========================


​    

### 加锁


```python
#不加锁的情况，最终结果不为0
balance = 0

def change(n):
    global balance
    balance+=n
    balance-=n

def run_thread(n):
    for i in range(1000000):
        change(n)

t1 = threading.Thread(target= run_thread,args=(4,))
t2 = threading.Thread(target= run_thread,args=(8,))

t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
```

    20



```python
#加锁
balance = 0

def change(n):
    global balance
    balance+=n
    balance-=n

lock = threading.Lock()  #获取线程锁
def run_thread(n):
    for i in range(1000000):
        #获取锁
        lock.acquire()
        try:
            change(n)
        finally:
            #释放锁
            lock.release()

t1 = threading.Thread(target= run_thread,args=(4,))
t2 = threading.Thread(target= run_thread,args=(8,))

t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
```

    0

## 多进程

### 单进程


```python
#-*- conding:utf-8 -*-
import time
import multiprocessing

def work_1(n):
    print('work_1 start=======================\n')
    for i in range(n):
        print('i love pyhton \n')
        time.sleep(1)
    print('work_1 end====================\n')


def work_2(n):
    print('work_2 start====================\n')
    for i in range(n):
        print('come on baby \n')
        time.sleep(1)
    print('work_2 end====================\n')

if __name__ == '__main__':
    work_1(3)
    work_2(3)
```

    work_1 start=======================
    
    i love pyhton 
    
    i love pyhton 
    
    i love pyhton 
    
    work_1 end====================
    
    work_2 start====================
    
    come on baby 
    
    come on baby 
    
    come on baby 
    
    work_2 end====================


​    

### 多进程


```python
#-*- conding:utf-8 -*-
import time
import multiprocessing

#多进程
def work_1(n):
    print('work_1 start=======================\n')
    for i in range(n):
        print('i love pyhton \n')
        time.sleep(1)
    print('work_1 end====================\n')


def work_2(n):
    print('work_2 start====================\n')
    for i in range(n):
        print('come on baby \n')
        time.sleep(1)
    print('work_2 end====================\n')

if __name__ == '__main__':
	# multiprocessing.set_start_method('spawn')
    p1 = multiprocessing.Process(target=work_1,args=(3,))
    p2 = multiprocessing.Process(target=work_2, args=(3,))

    p1.start()
    p2.start()
```

```
work_1 start=======================

i love pyhton 

work_2 start====================

come on baby 

i love pyhton 

come on baby 

i love pyhton 

come on baby 

work_1 end====================

work_2 end====================
```



### 加锁


```python
#-*- conding:utf-8 -*-
import time
import multiprocessing

#加锁
def work_1(n,lock):
    print('work_1 start===================\n')
    lock.acquire()
    for i in range(n):
        print('i love pyhton \n')
        time.sleep(1)
    print('work_1 end===============================\n')
    lock.release()

def work_2(n,lock):
    print('work_2 start================================\n')
    lock.acquire()
    for i in range(n):
        print('come on baby \n')
        time.sleep(1)
    print('work_2 end==========================\n')
    lock.release()

if __name__ == '__main__':
    lock=multiprocessing.Lock()
    p1 = multiprocessing.Process(target=work_1, args = (3,lock))
    p2 = multiprocessing.Process(target=work_2, args=(3,lock))

    p1.start()
    p2.start()
```

```
work_1 start===================

i love pyhton 

work_2 start================================

i love pyhton 

i love pyhton 

work_1 end===============================

come on baby 

come on baby 

come on baby 

work_2 end==========================
```



### 进程池


```python
# -*- conding:utf-8 -*-
import os
import multiprocessing
import time


def work(n):
    print('run work (%s) ,work id %s' % (n, os.getpid()))
    time.sleep(3)
    print('work (%s) stop ,work id %s' % (n, os.getpid()))


if __name__ == '__main__':
    print('Parent process %s.' % os.getpid())
    # 创建进程池
    p = multiprocessing.Pool(3)
    for i in range(5):
        # 创建5个进程，一次进入进程池
        p.apply_async(work, args=(i,))
    p.close()
    p.join()
```

```
Parent process 135724.
run work (0) ,work id 135784
run work (1) ,work id 135812
run work (2) ,work id 135792
work (0) stop ,work id 135784
run work (3) ,work id 135784
work (1) stop ,work id 135812
run work (4) ,work id 135812
work (2) stop ,work id 135792
work (3) stop ,work id 135784
work (4) stop ,work id 135812
```




```python
# -*- conding:utf-8 -*-
import multiprocessing
import time


def music(name, loop):
    print(time.ctime())
    for i in range(loop):
        time.sleep(2)
        print('您现在正在听的音乐是%s' % name)


def movie(name, loop):
    print(time.ctime())
    for i in range(loop):
        time.sleep(2)
        print('您现在正在看的电影是%s' % name)


if __name__ == '__main__':
    pool = multiprocessing.Pool(2)
    pool.apply_async(func=music, args=('花太香', 3))
    pool.apply_async(func=movie, args=('王牌特工', 4))
    pool.apply_async(func=music, args=('爱的故事上集', 2))
    pool.close()
    # pool.terminate()
    # 比较危险,不要轻易用,直接杀死进程池
    # join阻塞主进程,当子进程执行完毕的时候会继续往后执行,使用join必须在进程池使用terminate或者close
    pool.join()
    print('结束时间是%s' % time.ctime())
```

```
Sat Jan  5 14:26:13 2019
Sat Jan  5 14:26:13 2019
您现在正在听的音乐是花太香
您现在正在看的电影是王牌特工
您现在正在听的音乐是花太香
您现在正在看的电影是王牌特工
您现在正在听的音乐是花太香
Sat Jan  5 14:26:19 2019
您现在正在看的电影是王牌特工
您现在正在听的音乐是爱的故事上集
您现在正在看的电影是王牌特工
您现在正在听的音乐是爱的故事上集
结束时间是Sat Jan  5 14:26:23 2019
```



### Queue进程通信


```python
# -*- conding:utf-8 -*-
import multiprocessing
import time


# queue 跨进程通信
def put(q):
    for value in ['A', 'B', 'C']:
        print('发送 %s 到 queue...' % value)
        q.put(value)  # 通过put发送
        time.sleep(2)


## 读数据进程执行的代码:
def get(q):
    while True:
        value = q.get(True)  # 接受队列中的数据
        print('从 queue 接受 %s .' % value)


if __name__ == '__main__':
    # 父进程创建Queue，并传给各个子进程：
    q = multiprocessing.Queue()
    pw = multiprocessing.Process(target=put, args=(q,))
    pr = multiprocessing.Process(target=get, args=(q,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
```

```
发送 A 到 queue...
从 queue 接受 A .
发送 B 到 queue...
从 queue 接受 B .
发送 C 到 queue...
从 queue 接受 C .
```



### PIPE 管道通信


```python
# -*- conding:utf-8 -*-
import multiprocessing
import time


# PIPE 管道通信
def put(p):
    for value in ['A', 'B', 'C']:
        print('发送 %s 到 pipe...' % value)
        p[1].send(value)
        time.sleep(2)


# 读数据进程执行的代码:
def get(p):
    while True:
        value = p[0].recv()
        print('从 pipe 接受 %s .' % value)


if __name__ == '__main__':
    # 父进程创建Queue，并传给各个子进程：
    # p = multiprocessing.Pipe()
    p = multiprocessing.Pipe(duplex=False)  # 左收右发
    pw = multiprocessing.Process(target=put, args=(p,))
    pr = multiprocessing.Process(target=get, args=(p,))
    # 启动子进程pw，写入:
    pw.start()
    # 启动子进程pr，读取:
    pr.start()
    # 等待pw结束:
    pw.join()
    # pr进程里是死循环，无法等待其结束，只能强行终止:
    pr.terminate()
```

```
发送 A 到 pipe...
从 pipe 接受 A .
发送 B 到 pipe...
从 pipe 接受 B .
发送 C 到 pipe...
从 pipe 接受 C .
```



## 生产者和消费者模型


```python
# -*- conding:utf-8 -*-
import threading
import time
import queue

# 生产者消费者模型

def producer(name):  # 生产者
    count = 1
    while True:
        q.put("骨头%s" % count)
        print("[%s]生产了[骨头%d]" % (name, count))
        count += 1
        time.sleep(0.5)


def consumer(name):  # 消费者
    while True:
        print("[%s]取到[%s]并且吃了它..." % (name, q.get()))
        time.sleep(1)

        
if __name__=="__main__":
    q = queue.Queue(maxsize=10)

    p = threading.Thread(target=producer, args=("Tim",))
    c1 = threading.Thread(target=consumer, args=("King",))
    c2 = threading.Thread(target=consumer, args=("Wang",))

    p.start()
    c1.start()
    c2.start()
```

```
[Tim]生产了[骨头1]
[King]取到[骨头1]并且吃了它...
[Tim]生产了[骨头2]
[Wang]取到[骨头2]并且吃了它...
[Tim]生产了[骨头3]
[King]取到[骨头3]并且吃了它...
[Tim]生产了[骨头4]
[Wang]取到[骨头4]并且吃了它...
[Tim]生产了[骨头5]
[King]取到[骨头5]并且吃了它...

....
```



