# 【基础】条件语句：if

## 简单小例子

如果满足条件 A，则执行代码块 a，否则执行代码块 b。类似这样的控制流程语句，称之为条件语句。

它的基本形式是

```python
if 判断条件：
    执行语句……
else：
    执行语句……
```

举个最简单的例子

```python
>>> age = 20
>>> if age >=18:
...     print("已经是成年人")
... else:
...     print("还是未成年人")
...
已经是成年人
```

## 多条件语句

如果需要多次判断可以利用 `elif`，它的基本形式是

```python
if 判断条件1：
    执行语句……
elif 判断条件2：
    执行语句……
elif 判断条件3：
    执行语句……
else:
    执行语句……
```

举个最简单的例子

```python
>>> score = 75
>>>
>>> if score >=90:
...     print("优秀")
... elif score >= 80:
...     print("良好")
... elif score >= 70:
...     print("一般")
... elif score >= 60:
...     print("合格")
... else:
...     print("不合格")
...
一般
```

##  判断的条件

在 Python 中，值可以分为

- `假值` ：None、空列表、空集合、空字典，空元组、空字符串、0、False 等
- `真值` ：非空列表、非空集合、非空字典，非空元组、非空字符串、非 0 数值、True 等

`if` 和 `elif` 后面可以接一个表达式（上面已经举例过），也可以接一个对象。

只要这个对象是真假，代码就会进入相应分支，如果为对象为假值，则继续下一判断。

这边随便以 0 和 1 举例

```python
>>> aint = 1
>>> if aint:
...     print("ok")
...
ok
```

## 多个条件组合

在讲多个条件组合时，先来了解一下 Python 中的逻辑运算符。

以下假设变量 a 为 10, b为 20:

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |
| ------ | ---------- | ------------------------------------------------------------ | ----------------------- |
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |
| or     | x or y     | 布尔"或" - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |



学习完逻辑运算符，就可以开始写多条件语句

- 如果一个 if 条件需要同时满足多个条件，那么可以使用 `and`  或者 `&`
- 如果一个 if 条件只需要满足多个条件的其中一个，那么可以使用 `or` 或者 `|`
- 如果一个 if 要求不满足某个条件，那么可以使用 `not` 或者 `!`

```python
# 需要同时满足条件 A 和条件 B
if 条件A and 条件B:
	...
  
# 只需要满足条件A或者条件B即可
if 条件A or 条件B:
	...
  
# 要求不满足条件A
if not 条件A:
	...
```

# 【基础】循环语句：for

for 循环可以遍历任何序列的项目，如一个列表或者一个字符串。

它的基本语法是

```python
for 元素 in 序列对象:
   代码块
```

## 普通循环

直接上案例

```python
>>> phones = ["Apple", "Huawei", "Xiaomi"]
>>> for phone in phones:
...     print("当前手机是: " + phone)
...
当前手机是: Apple
当前手机是: Huawei
当前手机是: Xiaomi
```

## 带索引循环

如果想在循环的时候，把索引也取出来，可以加一个 `enumerate` 函数

```python
>>> phones = ["Apple", "Huawei", "Xiaomi"]
>>>
>>> for index,phone in enumerate(phones):
...     print("我的第 {} 把手机是: {}".format(index+1, phone))
...
我的第 1 把手机是: Apple
我的第 2 把手机是: Huawei
我的第 3 把手机是: Xiaomi
```

##  break 中断

正常情况下，我们都需要 for 循环能够全部循环完，但在某些情况下，需要中断循环的执行，中断循环使用的是 `break` 关键字。

举个例子

```python
>>> for i in [0, 1, 2]:
...     if i == 1:
...         print(f"当前的数是 {i}, 将退出循环")
...         break
...     print("当前的数是 " + str(i))
...
当前的数是 0
当前的数是 1, 将退出循环
```

##  continue 下一循环

在有些循环中，不需要把 for 的循环体内的代码全部执行完毕，这种情况下，可以使用 `continue` 关键字，直接进入下一循环。

举个例子，下面的循环中当 i 等于 1 时，就直接跳过了循环。

```python
>>> for i in [0, 1, 2]:
...     if i == 1:
...         continue
...     print("当前的数是 " + str(i))
...
当前的数是 0
当前的数是 2
```

##  for - else 循环

其实在 for 循环语句的后面，可以加一个 else 分支，当代码在 for 循环体中**正常执行完**，自然就会走到 else 分支中。

那么什么叫做 **正常执行完** 呢？就是只要不通过 break 语句中断的，都算正常执行完。

先以 continue 为例，所有的循环都非常正常，会走到 else 分支

```python
>>> for i in [0, 1, 2]:
...     if i == 1:
...         continue
...     print("当前的数是 " + str(i))
... else:
...     print("循环非常正常")
...
当前的数是 0
当前的数是 2
循环非常正常
```

再把 `continue`  改成 `break` 后，发现不会走到 else 分支

```python
>>> for i in [0, 1, 2]:
...     if i == 1:
...         break
...     print("当前的数是 " + str(i))
... else:
...     print("循环非常正常")
...
当前的数是 0
```



# 【基础】循环语句：while

while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。

其基本形式为：

```python
while 判断条件：
    执行语句
```

##  普通的循环

直接上案例

```python
age = 1
while age <= 3:
    print(f"孩子当前 {age} 岁，还不能上幼儿园")
    age += 1

print("年龄够了，可以上幼儿园了")
```

运行后，输出结果

```
孩子当前 1 岁，还不能上幼儿园
孩子当前 2 岁，还不能上幼儿园
孩子当前 3 岁，还不能上幼儿园
年龄够了，可以上幼儿园了
```

##  无限的循环

当 while 后面的条件一直满足且循环体内一直没有 break ，此时 while 就会变成死循环，就是写 while 循环时千万要注意的。

会造成死循环，无非两种情况：

1、 使用 while True，而且循环体内又没有 break 或者 走不到 break

```python
age = 1
while True:
    age += 1
```

2、 使用一个永远都会成立的判断条件，而且循环体内又没有 break 或者 走不到 break

```python
age = 1
while age > 0:
    age += 1
```

##  while - else 语句

和 for 循环一样， while 循环同样可以加一个 else 分支，当代码在 while 循环体中**正常执行完**，就会走到 else 分支中。

那么什么叫做 **正常执行完** 呢？就是只要不通过 break 语句中断的，都算正常执行完。

```python
>>> age = 1
>>> while age <= 3:
...     print(f"我已经 {age} 岁了")
...     age += 1
... else:
...     print("可以上幼儿园了")
...
我已经 1 岁了
我已经 2 岁了
我已经 3 岁了
可以上幼儿园了
```

如果在循环体内加 break ，就算是异常退出

```python
>>> age = 1
>>> while age <= 3:
...     if age == 2:
...         break
...     print(f"我已经 {age} 岁了")
...     age += 1
... else:
...     print("可以上幼儿园了")
...
我已经 1 岁了
```



#  【进阶】五种推导式

推导式（英文名：comprehensions），也叫解析式，是Python的一种独有特性。

推导式是可以从一个数据序列构建另一个新的数据序列的结构体。

总共有四种推导式：

1. 列表(list)推导式

2. 字典(dict)推导式

3. 集合(set)推导式
4. 生成器推导式

##  列表推导式

列表推导式的基本格式

```python
new_list = [expression for_loop_expression if condition]
```

举个例子。

我想找出一个数值列表中为偶数的元素，并组成新列表，通常不用列表推导式，可以这么写

```python
old_list = [0,1,2,3,4,5]

new_list = []
for item in old_list:
    if item % 2 == 0:
        new_list.append(item)

print(new_list) # output: [0, 2, 4]
```

一个简单的功能，写的代码倒是不少。

如果使用了列表推导式，那就简洁多了，而且代码还变得更加易读了。

```python
>>> old_list = [0,1,2,3,4,5]
>>>
>>> new_list = [item for item in old_list if item % 2 == 0]
>>> print(new_list) # output: [0, 2, 4]
[0, 2, 4]
```

##  字典推导式

字典推导式的基本格式，和 列表推导式相似，只是把 `[]` 改成了 `{}`，并且组成元素有两个：key 和 value，要用 `key_expr: value_expr ` 表示。

```python
new_dict ={ key_expr: value_expr for_loop_expression if condition }
```

举个例子。

我想从一个包含所有学生成绩信息的字典中，找出数学考满分的同学。

```python
old_student_score_info = {
    "Jack": {
        "chinese": 87,
        "math": 92,
        "english": 78
    },
    "Tom": {
        "chinese": 92,
        "math": 100,
        "english": 89
    }
}

new_student_score_info = {name: scores for name, scores in old_student_score_info.items() if scores["math"] == 100}
print(new_student_score_info)
# output: {'Tom': {'chinese': 92, 'math': 100, 'english': 89}}
```

##  集合推导式

集合推导式跟列表推导式也是类似的。 唯一的区别在于它使用大括号`{}`，组成元素也只要一个。

基本格式

```python
new_set = { expr for_loop_expression if condition }
```

举个例子

我想把一个数值列表里的数进行去重处理

```python
>>> old_list = [0,0,0,1,2,3]
>>>
>>> new_set = {item for item in old_list}
>>> print(new_set)
{0, 1, 2, 3}
```

##  生成器推导式

生成器推导式跟列表推导式，非常的像，只是把 `[]` 换成了 `()`

- 列表推导式：生成的是新的列表
- 生成器推导式：生成的是一个生成器

直接上案例了，找出一个数值列表中所有的偶数

```python
>>> old_list = [0,1,2,3,4,5]
>>> new_list = (item for item in old_list if item % 2 == 0)
>>> new_list
<generator object <genexpr> at 0x10292df10>
>>> next(new_list)
0
>>> next(new_list)
2
```

##  嵌套推导式

for 循环可以有两层，甚至更多层，同样的，上面所有的推导式，其实都可以写成嵌套的多层推导式。

但建议最多嵌套两层，最多的话，代码就会变得非常难以理解。

举个例子。

我想打印一个乘法表，使用两个for可以这样写

```python
for i in range(1, 10):
    for j in range(1, i+1):
        print('{}x{}={}\t'.format(j, i, i*j), end='')
    print("")
```

输出如下

```
1x1=1	
1x2=2	2x2=4	
1x3=3	2x3=6	3x3=9	
1x4=4	2x4=8	3x4=12	4x4=16	
1x5=5	2x5=10	3x5=15	4x5=20	5x5=25	
1x6=6	2x6=12	3x6=18	4x6=24	5x6=30	6x6=36	
1x7=7	2x7=14	3x7=21	4x7=28	5x7=35	6x7=42	7x7=49	
1x8=8	2x8=16	3x8=24	4x8=32	5x8=40	6x8=48	7x8=56	8x8=64	
1x9=9	2x9=18	3x9=27	4x9=36	5x9=45	6x9=54	7x9=63	8x9=72	9x9=81
```

如果使用嵌套的列表推导式，可以这么写

```python
>>> print('\n'.join([' '.join(['%2d *%2d = %2d' % (col, row, col * row) for col in range(1, row + 1)]) for row in range(1, 10)]))

 1 * 1 =  1
 1 * 2 =  2  2 * 2 =  4
 1 * 3 =  3  2 * 3 =  6  3 * 3 =  9
 1 * 4 =  4  2 * 4 =  8  3 * 4 = 12  4 * 4 = 16
 1 * 5 =  5  2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
 1 * 6 =  6  2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30  6 * 6 = 36
 1 * 7 =  7  2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35  6 * 7 = 42  7 * 7 = 49
 1 * 8 =  8  2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40  6 * 8 = 48  7 * 8 = 56  8 * 8 = 64
 1 * 9 =  9  2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45  6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81
```

