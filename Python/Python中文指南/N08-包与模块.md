#  【基础】什么是包、模块和库？

Python 中除了函数库以外，还有非常多且优秀的第三方库、包、模块。

那么问题就来了，库、模块和包各是什么意思？

它们之间有什么区别呢？今天就一起来学习下。

##  模块

以 `.py` 为后缀的文件，我们称之为 模块，英文名 Module。

模块让你能够有逻辑地组织你的 Python 代码段，把相关的代码分配到一个模块里能让你的代码更好用，更易懂。

假设现在有一个名为 `demo.py` 的文件，文件内容如下

```python
name="Python编程时光"
print("导入成功")
```

直接使用 import 语句就可以导入，导入之后，就可以使用 `模块名.变量名` 的方式访问这个变量。

```python
>>> import demo
导入成功
>>> demo.name
'Python编程时光'
>>>
```

在导入模块的时候，有一个非常重要的全局变量需要掌握，那就是  `__name__` 这个变量。

现在把 `demo.py` 的内容改成

```python
$ cat demo.py
print("__name__ 的值为: " + __name__)
```

- 当模块被直接执行时， `__name__` 的值为 `__main__`

```python
$ python demo.py
__name__ 的值为: __main__
```

- 当模块被导入时， `__name__`  的值为 模块名

```python
>>> import demo
__name__ 的值为: demo
```

当该模块被导入后，会在当前目录下产生一个 叫做 `__pycache__` 的缓存文件夹。

```shell
$ tree
.
├── __pycache__
│   └── demo.cpython-39.pyc
└── demo.py
```

这个文件夹有什么用呢？

简单来说，当你导入模块的时候，Python解释器会把模块的代码编译成字节码，并放入 `__pycache__`文件夹中。

这样以后再次运行的话，如果被调用的模块未发生改变，那就直接跳过编译这一步，直接去`__pycache__`文件夹中去运行相关的 *.pyc 文件，大大缩短了项目运行前的准备时间。

##  包

在早一点的 Python 版本（Python 3.3 之前）中，如果一个文件夹下有一个 `__init__.py` 文件，那我们就称之为包，英文名 Package。

在后来的 Python 版本（Python 3.3 开始）中，就没有这个要求了，只要是文件夹就可以当做包，我们称之为空间命名包，为做区分，我把上面那种包称之为 传统包。

考虑到很多人其实并不需要接触到空间命名包，所以我将空间命名包的内容单独放在一节里，为选读章节。

今天这节里主要讲讲传统包的内容。

传统包里的  `__init__.py` 可以为空文件，但一定要有该文件，它是包的标志性文件，在需要情况下可以在里面进行一些包的初始化工作。

```shell
$ tree
.
└── demo
    ├── __init__.py
    ├── bar.py
    └── foo.py
```

一个包里可以有多个模块，比如上面的 `foo.py` 和  `bar.py` 都属于 demo 模块。

如果要使用这些模块，就需要这样导入

```python
>>> import demo.foo
成功导入 foo.py
>>> import demo.bar
成功导入 bar.py
```

或者这样

```python
>>> from demo import foo
成功导入 foo.py
>>> from demo import bar
成功导入 bar.py
```



##  库

Python 库是指一定功能的代码集合，通常认为他是一个完整的项目打包。

库->包->模块，是从大到小的层级关系！

- 库：一个库可能由多个包和模块组成
- 包：一个包可能由多个模块组成
- 模块：一堆函数、类、变量的集合

#  【基础】安装第三方包的八种方法

##  使用 easy_install

`easy_install` 这应该是最古老的包安装方式了，目前基本没有人使用了。下面是 `easy_install` 的一些安装示例

```shell
# 通过包名，从PyPI寻找最新版本，自动下载、编译、安装
$ easy_install pkg_name

# 通过包名从指定下载页寻找链接来安装或升级包
$ easy_install -f http://pythonpaste.org/package_index.html 

# 指定线上的包地址安装
$ easy_install http://example.com/path/to/MyPackage-1.2.3.tgz

# 从本地的 .egg 文件安装
$ easy_install xxx.egg
```

##  使用 pip install

pip 是最主流的包管理方案，使用 `pip install xxx` 就可以从 PYPI 上搜索并安装 `xxx` （如果该包存在的话）。

下面仅列出一些常用的 `pip install `的安装示例

```shell
$ pip install requests

# 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下
$ pip install --no-index --find-links=/local/wheels pkg

# 所安装的包的版本为 2.1.2
$ pip install pkg==2.1.2

# 所安装的包必须大于等于 2.1.2
$ pip install pkg>=2.1.2

# 所安装的包必须小于等于 2.1.2
$ pip install pkg<=2.1.2
```

更多 pip 的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：[8.8 pip 的详细使用指南](https://python.iswbm.com/c08/c08_08.html)

##  使用 pipx

pipx 是一个专门用于安装和管理 cli 应用程序的工具，使用它安装的 Python 包会单独安装到一个全新的独有虚拟环境。

由于它是一个第三方工具，因此在使用它之前，需要先安装

```shell
$ python3 -m pip install --user pipx
$ python3 -m userpath append ~/.local/bin
Success!
```

安装就可以使用 pipx 安装cli 工具了。

```shell
# 创建虚拟环境并安装包
$ pipx install pkg
```

更多 pipx 的使用方法，可参考本系列教程后面的文章，介绍得非常清楚：[12.4 pipx 安装程序的使用指南](https://python.iswbm.com/c12/c12_04.html)

##  使用 setup.py

如果你有编写 setup.py 文件，可以使用如下命令直接安装

```python
# 使用源码直接安装
$ python setup.py install
```

##  使用 yum

Python 包在使用 `setup.py` 构建的时候（具体内容可阅读后面的内容：[8.15 超详细讲解 setup.py 的编写](https://python.iswbm.com/c08/c08_15.html)），对于包的发布格式有多种选项，其中有一个选项是 `bdist_rpm`，以这个选项发布出来的包是 `rpm` 的包格式。

```shell
# 发布 rpm 包
$ python setup.py bdist_rpm
```

对于`rpm` 这种格式，你需要使用 `yum install xxx` 或者 `rpm install xxx` 来安装。

```shell
# 使用 yum 安装
$ yum install pkg

# 使用 rpm 安装
$ rpm -ivh pkg
```

##  使用 pipenv

如果你在使用 pipenv 创建的虚拟环境中，可以使用下面这条命令把包安装到虚拟环境中

```shell
$ pipenv install pkg
```

##  使用 poetry

如果你有使用 poetry 管理项目依赖，那么可以使用下面这条命令安装包

```shell
# 直接安装包
$ poetry add pkg

# 指定为开发依赖
$ poetry add pytest --dev
```

##  使用 curl + 管道

有一些第三方工具包提供的安装方法，是直接使用 curl 配置管道来安装，比如上面提到的 poetry 就可以用这种方法安装。

```shell
$ curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python
```

#  【基础】导入单元的构成

导入单元有多种，可以是模块、包及变量等。

对于这些基础的概念，对于新手还是有必要介绍一下它们的区别。

**模块**：类似 \*.py，\*.pyc， \*.pyd ，\*.so，\*.dll 这样的文件，是 Python 代码载体的最小单元。

**包** 还可以细分为两种:

- Regular packages：是一个带有 `__init__.py`  文件的文件夹，此文件夹下可包含其他子包，或者模块
- Namespace packages

关于 Namespace packages，有的人会比较陌生，我这里摘抄官方文档的一段说明来解释一下。

Namespace packages 是由多个 部分 构成的，每个部分为父包增加一个子包。 各个部分可能处于文件系统的不同位置。 部分也可能处于 zip 文件中、网络上，或者 Python 在导入期间可以搜索的其他地方。 命名空间包并不一定会直接对应到文件系统中的对象；它们有可能是无实体表示的虚拟模块。

命名空间包的 `__path__ ` 属性不使用普通的列表。 而是使用定制的可迭代类型，如果其父包的路径 (或者最高层级包的 sys.path) 发生改变，这种对象会在该包内的下一次导入尝试时自动执行新的对包部分的搜索。

命名空间包没有 `parent/__init__.py` 文件。 实际上，在导入搜索期间可能找到多个 parent 目录，每个都由不同的部分所提供。 因此 parent/one 的物理位置不一定与 parent/two 相邻。 在这种情况下，Python 将为顶级的 parent 包创建一个命名空间包，无论是它本身还是它的某个子包被导入。

#  【基础】导入包的标准写法

当我们 import 导入模块或包时，Python 提供两种导入方式：

- 相对导入（relative import ）：from . import B 或 from ..A import B，其中.表示当前模块，..表示上层模块
- 绝对导入（absolute import）：import foo.bar 或者 from foo import bar

你可以根据实际需要进行选择，但有必要说明的是，在早期的版本（ Python2.6 之前），Python 默认使用的相对导入。而后来的版本中（ Python2.6 之后），都以绝对导入为默认使用的导入方式。

使用绝对路径和相对路径各有利弊：

- 当你在开发维护自己的项目时，应当使用相对路径导入，这样可以避免硬编码带来的麻烦。
- 而使用绝对路径，会让你模块导入结构更加清晰，而且也避免了重名的包冲突而导入错误。

在 PEP8 中对模块的导入提出了要求，遵守 PEP8规范能让你的代码更具有可读性，我这边也列一下：

- import 语句应当分行书写

```python
# bad
import os,sys

# good
import os
import sys
```

- import语句应当使用absolute import

```python
# bad
from ..bar import  Bar

# good
from foo.bar import test
```

- import语句应当放在文件头部，置于模块说明及docstring之后，全局变量之前

- import语句应该按照顺序排列，每组之间用一个空格分隔，按照内置模块，第三方模块，自己所写的模块调用顺序，同时每组内部按照字母表顺序排列

```python
# 内置模块
import os
import sys

# 第三方模块
import flask

# 本地模块
from foo import bar
```

# 【进阶】常规包与空间命名包

##  常规包

在 Python 3.3 之前或者说 Python 2 中，一个包想要被导入使用，那么该包内必须要有 `__init__.py` 文件，这个文件是 Python 识别一个文件夹是否是一个 Python 的重要标志。

举个例子，现在有如下的目录树，demo 及子文件夹 foo 和 bar 下都有  `__init__.py` 文件。

```shell
$ tree demo/
demo/
├── bar
│   └── __init__.py
├── foo
│   └── __init__.py
└── __init__.py
```

在该目录下进入 Python Console 模式，然后就可以正常导入了

```python
>>> import demo
>>> import demo.bar
>>> import demo.foo
```

如果此时我把 demo 目录下的  `__init__.py` 删除

```python
$ tree demo/
demo/
├── bar
│   └── __init__.py
└── foo
    └── __init__.py
```

再导入就会报错。

```python
>>> import demo
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ImportError: No module named demo
```

##  命名空间包

在 Python 3.3 之后（[PEP 420](https://www.python.org/dev/peps/pep-0420/)），即使一个文件夹中没有定义 `__init__.py`，也是可以被导入的，只不过它不是以 Python 包的形式导入，而是以命名空间包 (Namespace package) 的形式被导入，而这一特性是在 Python 3.3 被引入的。

比如还是上面的目录结构：

```shell
$ tree demo/
demo/
├── bar
│   └── __init__.py
└── foo
    └── __init__.py
```

在 Python 3 下进入 Python Console 模式，发现导入是正常的

```python
>>> import demo
>>> import demo.foo
>>> import demo.bar
>>> 
```

使用 `__path__` 查看一下，发现 demo 不再是一个常规包了，而是一个 namespace package 

```python
>>> demo
<module 'demo' (namespace)>
>>>
>>> demo.__path__
_NamespacePath(['/root/python/demo'])
```

##  空间命名包的好处

利用命名空间包这个技术，可以用来导入目录分散的代码。

比如有如下的目录树

```shell
$ tree
.
├── xc-pkg
│   └── demo
│       └── foo
│           └── __init__.py
└── xm-pkg
    └── demo
        └── bar
            └── __init__.py
```

在这 `xc-pkg` 和 `xm-pkg` 这两个目录里，都有着共同的命名空间 demo。这时候再导入这两个包的时候，发现这两个包被合并到一起了

```python
>>> import sys
>>> sys.path.extend(['xm-pkg', 'xc-pkg'])
>>> 
>>> import demo.foo
>>> import demo.bar
>>> demo
<module 'demo' (namespace)>
```

在这里工作的机制被称为`命名空间包`的一个特征。从本质上讲，`命名空间包`是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。

`命名空间包`的关键是确保顶级目录中没有 `__init__.py` 文件来作为共同的命名空间。缺失 `__init__.py` 文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其 `__path__` 变量中。

```python
>>> demo.__path__
_NamespacePath(['xm-pkg/demo', 'xc-pkg/demo'])
```

一个包是否被作为一个包命名空间的主要方法是检查其 `__file__` 属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的 namespace 这个词体现出来。

```python
>>> demo
<module 'demo' (namespace)>
>>>
>>> demo.__file__
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: module 'demo' has no attribute '__file__'
>>> 
```

#  【进阶】花式导包的八种方法

##  直接 import

人尽皆知的方法，直接导入即可

```python
>>> import os
>>> os.getcwd()
'/home/wangbm'
```

与此类似的还有，不再细讲

```python
import ...
import ... as ...
from ... import ...
from ... import ... as ...
```

一般情况下，使用 `import` 语句导入模块已经够用的。

但是在一些特殊场景中，可能还需要其他的导入方式。

下面我会一一地给你介绍。

##  使用 \__import__

`__import__` 函数可用于导入模块，import 语句也会调用函数。其定义为：

```
__import__(name[, globals[, locals[, fromlist[, level]]]])
```

参数介绍：

- name (required): 被加载 module 的名称
- globals (optional): 包含全局变量的字典，该选项很少使用，采用默认值 global()
- locals (optional): 包含局部变量的字典，内部标准实现未用到该变量，采用默认值 - local()
- fromlist (Optional): 被导入的 submodule 名称
- level (Optional): 导入路径选项，Python 2 中默认为 -1，表示同时支持 absolute import 和 relative import。Python 3 中默认为 0，表示仅支持 absolute import。如果大于 0，则表示相对导入的父目录的级数，即 1 类似于 '.'，2 类似于 '..'。

使用示例如下：

```python
>>> os = __import__('os')
>>> os.getcwd()
'/home/wangbm'
```

如果要实现 `import xx as yy` 的效果，只要修改左值即可

如下示例，等价于 `import os as myos`：

```python
>>> myos = __import__('os')
>>> myos.getcwd()
'/home/wangbm'
```



上面说过的 `__import__` 是一个内建函数，既然是内建函数的话，那么这个内建函数必将存在于 `__buildins__` 中，因此我们还可以这样导入 os 的模块：

```python
>>> __builtins__.__dict__['__import__']('os').getcwd()
'/home/wangbm'
```



##  使用 importlib 模块

importlib 是 Python 中的一个标准库，importlib 能提供的功能非常全面。

它的简单示例：

```python
>>> import importlib
>>> myos=importlib.import_module("os")
>>> myos.getcwd()
'/home/wangbm'
```

如果要实现 `import xx as yy`效果，可以这样

```python
>>> import importlib
>>> 
>>> myos = importlib.import_module("os")
>>> myos.getcwd()
'/home/wangbm'
```



##  使用 imp 模块

`imp` 模块提供了一些 import 语句内部实现的接口。例如模块查找（find_module）、模块加载（load_module）等等（模块的导入过程会包含模块查找、加载、缓存等步骤）。可以用该模块来简单实现内建的 `__import__` 函数功能：

```python
>>> import imp
>>> file, pathname, desc = imp.find_module('os')
>>> myos = imp.load_module('sep', file, pathname, desc)
>>> myos
<module 'sep' from '/usr/lib64/python2.7/os.pyc'>
>>> myos.getcwd()
'/home/wangbm'
```

从 python 3 开始，内建的 reload 函数被移到了 imp 模块中。而从 Python 3.4 开始，imp 模块被否决，不再建议使用，其包含的功能被移到了 importlib 模块下。即从 Python 3.4 开始，importlib 模块是之前 imp 模块和 importlib 模块的合集。



##  使用 execfile

在 Python 2 中有一个 execfile 函数，利用它可以用来执行一个文件。

语法如下：

```
execfile(filename[, globals[, locals]])
```

参数有这么几个：

- filename：文件名。
- globals：变量作用域，全局命名空间，如果被提供，则必须是一个字典对象。
- locals：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。

```python
>>> execfile("/usr/lib64/python2.7/os.py")
>>> 
>>> getcwd()
'/home/wangbm'
```



##  使用 exec 执行

`execfile` 只能在 Python2 中使用，Python 3.x 里已经删除了这个函数。

但是原理值得借鉴，你可以使用 open ... read  读取文件内容，然后再用 exec 去执行模块。

示例如下：

```python
>>> with open("/usr/lib64/python2.7/os.py", "r") as f:
...     exec(f.read())
... 
>>> getcwd()
'/home/wangbm'
```



##  import_from_github_com

有一个包叫做 **import_from_github_com**，从名字上很容易得知，它是一个可以从 github 下载安装并导入的包。为了使用它，你需要做的就是按照如下命令使用pip 先安装它。

```shell
$ python3 -m pip install import_from_github_com
```

这个包使用了PEP 302中新的引入钩子，允许你可以从github上引入包。这个包实际做的就是安装这个包并将它添加到本地。你需要 Python 3.2 或者更高的版本，并且 git 和 pip 都已经安装才能使用这个包。

pip 要保证是较新版本，如果不是请执行如下命令进行升级。

```shell
$ python3 -m pip install --upgrade pip
```

确保环境 ok 后，你就可以在 Python shell 中使用 import_from_github_com

示例如下

```python
>>> from github_com.zzzeek import sqlalchemy
Collecting git+https://github.com/zzzeek/sqlalchemy
Cloning https://github.com/zzzeek/sqlalchemy to /tmp/pip-acfv7t06-build
Installing collected packages: SQLAlchemy
Running setup.py install for SQLAlchemy ... done
Successfully installed SQLAlchemy-1.1.0b1.dev0
>>> locals()
{'__builtins__': <module 'builtins' (built-in)>, '__spec__': None,
'__package__': None, '__doc__': None, '__name__': '__main__',
'sqlalchemy': <module 'sqlalchemy' from '/usr/local/lib/python3.5/site-packages/\
sqlalchemy/__init__.py'>,
'__loader__': <class '_frozen_importlib.BuiltinImporter'>}
>>>
```

看了 import_from_github_com的源码后，你会注意到它并没有使用importlib。实际上，它的原理就是使用 pip 来安装那些没有安装的包，然后使用Python的`__import__()`函数来引入新安装的模块。



##  远程导入模块

在后面有一篇文章里，深入剖析了导入模块的内部原理，并在最后手动实现了从远程服务器上读取模块内容，并在本地成功将模块导入的导入器。

具体内容非常的多，你可以点击这个[链接](http://mp.weixin.qq.com/s?__biz=MzIzMzMzOTI3Nw==&mid=2247484838&idx=1&sn=1e6fbf5d7546902c6965c60383f7b639&chksm=e8866544dff1ec52e01b6c9a982dfa150b8e34ad472acca35201373dc51dadb5a8630870982a&scene=21#wechat_redirect)进行深入学习。

示例代码如下：

```python
# 新建一个 py 文件（my_importer.py），内容如下
import sys
import importlib
import urllib.request as urllib2

class UrlMetaFinder(importlib.abc.MetaPathFinder):
    def __init__(self, baseurl):
        self._baseurl = baseurl


    def find_module(self, fullname, path=None):
        if path is None:
            baseurl = self._baseurl
        else:
            # 不是原定义的url就直接返回不存在
            if not path.startswith(self._baseurl):
                return None
            baseurl = path

        try:
            loader = UrlMetaLoader(baseurl)
            return loader
        except Exception:
            return None

class UrlMetaLoader(importlib.abc.SourceLoader):
    def __init__(self, baseurl):
        self.baseurl = baseurl

    def get_code(self, fullname):
        f = urllib2.urlopen(self.get_filename(fullname))
        return f.read()

    def get_data(self):
        pass

    def get_filename(self, fullname):
        return self.baseurl + fullname + '.py'

def install_meta(address):
    finder = UrlMetaFinder(address)
    sys.meta_path.append(finder)
```

并且在远程服务器上开启 http 服务（为了方便，我仅在本地进行演示），并且手动编辑一个名为 my_info 的 python 文件，如果后面导入成功会打印 `ok`。

```shell
$ mkdir httpserver && cd httpserver
$ cat>my_info.py<EOF
name='wangbm'
print('ok')
EOF
$ cat my_info.py
name='wangbm'
print('ok')
$
$ python3 -m http.server 12800
Serving HTTP on 0.0.0.0 port 12800 (http://0.0.0.0:12800/) ...
...
```

一切准备好，验证开始。

```python
>>> from my_importer import install_meta
>>> install_meta('http://localhost:12800/') # 往 sys.meta_path 注册 finder
>>> import my_info  # 打印ok，说明导入成功
ok
>>> my_info.name  # 验证可以取得到变量
'wangbm'
```



好了，8 种方法都给大家介绍完毕，对于普通开发者来说，其实只要掌握 import 这种方法足够了，而对于那些想要自己开发框架的人来说，深入学习` __import__ `以及 importlib 是非常有必要的。



#   【进阶】包导入的三个冷门知识点

##  使用 \__all__  控制可被导入的变量

使用 `from module import *`  默认情况下会导入 module 里的所有变量，若你只想从模块中导入其中几个变量，可以在 module 中使用 `__all__` 来控制想要被其他模块导入的变量。

```python
# profile.py
name='小明'
age=18

__all__=['name']
```

打开 python console 验证一下

```python
>>> from profile import *
>>> print(name)
小明
>>> print(age)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'age' is not defined
```

`__all__` 仅对于使用`from module import *`  这种情况适用。

它经常在一个包的 `__init__.py` 中出现。



##  命名空间包的神奇之处

命名空间包，一个陌生的名字。

与我们熟悉的常规包不同的是，它没有 `__init__.py` 文件。

更为特殊的是，它可以跨空间地将两个不相邻的子包，合并成一个虚拟机的包，我们将其称之为 `命名空间包`。

例如，一个项目的部分代码布局如下

```
foo-package/
    spam/
        blah.py

bar-package/
    spam/
        grok.py
```

在这2个目录里，都有着共同的命名空间spam。在任何一个目录里都没有\__init__.py文件。

让我们看看，如果将foo-package和bar-package都加到python模块路径并尝试导入会发生什么？

```python
>>> import sys
>>> sys.path.extend(['foo-package', 'bar-package'])
>>> import spam.blah
>>> import spam.grok
>>>
```



当一个包为命名空间包时，他就不再和常规包一样具有 `__file_` 属性，取而代之的是 `__path__`

```python
>>> import sys
>>> sys.path.extend(['foo-package', 'bar-package'])
>>> import spam.blah
>>> import spam.grok
>>> spam.__path__
_NamespacePath(['foo-package/spam', 'bar-package/spam'])
>>> spam.__file__
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
AttributeError: 'module' object has no attribute '__file__'
```



##  模块重载中的一个坑

由于有 sys.modules 的存在，当你导入一个已导入的模块时，实际上是没有效果的。

为了达到模块的重载，有的人会将已导入的包从 sys.modules 中移除后再导入

就像下面这样子

```python
>>> import foo.bar
successful to be imported
>>>
>>> import foo.bar
>>>
>>> import sys
>>> sys.modules['foo.bar']
<module 'foo.bar' from '/Users/MING/Code/Python/foo/bar.py'>
>>> del sys.modules['foo.bar']
>>>
>>> import foo.bar
successful to be imported
```

上面的例子里我使用的是`import foo.bar` ，如果你使用的是  `from foo import bar` 这种导入形式，会发现重载是同样是无效的。

这应该算是一个小坑，不知道的人，会掉入坑中爬不出来。

```python
>>> import foo.bar
successful to be imported
>>>
>>> import foo.bar
>>>
>>> import sys
>>> del sys.modules['foo.bar']
>>> from foo import bar
>>>
```

因此，在生产环境中可能需要避免重新加载模块。而在调试模式中，它会提供一定的便利，但你要知道这个重载的弊端，以免掉入坑里。



#  【基础】pip 的超全使用指南

所有的 Python 开发者都清楚，Python 之所以如此受欢迎，能够在众多高级语言中，脱颖而出，除了语法简单，上手容易之外，更多还要归功于 Python 生态的完备，有数以万计的 Python 爱好者愿意以 Python 为基础封装出各种有利于开发的第三方工具包。

这才使用我们能够以最快的速度开发出一个满足基本需要的项目，而不是每次都重复造轮子。

Python 从1991年诞生到现在，已经过去28个年头了，这其间产生了数以万计的第三方包，且每个包都会不断更新，会有越来越多的版本。

当你在一个复杂的项目环境中，如果没有一个有效的依赖包管理方案，项目的维护将会是一个大问题。

pip 是官方推荐的包管理工具，在大多数开发者眼里，pip 几乎是 Python 的标配。

当然也有其他的包管理工具

- **distutils**：仅用于打包和安装，严格来讲不算是包管理工具

- **setuptools**：distutils的增强版，扩展了distutils，提供更多的功能，引入包依赖的管理，easy_install就是它的一个命令行工具，引入了 egg 的文件格式。

- **Pipenv**：一个集依赖包管理（pip）及虚拟环境管理（virtualenv）的工具

- 还有其他的，这里不一一列出。

今天的主角是 pip ，大家肯定不会陌生。但我相信不少人，只是熟悉几个常用的用法，而对于其他几个低频且实用的用法，却知之甚少，这两天，我查阅官方文档，把这些用法整理了一下，应该是网络上比较全的介绍。

##  查询软件包

查询当前环境安装的所有软件包

```shell
$ pip list
```

查询 pypi 上含有某名字的包

```shell
$ pip search pkg
```

查询当前环境中可升级的包

```shell
$ pip list --outdated
```

查询一个包的详细内容

```shell
$ pip show pkg
```

##  下载软件包

在不安装软件包的情况下下载软件包到本地

```shell
$ pip download --destination-directory /local/wheels -r requirements.txt
```

下载完，总归是要安装的，可以指定这个目录中安装软件包，而不从 pypi 上安装。

```shell
$ pip install --no-index --find-links=/local/wheels -r requirements.txt
```

当然你也从你下载的包中，自己构建生成 wheel 文件

```shell
$ pip install wheel
$ pip wheel --wheel-dir=/local/wheels -r requirements.txt
```



##  安装软件包

使用 `pip install <pkg>` 可以很方便地从 pypi 上搜索下载并安装 python 包。

如下所示

```shell
$ pip install requests
```

这是安装包的基本格式，我们也可以为其添加更多参数来实现不同的效果。

###  只从本地安装，而不从 pypi 安装

```shell
# 前提你得保证你已经下载 pkg 包到 /local/wheels 目录下
$ pip install --no-index --find-links=/local/wheels pkg
```

###  限定版本进行软件包安装

以下三种，对单个 python 包的版本进行了约束

```shell
# 所安装的包的版本为 2.1.2
$ pip install pkg==2.1.2

# 所安装的包必须大于等于 2.1.2
$ pip install pkg>=2.1.2

# 所安装的包必须小于等于 2.1.2
$ pip install pkg<=2.1.2
```

以下命令用于管理/控制整个 python 环境的包版本

```shell
# 导出依赖包列表
pip freeze >requirements.txt

# 从依赖包列表中安装
pip install -r requirements.txt

# 确保当前环境软件包的版本(并不确保安装)
pip install -c constraints.txt
```

###  限制不使用二进制包安装

由于默认情况下，wheel 包的平台是运行 pip download 命令 的平台，所以可能出现平台不适配的情况。

比如在 MacOS 系统下得到的 pymongo-2.8-cp27-none-macosx_10_10_intel.whl 就不能在 linux_x86_64 安装。

使用下面这条命令下载的是 tar.gz 的包，可以直接使用 pip install 安装。

比 wheel 包，这种包在安装时会进行编译，所以花费的时间会长一些。

```shell
# 下载非二进制的包
$ pip download --no-binary=:all: pkg

#　安装非二进制的包
$ pip install pkg --no-binary
```

###  指定代理服务器安装

当你身处在一个内网环境中时，无法直接连接公网。这时候你使用`pip install` 安装包，就会失败。

面对这种情况，可以有两种方法：

1. 下载离线包拷贝到内网机器中安装
2. 使用代理服务器转发请求

第一种方法，虽说可行，但有相当多的弊端

- 步骤繁杂，耗时耗力
- 无法处理包的依赖问题

这里重点来介绍，第二种方法：

```shell
$ pip install --proxy [user:passwd@]http_server_ip:port pkg
```

每次安装包就发输入长长的参数，未免有些麻烦，为此你可以将其写入配置文件中：`$HOME/.config/pip/pip.conf`

对于这个路径，说明几点

- 不同的操作系统，路径各不相同

```shell
# Linux/Unix:
/etc/pip.conf
~/.pip/pip.conf
~/.config/pip/pip.conf
 
# Mac OSX:
~/Library/Application Support/pip/pip.conf
~/.pip/pip.conf
/Library/Application Support/pip/pip.conf
 
# Windows:
%APPDATA%\pip\pip.ini
%HOME%\pip\pip.ini
C:\Documents and Settings\All Users\Application Data\PyPA\pip\pip.conf (Windows XP)
C:\ProgramData\PyPA\pip\pip.conf (Windows 7及以后) 
```

- 若在你的机子上没有此文件，则自行创建即可

如何配置，这边给个样例：

```ini
[global]
index-url = http://mirrors.aliyun.com/pypi/simple/ 

# 替换出自己的代理地址，格式为[user:passwd@]proxy.server:port
proxy=http://xxx.xxx.xxx.xxx:8080 

[install]
# 信任阿里云的镜像源，否则会有警告
trusted-host=mirrors.aliyun.com 
```

###  安装用户私有软件包

很多人可能还不清楚，python 的安装包是可以用户隔离的。

如果你拥有管理员权限，你可以将包安装在全局环境中。在全局环境中的这个包可被该机器上的所有拥有管理员权限的用户使用。

如果一台机器上的使用者不只一样，自私地将在全局环境中安装或者升级某个包，是不负责任且危险的做法。

面对这种情况，我们就想能否安装单独为我所用的包呢？

庆幸的是，还真有。

我能想到的有两种方法：

1. 使用虚拟环境
2. 将包安装在用户的环境中

虚拟环境，之前写过几篇文章，这里不再展开讲。

今天的重点是第二种方法，教你如何安装用户私有的包？

命令也很简单，只要加上 `--user` 参数，pip 就会将其安装在当前用户的 `~/.local/lib/python3.x/site-packages` 下，而其他用户的 python 则不会受影响。

```shell
pip install --user pkg
```

来举个例子

```shell
# 在全局环境中未安装 requests
[root@localhost ~]# pip list | grep requests   
[root@localhost ~]# su - wangbm
[root@localhost ~]# 

# 由于用户环境继承自全局环境，这里也未安装
[wangbm@localhost ~]# pip list | grep requests 
[wangbm@localhost ~]# pip install --user requests  
[wangbm@localhost ~]# pip list | grep requests 
requests (2.22.0)
[wangbm@localhost ~]# 

# 从 Location 属性可发现 requests 只安装在当前用户环境中
[wangbm@ws_compute01 ~]$ pip show requests
---
Metadata-Version: 2.1
Name: requests
Version: 2.22.0
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.org
Installer: pip
License: Apache 2.0
Location: /home/wangbm/.local/lib/python2.7/site-packages
[wangbm@localhost ~]$ exit
logout

# 退出 wangbm 用户，在 root 用户环境中发现 requests 未安装
[root@localhost ~]$ pip list | grep requests
[root@localhost ~]$ 
```

当你身处个人用户环境中，python 导包时会先检索当前用户环境中是否已安装这个包，已安装则优先使用，未安装则使用全局环境中的包。

验证如下：

```python
>>> import sys
>>> from pprint import pprint 
>>> pprint(sys.path)
['',
 '/usr/lib64/python27.zip',
 '/usr/lib64/python2.7',
 '/usr/lib64/python2.7/plat-linux2',
 '/usr/lib64/python2.7/lib-tk',
 '/usr/lib64/python2.7/lib-old',
 '/usr/lib64/python2.7/lib-dynload',
 '/home/wangbm/.local/lib/python2.7/site-packages',
 '/usr/lib64/python2.7/site-packages',
 '/usr/lib64/python2.7/site-packages/gtk-2.0',
 '/usr/lib/python2.7/site-packages',
 '/usr/lib/python2.7/site-packages/pip-18.1-py2.7.egg',
 '/usr/lib/python2.7/site-packages/lockfile-0.12.2-py2.7.egg']
>>> 

```

###  延长超时时间

若网络情况不是很好，在安装某些包时经常会因为 ReadTimeout 而失败。

对于这种情况，一般重试几次就好了。

但是这样难免有些麻烦，有没有更好的解决方法呢？

有的，可以通过延长超时时间。

```shell
$ pip install --default-timeout=100 <packages>
```



##  卸载软件包

就一条命令，不再赘述

```shell
$ pip uninstall pkg
```



##  升级软件包

想要对现有的 python 进行升级，其本质上也是先从 pypi 上下载最新版本的包，再对其进行安装。所以升级也是使用 `pip install`，只不过要加一个参数 `--upgrade`。

```shell
$ pip install --upgrade pkg
```

在升级的时候，其实还有一个不怎么用到的选项 `--upgrade-strategy`，它是用来指定升级策略。

它的可选项只有两个：

- `eager` ：升级全部依赖包
- `only-if-need`：只有当旧版本不能适配新的父依赖包时，才会升级。

在 pip 10.0 版本之后，这个选项的默认值是 `only-if-need`，因此如下两种写法是一互致的。

```shell
$ pip install --upgrade pkg1 
$ pip install --upgrade pkg1 --upgrade-strategy only-if-need
```

##  配置文件

由于在使用 pip 安装一些包时，默认会使用 pip 的官方源，所以经常会报网络超时失败。

常用的解决办法是，在安装包时，使用 `-i` 参数指定一个国内的镜像源。但是每次指定就很麻烦呀，还要打超长的一串字母。

这时候，其实可以将这个源写进 pip 的配置文件里。以后安装的时候，就默认从你配置的这个 源里安装了。

那怎么配置呢？文件文件在哪？

使用` win+r` 输入 `%APPDATA%` 进入用户资料文件夹，查看有没有一个 pip 的文件夹，若没有则创建之。

然后进入这个 文件夹，新建一个 `pip.ini` 的文件，内容如下

```ini
[global]
time-out=60
index-url=https://pypi.tuna.tsinghua.edu.cn/simple/
[install]
trusted-host=tsinghua.edu.cn
```



以上几乎包含了 pip 的所有常用使用场景，为了方便，我将其整理成一张表格。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-998261.png)

#  【进阶】理解模块的缓存

在一个模块内部重复引用另一个相同模块，实际并不会导入两次，原因是在使用关键字 `import` 导入模块时，它会先检索 `sys.modules` 里是否已经载入这个模块了，如果已经载入，则不会再次导入，如果不存在，才会去检索导入这个模块。

来实验一下，在 `my_mod02` 这个模块里，我 import 两次 `my_mod01` 这个模块，按逻辑每一次 import 会一次 `my_mod01` 里的代码（即打印 `in mod01`），但是验证结果是，只打印了一次。

```shell
$ cat my_mod01.py                 
print('in mod01')                    

$ cat my_mod02.py                 
import my_mod01                                        
import my_mod01     

$ python my_mod02.py              
in mod01                          
```

该现象的解释是：因为有 `sys.modules` 的存在。

`sys.modules` 是一个字典（key：模块名，value：模块对象），它存放着在当前 namespace 所有已经导入的模块对象。

```python
# test_module.py

import sys
print(sys.modules.get('json', 'NotFound'))

import json
print(sys.modules.get('json', 'NotFound'))
```

运行结果如下，可见在 导入后 json 模块后，`sys.modules` 才有了 json 模块的对象。

```shell
$ python test_module.py
NotFound
<module 'json' from 'C:\Python27\lib\json\__init__.pyc'>
```

 由于有缓存的存在，使得我们无法重新载入一个模块。

但若你想反其道行之，可以借助 importlib 这个神奇的库来实现。事实也确实有此场景，比如在代码调试中，在发现代码有异常并修改后，我们通常要重启服务再次载入程序。这时候，若有了模块重载，就无比方便了，修改完代码后也无需服务的重启，就能继续调试。

还是以上面的例子来理解，`my_mod02.py` 改写成如下

```python
# my_mod02.py

import importlib
import my_mod01
importlib.reload(my_mod01)
```

使用 python3 来执行这个模块，与上面不同的是，这边执行了两次 `my_mod01.py`

```shell
$ python3 my_mod02.py
in mod01
in mod01
```

#  【进阶】理解查找器与加载器

如果指定名称的模块在 `sys.modules` 找不到，则将发起调用 Python 的导入协议以查找和加载该模块。 

此协议由两个概念性模块构成，即 `查找器` 和 `加载器`。 

一个 Python 的模块的导入，其实可以再细分为两个过程：

1. 由查找器实现的模块查找
2. 由加载器实现的模块加载

##  查找器是什么？

查找器（finder），简单点说，查找器定义了一个模块查找机制，让程序知道该如何找到对应的模块。

其实 Python 内置了多个默认查找器，其存在于 sys.meta_path 中。

但这些查找器对应使用者来说，并不是那么重要，因此在 Python 3.3 之前， Python 解释将其隐藏了，我们称之为隐式查找器。

```python
# Python 2.7
>>> import sys
>>> sys.meta_path
[]
>>> 
```

由于这点不利于开发者深入理解 import 机制，在 Python 3.3 后，所有的模块导入机制都会通过 sys.meta_path 暴露，不会在有任何隐式导入机制。

```python
# Python 3.6
>>> import sys
>>> from pprint import pprint
>>> pprint(sys.meta_path)
[<class '_frozen_importlib.BuiltinImporter'>,
 <class '_frozen_importlib.FrozenImporter'>,
 <class '_frozen_importlib_external.PathFinder'>]
```

观察一下 Python 默认的这几种查找器 （finder），可以分为三种：

- 一种知道如何导入内置模块
- 一种知道如何导入冻结模块
- 一种知道如何导入来自 [import path](https://docs.python.org/zh-cn/3/glossary.html#term-import-path) 的模块 (即 [path based finder](https://docs.python.org/zh-cn/3/glossary.html#term-path-based-finder))。

那我们能不能自已定义一个查找器呢？当然可以，你只要

- 定义一个实现了 find_module 方法的类（py2和py3均可），或者实现 find_loader 类方法（仅 py3 有效），如果找到模块需要返回一个 loader 对象或者 ModuleSpec 对象（后面会讲），没找到需要返回 None
- 定义完后，要使用这个查找器，必须注册它，将其插入在 sys.meta_path 的首位，这样就能优先使用。

```python
import sys

class MyFinder(object):
    @classmethod
    def find_module(cls, name, path, target=None):
        print("Importing", name, path, target)
        # 将在后面定义
        return MyLoader()

# 由于 finder 是按顺序读取的，所以必须插入在首位
sys.meta_path.insert(0, MyFinder)
```

查找器可以分为两种：

```shell
object
 +-- Finder (deprecated)
      +-- MetaPathFinder
      +-- PathEntryFinder
```

这里需要注意的是，在 3.4 版前，查找器会直接返回 加载器（Loader）对象，而在 3.4 版后，查找器则会返回模块规格说明（ModuleSpec），其中 包含加载器。 

而关于什么是 加载器 和 模块规格说明， 请继续往后看。

##  加载器是什么？

查找器只负责查找定位找模，而真正负责加载模块的，是加载器（loader）。

一般的 loader 必须定义名为 ` load_module() ` 的方法。

为什么这里说一般，因为 loader 还分多种：

```shell
object
 +-- Finder (deprecated)
 |    +-- MetaPathFinder
 |    +-- PathEntryFinder
 +-- Loader
      +-- ResourceLoader --------+
      +-- InspectLoader          |
           +-- ExecutionLoader --+
                                 +-- FileLoader
                                 +-- SourceLoader
```

通过查看源码可知，不同的加载器的抽象方法各有不同。



加载器通常由一个 finder 返回。详情参见 PEP 302，对于 abstract base class 可参见 importlib.abc.Loader。

那如何自定义我们自己的加载器呢？

你只要

- 定义一个实现了 load_module 方法的类
- 对与导入有关的属性（[点击查看详情](https://docs.python.org/zh-cn/3/reference/import.html#import-related-module-attributes)）进行校验
- 创建模块对象并绑定所有与导入相关的属性变量到该模块上
- 将此模块保存到 sys.modules 中（顺序很重要，避免递归导入）
- 然后加载模块（这是核心）
- 若加载出错，需要能够处理抛出异常（ ImportError）
- 若加载成功，则返回 module 对象

若你想看具体的例子，可以接着往后看。

##  模块规格说明

导入机制在导入期间会使用有关每个模块的多种信息，特别是加载之前。 大多数信息都是所有模块通用的。 模块规格说明的目的是基于每个模块来封装这些导入相关信息。

模块的规格说明会作为模块对象的 `__spec__` 属性对外公开。 有关模块规格的详细内容请参阅 [`ModuleSpec`](https://docs.python.org/zh-cn/3/library/importlib.html#importlib.machinery.ModuleSpec)。

在 Python 3.4 后，查找器不再返回加载器，而是返回 ModuleSpec 对象，它储存着更多的信息

- 模块名
- 加载器
- 模块绝对路径

那如何查看一个模块的 ModuleSpec ？

这边举个例子

```shell
$ cat my_mod02.py
import my_mod01
print(my_mod01.__spec__)

$ python3 my_mod02.py
in mod01
ModuleSpec(name='my_mod01', loader=<_frozen_importlib_external.SourceFileLoader object at 0x000000000392DBE0>, origin='/home/MING/my_mod01.py')
```

从 ModuleSpec 中可以看到，加载器是包含在内的，那我们如果要重新加载一个模块，是不是又有了另一种思路了？

来一起验证一下。

现在有两个文件：

一个是 my_info.py

```python
# my_info.py
name='wangbm'
```

 另一个是：main.py

```python
# main.py
import my_info

print(my_info.name)

# 加一个断点
import pdb;pdb.set_trace()

# 再加载一次
my_info.__spec__.loader.load_module()

print(my_info.name)
```

在 `main.py` 处，我加了一个断点，目的是当运行到断点处时，我修改 my_info.py 里的 name 为 `ming` ，以便验证重载是否有效？

```shell
$ python3 main.py
wangbm
> /home/MING/main.py(9)<module>()
-> my_info.__spec__.loader.load_module()
(Pdb) c
ming
```

从结果来看，重载是有效的。



##  导入器是什么？

导入器（importer），也许你在其他文章里会见到它，但其实它并不是个新鲜的东西。

它只是同时实现了查找器和加载器两种接口的对象，所以你可以说导入器（importer）是查找器（finder），也可以说它是加载器（loader）。

#  【进阶】实现远程导入模块

由于 Python 默认的 查找器和加载器 仅支持本地的模块的导入，并不支持实现远程模块的导入。

为了让你更好的理解 Python Import Hook 机制，我下面会通过实例演示，如何自己实现远程导入模块的导入器。

##  动手实现导入器

当导入一个包的时候，Python 解释器首先会从 sys.meta_path 中拿到查找器列表。

默认顺序是：内建模块查找器 -> 冻结模块查找器 -> 第三方模块路径（本地的 sys.path）查找器

若经过这三个查找器，仍然无法查找到所需的模块，则会抛出ImportError异常。



因此要实现远程导入模块，有两种思路。

- 一种是实现自己的元路径导入器；
- 另一种是编写一个钩子，添加到sys.path_hooks里，识别特定的目录命名模式。



我这里选择第一种方法来做为示例。

实现导入器，我们需要分别查找器和加载器。

**首先是查找器**

由源码得知，路径查找器分为两种

- MetaPathFinder
- PathEntryFinder

这里使用 MetaPathFinder 来进行查找器的编写。

在 Python 3.4 版本之前，查找器必须实现 `find_module()` 方法，而  Python 3.4+ 版，则推荐使用 `find_spec()`  方法，但这并不意味着你不能使用 `find_module()`，但是在没有 `find_spec()` 方法时，导入协议还是会尝试 `find_module()` 方法。

我先举例下使用 `find_module()` 该如何写。

```python
from importlib import abc

class UrlMetaFinder(abc.MetaPathFinder):
    def __init__(self, baseurl):
        self._baseurl = baseurl

    def find_module(self, fullname, path=None):
        if path is None:
            baseurl = self._baseurl
        else:
            # 不是原定义的url就直接返回不存在
            if not path.startswith(self._baseurl):
                return None
            baseurl = path

        try:
            loader = UrlMetaLoader(baseurl)
            loader.load_module(fullname)
            return loader
        except Exception:
            return None
```

若使用 `find_spec()` ，要注意此方法的调用需要带有两到三个参数。 

第一个是被导入模块的完整限定名称，例如 `foo.bar.baz`。 第二个参数是供模块搜索使用的路径条目。 对于最高层级模块，第二个参数为 `None`，但对于子模块或子包，第二个参数为父包 `__path__` 属性的值。 如果相应的 `__path__` 属性无法访问，将引发 [`ModuleNotFoundError`](https://docs.python.org/zh-cn/3/library/exceptions.html#ModuleNotFoundError)。 第三个参数是一个将被作为稍后加载目标的现有模块对象。 导入系统仅会在重加载期间传入一个目标模块。

```python
from importlib import abc
from importlib.machinery import ModuleSpec

class UrlMetaFinder(abc.MetaPathFinder):
    def __init__(self, baseurl):
        self._baseurl = baseurl
    def find_spec(self, fullname, path=None, target=None):
        if path is None:
            baseurl = self._baseurl
        else:
            # 不是原定义的url就直接返回不存在
            if not path.startswith(self._baseurl):
                return None
            baseurl = path

        try:
            loader = UrlMetaLoader(baseurl)
            return ModuleSpec(fullname, loader, is_package=loader.is_package(fullname))
        except Exception:
            return None
```



**接下来是加载器**

由源码得知，路径查找器分为三种

- FileLoader
- SourceLoader

按理说，两种加载器都可以实现我们想要的功能，我这里选用 SourceLoader 来示范。

在 SourceLoader 这个抽象类里，有几个很重要的方法，在你写实现加载器的时候需要注意

- get_code：获取源代码，可以根据自己场景实现实现。
- exec_module：执行源代码，并将变量赋值给 `module.__dict__` 
- get_data：抽象方法，必须实现，返回指定路径的字节码。
- get_filename：抽象方法，必须实现，返回文件名

在一些老的博客文章中，你会经常看到 加载器 要实现 `load_module()` ，而这个方法早已在 Python 3.4 的时候就被废弃了，当然为了兼容考虑，你若使用 `load_module()` 也是可以的。

```python
from importlib import abc

class UrlMetaLoader(abc.SourceLoader):
    def __init__(self, baseurl):
        self.baseurl = baseurl

    def get_code(self, fullname):
        f = urllib2.urlopen(self.get_filename(fullname))
        return f.read()

    def load_module(self, fullname):
        code = self.get_code(fullname)
        mod = sys.modules.setdefault(fullname, imp.new_module(fullname))
        mod.__file__ = self.get_filename(fullname)
        mod.__loader__ = self
        mod.__package__ = fullname
        exec(code, mod.__dict__)
        return None

    def get_data(self):
        pass

    def execute_module(self, module):
        pass

    def get_filename(self, fullname):
        return self.baseurl + fullname + '.py'
```

当你使用这种旧模式实现自己的加载时，你需要注意两点，很重要：

- execute_module 必须重载，而且不应该有任何逻辑，即使它并不是抽象方法。
- load_module，需要你在查找器里手动执行，才能实现模块的加载。。

做为替换，你应该使用 `execute_module()` 和 `create_module()` 。由于基类里已经实现了 `execute_module` 和 `create_module()`，并且满足我们的使用场景。我这边可以不用重复实现。和旧模式相比，这里也不需要在设查找器里手动执行 `execute_module()`。

```python
import urllib.request as urllib2

class UrlMetaLoader(importlib.abc.SourceLoader):
    def __init__(self, baseurl):
        self.baseurl = baseurl

    def get_code(self, fullname):
        f = urllib2.urlopen(self.get_filename(fullname))
        return f.read()

    def get_data(self):
        pass

    def get_filename(self, fullname):
        return self.baseurl + fullname + '.py'
```

查找器和加载器都有了，别忘了往sys.meta_path 注册我们自定义的查找器（UrlMetaFinder）。

```python
def install_meta(address):
    finder = UrlMetaFinder(address)
    sys.meta_path.append(finder)
```

所有的代码都解析完毕后，我们将其整理在一个模块（my_importer.py）中

```python
# my_importer.py
import sys
import importlib
import urllib.request as urllib2

class UrlMetaFinder(importlib.abc.MetaPathFinder):
    def __init__(self, baseurl):
        self._baseurl = baseurl


    def find_module(self, fullname, path=None):
        if path is None:
            baseurl = self._baseurl
        else:
            # 不是原定义的url就直接返回不存在
            if not path.startswith(self._baseurl):
                return None
            baseurl = path

        try:
            loader = UrlMetaLoader(baseurl)
            return loader
        except Exception:
            return None

class UrlMetaLoader(importlib.abc.SourceLoader):
    def __init__(self, baseurl):
        self.baseurl = baseurl

    def get_code(self, fullname):
        f = urllib2.urlopen(self.get_filename(fullname))
        return f.read()

    def get_data(self):
        pass

    def get_filename(self, fullname):
        return self.baseurl + fullname + '.py'

def install_meta(address):
    finder = UrlMetaFinder(address)
    sys.meta_path.append(finder)
```

##  搭建远程服务端

最开始我说了，要实现一个远程导入模块的方法。

我还缺一个在远端的服务器，来存放我的模块，为了方便，我使用python自带的 `http.server` 模块用一条命令即可实现。

```shell
$ mkdir httpserver && cd httpserver
$ cat>my_info.py<EOF
name='wangbm'
print('ok')
EOF
5sM!ebM5sM!ebMt0fNkt0fNk
$ cat my_info.py
name='wangbm'
print('ok')
$ 
$ python3 -m http.server 12800
Serving HTTP on 0.0.0.0 port 12800 (http://0.0.0.0:12800/) ...
...
```

一切准备好，我们就可以验证了。

```python
>>> from my_importer import install_meta
>>> install_meta('http://localhost:12800/') # 往 sys.meta_path 注册 finder 
>>> import my_info  # 打印ok，说明导入成功
ok
>>> my_info.name  # 验证可以取得到变量
'wangbm'
```

至此，我实现了一个简易的可以导入远程服务器上的模块的导入器。

#  【基础】分发工具：distutils和setuptools

##  包分发的始祖：distutils

`distutils` 是 Python 的一个标准库，从命名上很容易看出它是一个分发（distribute）工具（utlis），它是 Python 官方开发的一个分发打包工具，所有后续的打包工具，全部都是基于它进行开发的。

`distutils` 的精髓在于编写 setup.py，它是模块分发与安装的指导文件。

那么如何编写 setup.py 呢？这里面的内容非常多，我会在后面进行详细的解析，请你耐心往下看。

你有可能没写过 setup.py ，但你绝对使用过 setup.py 来做一些事情，比如下面这条命令，我们经常用它来进行模块的安装。

```shell
$ python setup.py install
```

这样的安装方法是通过源码安装，与之对应的是通过二进制软件包的安装，同样我也会在后面进行介绍。

##  分发工具升级：setuptools

`setuptools` 是 distutils 增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发 Python 包。大部分 Python 用户都会使用更先进的 setuptools 模块。

 **distribute**，或许你在其他地方也见过它，这里也提一下。

distribute 是 setuptools 有一个分支版本，分支的原因可能是有一部分开发者认为 setuptools 开发太慢了。但现在，distribute 又合并回了 setuptools 中。因此，我们可以认为它们是同一个东西。

还有一个大包分发工具是 **distutils2**，其试图尝试充分利用distutils，detuptools 和 distribute 并成为 Python 标准库中的标准工具。但该计划并没有达到预期的目的，且已经是一个废弃的项目。

因此，setuptools 是一个优秀的，可靠的 Python 包安装与分发工具。

那么如何在一个干净的环境中安装 setuptools 呢？

主要有两种方法：

- 源码安装：在 https://pypi.org/project/setuptools/#files 中下载 zip 包 解压执行 `python setup.py install` 安装
- 通过引导程序安装：下载引导程序，它可以用来下载或者更新最新版本的 setuptools

```shell
$ wget http://peak.telecommunity.com/dist/ez_setup.py

# 安装
$ python ez_setup.py

# 更新，以下两种任选
$ python ez_setup.py –U setuptools
$ pip install -U setuptools
```

#  【基础】源码包与二进制包有什么区别？

Python 包的分发可以分为两种：

1. 以源码包的方式发布

源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。

源码包的本质是一个压缩包，其常见的格式有：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-011251.png)

2. 以二进制包形式发布

二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。

由于不同平台的编译出来的包无法通用，所以在发布时，需事先编译好多个平台的包。

二进制包的常见格式有：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-025253.png)

#  【基础】eggs与wheels 有什么区别？

Egg 格式是由 setuptools 在 2004 年引入，而 Wheel 格式是由 PEP427 在 2012 年定义。Wheel 的出现是为了替代 Egg，它的本质是一个zip包，其现在被认为是 Python 的二进制包的标准格式。

以下是 Wheel 和 Egg 的主要区别：

- Wheel 有一个官方的 PEP427 来定义，而 Egg 没有 PEP 定义
- Wheel 是一种分发格式，即打包格式。而 Egg 既是一种分发格式，也是一种运行时安装的格式，并且是可以被直接 import
- Wheel 文件不会包含 .pyc 文件
- Wheel 使用和 PEP376 兼容的 .dist-info 目录，而 Egg 使用 .egg-info 目录
- Wheel 有着更丰富的命名规则。
- Wheel 是有版本的。每个 Wheel 文件都包含 wheel 规范的版本和打包的实现
- Wheel 在内部被 sysconfig path type 管理，因此转向其他格式也更容易

wheel 包可以通过 pip 来安装，只不过需要先安装 wheel 模块，然后再使用 pip 的命令。

```shell
$ pip install wheel
$ pip wheel --wheel-dir=/local/wheels pkg
```

# 【进阶】超详细讲解 setup.py 的编写

##  setup.py 的编写

1、构建源码发布包。

用于发布一个 Python 模块或项目，将源码打包成 tar.gz （用于 Linux 环境中）或者 zip 压缩包（用于 Windows 环境中）

```shell
$ python setup.py sdist
```

那这种包如何安装呢？

答案是，使用 `setuptools` 中提供的 `easy_install` 工具。

```shell
$ easy_install xxx.tar.gz
```

使用 sdist 将根据当前平台创建默认格式的存档。在类 Unix 平台上，将创建后缀后为 `.tar.gz`  的 gzip 压缩的tar文件分发包，而在Windows上为 ZIP 文件。

当然，你也可以通过指定你要的发布包格式来打破这个默认行为

```shell
$ python setup.py sdist --formats=gztar,zip
```

你可以指定的格式有哪些呢？

创建一个压缩的tarball和一个zip文件。可用格式为：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-041255.png)

对以上的格式，有几点需要注意一下：

- 在版本3.5中才添加了对  `xztar` 格式的支持
- zip 格式需要你事先已安装相应的模块：zip程序或zipfile模块（已成为Python的标准库）
- ztar 格式正在弃用，请尽量不要使用

另外，如果您希望归档文件的所有文件归root拥有，可以这样指定

```shell
$ python setup.py sdist --owner=root --group=root
```



2、构建二进制分发包。

在windows中我们习惯了双击 exe 进行软件的安装，Python 模块的安装也同样支持 打包成 exe 这样的二进制软件包。

```shell
$ python setup.py bdist_wininst
```

而在 Linux 中，大家也习惯了使用 rpm 来安装包，对此你可以使用这条命令实现 rpm 包的构建

```shell
$ python setup.py bdist_rpm
```

若你喜欢使用 easy_install 或者 pip 来安装离线包。你可以将其打包成 egg 包

```shell
$ python setup.py bdist_egg
```

若你的项目，需要安装多个平台下，既有 Windows 也有 Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制包

```shell
$ python setup.py bdist
```



##  使用 setup.py 安装包

正常情况下，我们都是通过以上构建的源码包或者二进制包进行模块的安装。

但在编写 setup.py 的过程中，可能不能一步到位，需要多次调试，这时候如何测试自己写的 setup.py 文件是可用的呢？

这时候你可以使用这条命令，它会将你的模块安装至系统全局环境中

```shell
$ python setup.py install
```

如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。

这时候你可以使用这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。

```shell
$ python setup.py develop
```

#  【进阶】打包辅助神器 PBR 是什么？

`pbr` 是 setuptools 的辅助工具，最初是为 OpenStack 开发(https://launchpad.net/pbr)，基于`d2to1`。



`pbr` 会读取和过滤setup.cfg中的数据，然后将解析后的数据提供给 `setup.py` 作为参数。包含如下功能：

1. 从git中获取Version、AUTHORS and ChangeLog信息
2. Sphinx Autodoc。pbr 会扫描project，找到所有模块，生成stub files
3. Requirements。pbr会读取requirements.txt，生成setup函数需要的`install_requires/tests_require/dependency_links`

这里需要注意，在 `requirements.txt` 文件的头部可以使用：`--index https://pypi.python.org/simple/`，这一行把一个抽象的依赖声明如 requests==1.2.0 转变为一个具体的依赖声明 requests 1.2.0 from pypi.python.org/simple/

4. long_description。从README.rst, README.txt or README file中生成`long_description`参数



使用pbr很简单：

```
from setuptools import setup

setup(
    setup_requires=['pbr'],
    pbr=True,
)

```

使用pbr时，setup.cfg中有一些配置。在[files]中，有三个key：
`packages`:指定需要包含的包，行为类似于setuptools.find_packages
`namespace_packages`:指定namespace packages
`data_files`: 指定目的目录和源文件路径，一个示例：

```
[files]
data_files =
    etc/pbr = etc/pbr/*
    etc/neutron =
        etc/api-paste.ini
        etc/dhcp-agent.ini
    etc/init.d = neutron.init

```

`[entry_points]` 段跟 setuptools 的方式相同。



到此，我讲了三种编写使用 setup.py 的方法

- 使用命令行参数指定，一个一个将参数传递进去（极不推荐）
- 在 setup.py 中的setup函数中指定（推荐使用）
- 使用 pbr ，在 setup.cfg 中指定（易于管理，更推荐）

#  【进阶】开源自己的包到 PYPI 上

通过前面的学习，你一定已经学会了如何打包自己的项目，若你觉得自己开发的模块非常不错，想要 share 给其他人使用，你可以将其上传到 PyPi （Python Package Index）上，它是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包。

如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 `~/.pypirc` 文件，此文件中配置 PyPI 访问地址和账号。如的.pypirc文件内容请根据自己的账号来修改。

典型的 .pypirc 文件

```ini
[distutils]
index-servers = pypi

[pypi]
username:xxx
password:xxx
```

然后使用这条命令进行信息注册，完成后，你可以在 PyPi 上看到项目信息。

```shell
$ python setup.py register
```

注册完了后，你还要上传源码包，别人才使用下载安装

```shell
$ python setup.py upload
```

或者也可以使用 `twine` 工具注册上传，它是一个专门用于与 pypi 进行交互的工具，详情可以参考官网：https://www.ctolib.com/twine.html，这里不详细讲了。

