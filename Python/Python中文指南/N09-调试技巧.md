#  【调试技巧】超详细图文教你调试代码

##  调试的过程

调试可以说是每个开发人员都必备一项技能，在日常开发和排查 bug 都非常有用。

调试的过程分为三步：

1. 第一步：在你想要调试的地方，打上断点

2. 第二步：使用调试模式来运行这个 python 程序
3. 第三步：使用各种手段开始代码调试

首先第一步和第二步，我用下面这张图表示

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-161252.png)

点击上图中的小蜘蛛，开启调试模式后，在 PyCharm 下方会弹出一个选项卡。

这个选项卡的按键非常多，包括

1. 变量查看窗口
2. 调试控制窗口
3. 线程控制窗口
4. 程序控制窗口

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-176252.png)

在变量查看窗口，你可以查看当前程序进行到该断点处，所有的普通变量和特殊变量，你每往下执行一行代码，这些变量都有可能跟着改变。

如果你的程序是多线程的，你可以通过线程控制窗口的下拉框来切换线程。

以上两个窗口，都相对比较简单，我一笔带过，下面主要重点讲下调试控制按钮和程序控制按钮。

在调试控制窗口，共有 8 个按钮，他们的作用分别是什么呢？

1. Show Execution Point：无论你的代码编辑 窗口的光标在何处，只要点下该按钮，都会自动跳转到程序运行的地方。
2. Step Over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。在不存在子函数的情况下是和step into效果一样的。简单的说就是，程序代码越过子函数，但子函数会执行，且不进入。
3. Step Into：在单步执行时，遇到子函数就进入并且继续单步执行，有的会跳到源代码里面去执行。
4. Step Into My Code：在单步执行时，遇到子函数就进入并且继续单步执行，不会进入到源码中。
5. Step Out：假如进入了一个函数体中，你看了两行代码，不想看了，跳出当前函数体内，返回到调用此函数的地方，即使用此功能即可。
6. Run To Cursor：运行到光标处，省得每次都要打一个断点。
7. Evaluate Expression：计算表达式，在里面可以自己执行一些代码。

以上七个功能，就是最常用的功能，一般操作步骤就是，设置好断点，debug运行，然后 F8 单步调试，遇到想进入的函数 F7 进去，想出来在 shift + F8，跳过不想看的地方，直接设置下一个断点，然后 F9 过去。

看这张图就行了（下面第6点有误，应该是运行到光标处，而不是下一断点处）

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-191251.png)

在程序控制窗口，共有 6 个按钮，他们的作用分别又是什么呢？同时看下面这张图就行了。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-206255.png)

##  调试相关的快捷键

- ⇧ + F9：调试当前文件
- ⌥ + ⇧ + F9：弹出菜单，让你选择调试哪一个文件

- F8：单步执行，不进入函数
- F7：单步执行，进入函数
- ⌥ + ⇧ +F7：单步执行，只进入自己写的函数
- ⇧ + F8：跳出函数体
- F9：运行到下一断点
- ⌥ + F9：运行到光标处
- ⇧ + ⌘ + F8：查看所有设置的断点
- ⌘ + F8：切换断点（有断点则取消断点，没有则加上断点）
- ⌥ + F5：重新以调试模式运行
- ⌥ + F8 计算表达式（可以更改变量值使其生效）

#  【调试技巧】PyCharm 中指定参数调试程序

你在 Pycharm 运行你的项目，通常是怎么执行的？我的做法是，右键，然后点击 `Run`，或者使用快捷键 `Shift + F10` 。

有时候，在运行/调试脚本的时候，我们需要指定一些参数，这在命令行中，直接指定即可。

假设在命令行中，运行脚本的命令是这样

```shell
python main.py init --local
```

对于刚使用 Pycharm 的同学，可能并不知道 Pycharm 也是可以指定参数的。点击下图位置

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-135252.png)

进入设置面板，在 `Script parameters` 中填入参数即可。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-197258.png)

同时在上图的底部，你可以看到，这里可以很方便的切换 解释器，比你跑到这边来要容易得多吧

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-165250.png)

#  【调试技巧】PyCharm跑完后立即进入调试模式

假如我们在一个爬虫的项目中，会使用到 正则表达式 来匹配我们想要抓取的内容。正则这种东西，有几个人能够一步到位的呢，通常都需要经过很多次的调试才能按预期匹配。在我们改了一次正则后，运行了下，需要重新向网站抓取请求，才能发现没有匹配上，然后又改了一版，再次运行同样需要发起请求，结果还是发现还是没有匹配上，往往复复，正则不好的同学可能要进行几十次的尝试。

（上面这个例子可能不太贴切，毕竟是有很多种方法实现不用重新发请求，只是列举了一种很笨拙且低效的调试过程，你看看就好了）

而我们在这几十次的调试中，向同一网站发起请求都是没有意义的重复工作。如果在 Pycharm 中可以像  IPython Shell  和 Jupyter Notebook 那样，可以记住运行后所有的变量信息，可以在不需要重新运行项目或脚本，就可以通过执行命令表达式，来调整我们的代码，进行我们的正则调试。

答案当然是有。

假如我在调试如下几行简单的代码。在第 3 行处打了个断点。然后点击图示位置 `Show Python Prompt` 按钮。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-045251.png)

就进入了 `Python Shell` 的界面，这个Shell 环境和我们当前运行的程序环境是打通的，变量之间可以互相访问，这下你可以轻松地进行调试了。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-076255.png)

上面我们打了个断点，是为了方便说明这个效果。并不是说一定要打断点。如果不打断点，在脚本执行完成后，也仍然可以在这个界面查看并操作所有变量。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-121260.png)

现在我们已经可以满足我们的调试的需求，但是每次运行脚本，都要手动点击 `Show Python Prompt` ，有点麻烦。嗯？其实这个有地方可以设置默认打开的。这个开关还比较隐秘，一般人还真发现不了。

你需要点击图示位置 `Edit Configurations` 处。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-135252.png)

然后在这里打勾选中。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-061251.png)

设置上之后，之后你每次运行后脚本后，都会默认为你存储所有变量的值，并为你打开 console 命令行调试界面。

除了上面这种方法，其实还有一种方法可以在调试过程中，执行命令表达式，而这种大家可能比较熟悉了，这边也提一下，就当是汇总一下。但是从功能上来说，是没有上面这种方法来得方便易用的。因为这种方法，必须要求你使用 debug 模式运行项目，并打断点。

使用方法就是，在你打了断点后，在图示位置处，点击右键使用 `Evaluate Expression`

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-181250.png)

就弹出了一个 `Evaluate Expression` 窗口，这里 可以运行命令表达式，直接操作变量。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171030-152257.png)

#  【调试技巧】脚本报错后立即进入调试模式

当你在使用 `python xxx.py` 这样的方法，执行 Python 脚本时，若因为代码 bug 导致异常未捕获，那整个程序便会终止退出。

这个时候，我们通常会去排查是什么原因导致的程序崩溃。

大家都知道，排查问题的思路，第一步肯定是去查看日志，若这个 bug 隐藏的比较深，只有在特定场景下才会现身，那么还需要开发者，复现这个 bug，方能优化代码。

复现有时候很难，有时候虽然简单，但是要伪造各种数据，相当麻烦。

如果有一种方法能在程序崩溃后，立马进入调试模式该有多好啊？

明哥都这么问了，那肯定是带着解决方案来的。

只要你在执行脚本行，加上 `-i` 参数，即可在脚本执行完毕后进入 Python Shell 模式，方便你进行调试。

具体演示如下：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-100251.png)

需要注意的是：脚本执行完毕，有两种情况：

1. 正常退出
2. 异常退出

这两种都会进入 Python Shell，如果脚本并无异常，最终也会进入 Python Shell 模式，需要你手动退出

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-118255.png)

#  【调试技巧】使用 PDB 进行无界面调试

Pycharm 的图形化界面虽然好用，但是在某些场景中，是无法使用的。而 Python 本身已经给我们提供了一个调试神器 -- pdb，可能你还不知道它，为了讲解这个神器，我写了这篇文章来帮助你轻松的理解它。

## 准备文件

在调试之前先将这两个文件准备好（做为演示用），并放在同级目录中。

`utils.py`

```python
def sum(mylist):
    result = 0
    for item in mylist:
        result += item
    return result
```

`pdb_demo.py`

```python
import utils

def myfunc(mylist):
    result = utils.sum(mylist)
    print(result)


if __name__ == '__main__':
    print("----start----")
    myfunc([1,2,3,4])
    print("----end-----")
```



##  进入调试模式

主要有两种方法

做为脚本调用，方法很简单，就像正常执行python脚本一样，只是多加了`-m pdb`

```
python -m pdb pdb_demo.py
```

使用这个方式进入调试模式，会在脚本的第一行开始单步调试。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-651251.png)

对于单文件的脚本并没有什么问题，如果是一个大型的项目，项目里有很多的文件，使用这种方式只能大大降低我们的效率。

一般情况下，都会直接在你需要的地方打一个断点，那如何打呢？

只需在你想要打断点的地方加上这两行。

```python
import pdb
pdb.set_trace()
```

然后执行时，也不需要再指定`-m pdb`了，直接`python pdb_demo.py ` ，就会直接在这个地方暂停。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-666254.png)

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-681252.png)



##  调试指令

熟悉 Pycharm 的人都知道，我们执行下一步，执行到下一个断点是

同样的，pdb 也需要你更多记这样的命令。

当你看到pdb模式的标识符 `(Pdb)`时，就可以输入这样的命令。

我在这里将这些指令按使用频度分为三个等级。



**最常用**

| 指令 |   英文    |           解释           |
| :--: | :-------: | :----------------------: |
|  n   |   Next    |          下一步          |
|  l   |   list    |    列出当前断点处源码    |
|  p   |   print   |         打印变量         |
|  s   | step into | 执行当前行，可以进入函数 |
|  r   |  return   | 运行完当前函数，返回结果 |
|  c   | continue  |  执行到下一断点或者结束  |
|  b   |   break   |         设置断点         |
|  q   |   quit    |         退出程序         |

**有时使用**

|    指令     |   英文   |             解释             |
| :---------: | :------: | :--------------------------: |
|      a      |   args   |      列出当前函数的参数      |
|     pp      |  pprint  |     一种可视化更好的打印     |
|      j      |   jump   |          跳到指定行          |
|     cl      |  clear   |           清除断点           |
|      w      |  where   |         打印当前堆栈         |
|      u      |    up    |  执行跳转到当前堆栈的上一层  |
|     unt     |  until   | 行数递增执行(忽略循环和函数) |
|     ll      | longlist |        列出更多的源码        |
| run/restart |   run    |    重新启动 debug(-m pdb)    |

**几乎不用**

|  指令   |      英文       |        解释        |
| :-----: | :-------------: | :----------------: |
| tbreak  | temporary break |      临时断点      |
| disable |                 |      停用断点      |
| enable  |                 |      启用断点      |
|  alias  |                 |      设置别名      |
| unalias |                 |      删除别名      |
| whatis  |                 |    打印对象类型    |
| ignore  |                 |   设置忽略的断点   |
| source  |                 | 列出给定对象的源码 |

其上全部是我翻译自官方文档，原文在这里：https://docs.python.org/3/library/pdb.html

其实你大可不必死记这些命令，忘记的时候，只要敲入`help`并回车，就可以看所有的指令了。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-712259.png)



##  开始调试

这里就几个最常用的指定，来演示一遍。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-696256.png)

这个调试过程，我加了些注释，你应该能够很轻易地理解这种调试方式。

#  【调试技巧】如何调试已经运行的程序？

官方原始wiki：https://wiki.python.org/moin/DebuggingWithGdb

在CentOS 下，安装包过程，官方给的不够详细。这里记录一下

先安装  yum-utils，装完后就能使用 debuginfo

```shell
sudo yum install yum-utils
```

然后使用debuginfo 安装 glibc，不过在安装之前，有可能 你需要先配置debuginfo的仓库，编辑`/etc/yum.repos.d/CentOS-Debuginfo.repo`

```
#Debug Info
[debuginfo]
name=CentOS-$releasever - DebugInfo
# CentOS-4
#baseurl=http://debuginfo.centos.org/$releasever/
# CentOS-5
baseurl=http://debuginfo.centos.org/$releasever/$basearch/
gpgcheck=0
enabled=1
# CentOS-4
#gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-$releasever
# CentOS-5
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-5
protect=1
```

然后就可以安装 `glibc` 了。

```shell
yum --nogpgcheck --enablerepo=debuginfo install glibc-debuginfo
sudo debuginfo-install glibc
```

最后安装 `python-debuginfo`

```shell
sudo yum install gdb python-debuginfo
```



#  【调试技巧】使用 PySnopper 调试疑难杂症

对于每个程序开发者来说，调试几乎是必备技能。

代码写到一半卡住了，不知道这个函数执行完的返回结果是怎样的？调试一下看看

代码运行到一半报错了，什么情况？怎么跟预期的不一样？调试一下看看



调试的方法多种多样，不同的调试方法适合不同的场景和人群。

- 如果你是刚接触编程的小萌新，对很多工具的使用还不是很熟练，那么 print 和 log 大法好
- 如果你在本地（Win或者Mac）电脑上开发，那么 IDE 的图形化界面调试无疑是最适合的；
- 如果你在服务器上排查BUG，那么使用 PDB 进行无图形界面的调试应该是首选；
- 如果你要在本地进行开发，但是项目的进行需要依赖复杂的服务器环境，那么可以了解下 PyCharm 的远程调试

除了以上，今天明哥再给你介绍一款非常好用的调试工具，它能在一些场景下，大幅度提高调试的效率， 那就是 `PySnooper`，它在 Github 上已经收到了 13k 的 star，获得大家的一致好评。

**有了这个工具后，就算是小萌新也可以直接无门槛上手，从此与 print 说再见~**

##  快速安装

执行下面这些命令进行安装 PySnooper

```shell
$ python3 -m pip install pysnooper

# 或者
$ conda install -c conda-forge pysnooper

# 或者
$ yay -S python-pysnooper
```

##  简单案例

下面这段代码，定义了一个 demo_func 的函数，在里面生成一个 profile 的字典变量，然后去更新它，最后返回。

代码本身没有什么实际意义，但是用来演示 PySnooper 已经足够。

```python
import pysnooper

@pysnooper.snoop()
def demo_func():
    profile = {}
    profile["name"] = "写代码的明哥"
    profile["age"] = 27
    profile["gender"] = "male"

    return profile

def main():
    profile = demo_func()

main()
```

现在我使用终端命令行的方式来运行它

```shell
[root@iswbm ~]# python3 demo.py 
Source path:... demo.py
17:52:49.624943 call         4 def demo_func():
17:52:49.625124 line         5     profile = {}
New var:....... profile = {}
17:52:49.625156 line         6     profile["name"] = "写代码的明哥"
Modified var:.. profile = {'name': '写代码的明哥'}
17:52:49.625207 line         7     profile["age"] = 27
Modified var:.. profile = {'name': '写代码的明哥', 'age': 27}
17:52:49.625254 line         8     profile["gender"] = "male"
Modified var:.. profile = {'name': '写代码的明哥', 'age': 27, 'gender': 'male'}
17:52:49.625306 line        10     return profile
17:52:49.625344 return      10     return profile
Return value:.. {'name': '写代码的明哥', 'age': 27, 'gender': 'male'}
Elapsed time: 00:00:00.000486
```

可以看到 PySnooper 把函数运行的过程全部记录了下来，包括：

- 代码的片段、行号等信息，以及每一行代码是何时调用的？
- 函数内局部变量的值如何变化的？何时新增了变量，何时修改了变量。
- 函数的返回值是什么？
- 运行函数消耗了多少时间？

而作为开发者，要得到这些如此详细的调试信息，你需要做的非常简单，只要给你想要调试的函数上带上一顶帽子（装饰器） -- `@pysnooper.snoop()` 即可。



##  详细使用

###  重定向到日志文件

`@pysnooper.snoop()` 不加任何参数时，会默认将调试的信息输出到标准输出。

对于单次调试就能解决的 BUG ，这样没有什么问题，但是有一些 BUG 只有在特定的场景下才会出现，需要你把程序放在后面跑个一段时间才能复现。

这种情况下，你可以将调试信息重定向输出到某一日志文件中，方便追溯排查。

```python
@pysnooper.snoop(output='/var/log/debug.log')
def demo_func():
    ...
```

###  跟踪非局部变量值

PySnooper 是以函数为单位进行调试的，它默认只会跟踪函数体内的局部变量，若想跟踪全局变量，可以给 `@pysnooper.snoop()` 加上 `watch` 参数

```python
out = {"foo": "bar"}

@pysnooper.snoop(watch=('out["foo"]'))
def demo_func():
    ...
```

如此一来，PySnooper 会在 `out["foo"]` 值有变化时，也将其打印出来

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-402253.png)

watch 参数，接收一个可迭代对象（可以是list 或者 tuple），里面的元素为字符串表达式，什么意思呢？看下面例子就知道了

```python
@pysnooper.snoop(watch=('out["foo"]', 'foo.bar', 'self.foo["bar"]'))
def demo_func():
		...
```

和 `watch` 相对的，`pysnooper.snoop()` 还可以接收一个函数 `watch_explode`，表示除了这几个参数外的其他所有全局变量都监控。

```python
@pysnooper.snoop(watch_explode=('foo', 'bar'))
def demo_func():
		...
```

###  设置跟踪函数的深度

当你使用 PySnooper 调试某个函数时，若该函数中还调用了其他函数，PySnooper 是不会傻傻的跟踪进去的。

如果你想继续跟踪该函数中调用的其他函数，可以通过指定 `depth` 参数来设置跟踪深度（不指定的话默认为 1）。

```python
@pysnooper.snoop(depth=2)
def demo_func():
		...
```

###  设置调试日志的前缀

当你在使用 PySnooper 跟踪多个函数时，调试的日志会显得杂乱无章，不方便查看。

在这种情况下，PySnooper 提供了一个参数，方便你为不同的函数设置不同的标志，方便你在查看日志时进行区分。

```python
@pysnooper.snoop(output="/var/log/debug.log", prefix="demo_func: ")
def demo_func():
    ...
```

效果如下

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-416253.png)

###  设置最大的输出长度

默认情况下，PySnooper 输出的变量和异常信息，如果超过 100 个字符，被会截断为 100 个字符。

当然你也可以通过指定参数 进行修改

```python
@pysnooper.snoop(max_variable_length=200）
def demo_func():
    ...
```

您也可以使用max_variable_length=None它从不截断它们。

```python
@pysnooper.snoop(max_variable_length=None）
def demo_func():
    ...
```



###  支持多线程调试模式

PySnooper 同样支持多线程的调试，通过设置参数 `thread_info=True`，它就会在日志中打印出是在哪个线程对变量进行的修改。

```python
@pysnooper.snoop(thread_info=True)
def demo_func():
    ...
```

效果如下

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-432256.png)



###  自定义对象的格式输出

`pysnooper.snoop()` 函数有一个参数是 `custom_repr`，它接收一个元组对象。

在这个元组里，你可以指定特定类型的对象以特定格式进行输出。



这边我举个例子。

假如我要跟踪 person 这个 Person 类型的对象，由于它不是常规的 Python 基础类型，PySnooper 是无法正常输出它的信息的。

因此我在 `pysnooper.snoop()` 函数中设置了 `custom_repr` 参数，该参数的第一个元素为 Person，第二个元素为 `print_persion_obj` 函数。

PySnooper 在打印对象的调试信息时，会逐个判断它是否是 Person 类型的对象，若是，就将该对象传入 `print_persion_obj` 函数中，由该函数来决定如何显示这个对象的信息。

```python
class Person:pass

def print_person_obj(obj):
    return f"<Person {obj.name} {obj.age} {obj.gender}>"
  
@pysnooper.snoop(custom_repr=(Person, print_person_obj))
def demo_func():
    ...
```



完整的代码如下

```python
import pysnooper

class Person:pass


def print_person_obj(obj):
    return f"<Person {obj.name} {obj.age} {obj.gender}>"

@pysnooper.snoop(custom_repr=(Person, print_person_obj))
def demo_func():
    person = Person()
    person.name = "写代码的明哥"
    person.age = 27
    person.gender = "male"

    return person

def main():
    profile = demo_func()

main()
```

运行一下，观察一下效果。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-446264.png)



如果你要自定义格式输出的有很多个类型，那么 `custom_repr` 参数的值可以这么写

```python
@pysnooper.snoop(custom_repr=((Person, print_person_obj), (numpy.ndarray, print_ndarray)))
def demo_func():
    ...
```

还有一点我提醒一下，元组的第一个元素可以是类型（如类名Person 或者其他基础类型 list等），也可以是一个判断对象类型的函数。

也就是说，下面三种写法是等价的。

```python
# 【第一种写法】
@pysnooper.snoop(custom_repr=(Person, print_persion_obj))
def demo_func():
    ...


# 【第二种写法】
def is_persion_obj(obj):
    return isinstance(obj, Person)

@pysnooper.snoop(custom_repr=(is_persion_obj, print_persion_obj))
def demo_func():
    ...


# 【第三种写法】
@pysnooper.snoop(custom_repr=(lambda obj: isinstance(obj, Person), print_persion_obj))
def demo_func():
    ...
```



以上就是明哥今天给大家介绍的一款调试神器（`PySnooper`） 的详细使用手册，是不是觉得还不错？



#  【调试技巧】使用 PyCharm 进行远程调试

一般情况下，我们开发调试都是在个人PC上完成，遇到问题，开一下 `Pycharm` 的调试器，很快就能找到问题所在。

可有些时候，项目代码的运行会对运行环境有依赖，必须在部署了相关依赖组件的服务器上才可以运行，这就直接导致了我们不能在本地进行调试。

对于这种特殊的场景，就我所知，有如下两种解决方案：

- pdb
- Remote Debug

本篇文章会先讲第二种方案，它是 `专业版Pycharm` 才开放的功能，需要你安装专业版的Pycharm，具体升级破解步骤，请自行 Google，这里不涉及。

远程调试的意思，是让我们可以在我们在 PC 上用 Pycharm 的图形化界面来进行调试代码，它和本地调试没有太大的区别，原来怎么调试的现在还是怎么调试。

区别就在于，本地调试不需要事前配置，只要你的代码准备好了，随时可以开始 Debug 。而远程调试需要不少前置步骤，这些设置过程，也是本文的主要内容。

##  新建一个项目

首先，要在Pycharm中新建一个空的项目，后面我们拉服务器上的项目代码就会放置在这个项目目录下。我这边的名字是 NOVA，你可以自己定义。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-381251.png)

##  配置连接服务器

Tools -> Deployment -> configuration

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-398255.png)

添加一个`Server`

- Name：填你的服务器的IP

- Type：设定为SFTP

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-411251.png)

点击`OK`后，进入如下界面，你可以按我的备注，填写信息：

- SFTP host：公网ip
- Port：服务器开放的ssh端口
- Root path：你要调试的项目代码目录
- Username：你登陆服务器所用的用户
- Auth type：登陆类型，若用密码登陆的就是Password
- Password：选密码登陆后，这边输入你的登陆密码，可以选择保存密码。

这里请注意，要确保你的电脑可以ssh连接到你的服务器，不管是密钥登陆还是密码登陆，如果开启了白名单限制要先解除。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-426253.png)

填写完成后，切换到`Mappings`选项卡，在箭头位置，填写`\`

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-441254.png)

以上服务器信息配置，全部正确填写完成后，点击`OK`

接下来，我们要连接远程服务器了。
Tools -> Deployment -> Browse Remote Host

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-456252.png)

##  下载项目代码

如果之前填写的服务器登陆信息准确无误的话，现在就可以看到远程的项目代码。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-471257.png)

选择下载远程代码要本地。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-486253.png)

下载完成提示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-501255.png)

现在的IDE界面应该是这样子的。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-516260.png)

##  下载远程解释器

为什么需要这步呢？

远程调试是在远端的服务器上运行的，它除了依赖其他组件之外，还会有一些很多Python依赖包我们本地并没有。

进入 File -> Settings
按图示，添加远程解释器。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-531252.png)

填写远程服务器信息，跟之前的一样，不再赘述。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-549253.png)

点击`OK`后，会自动下载远程解释器。如果你的项目比较大，这个时间可能会比较久，请耐心等待。

##  添加程序入口

因为我们要在本地DEBUG，所以你一定要知道你的项目的入口程序。如果这个入口程序已经包含在你的项目代码中，那么请略过这一步。

如果没有，就请自己生成入口程序。

比如，我这边的项目，在服务器上是以一个服务运行的。而我们都知道服务的入口是`Service文件`。
`cat /usr/lib/systemd/system/openstack-nova-compute.service`

```
[Unit]
Description=OpenStack Nova Compute Server
After=syslog.target network.target libvirtd.service

[Service]
Environment=LIBGUESTFS_ATTACH_METHOD=appliance
Type=notify
NotifyAccess=all
TimeoutStartSec=0
Restart=always
User=nova
ExecStart=/usr/bin/nova-compute

[Install]
WantedBy=multi-user.target
```

看到那个`ExecStart`没有？那个就是我们程序的入口。
我们只要将其拷贝至我们的Pycharm中，并向远程同步该文件。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-561255.png)

##  调试前设置

开启代码自动同步，这样，我们对代码的修改Pycharm都能识别，并且为我们提交到远程服务器。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-576252.png)

开启 `Gevent compatible`，如果不开启，在调试过程中，很可能出现无法调试，或者无法追踪/查看变量等问题。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-621252.png)

##  开始调试代码

在你的程序入口文件处，点击右键，选择Debug即可。

如果你的程序入口，需要引入参数，这是经常有的事，可以的这里配置。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-591253.png)

配置完点击保存即可。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171028-607254.png)

##  友情提醒

按照文章的试调试代码，会自动同步代码至远端，千万不要在生产环境使用，一定要在开发环境中使用，否则后果自负。

调试工具给了程序员提供了很大的便利，但还是希望你不要过度依赖。尽量在每次写代码的时候，都追求一次成型，提高自己的编码能力。

#  【调试技巧】报错后直接切换pdb调试

前面的文章里介绍了两种 pdb 的调试入口，也是大部分所熟知的。

这里再带大家回顾一下

**第一种**：指定 `-m pdb` 来开启

```python
$ python -m pdb pdb_demo.py
```

**第二种**：使用 `pdb.set_trace()` 在代码中设置断点

```python
import pdb

pdb.set_trace()
```

但其实，pdb 还另外两种调试方法，第一种方法，可能有 99% 的开发者都没用过，甚至连见过都没有。

这两种方法，是配合 Python Console 的交互界面来实现的。

首先我准备好一个名为 `utils.py` 的 Python文件，里面定义了一个 sum 的工具函数（仅作演示用）。

```python
def sum(*args):
    result = 0
    for arg in args:
        result += arg

    return result
```

然后在终端敲入 Python 进入 Console 的模式，导入这个模块，并调用 sum 函数，在正常情况下，函数可以正常工作。

```python
>>> import utils
>>> utils.sum(1,2,3)
6
```

但如果你的参数类型传成了 str，函数就会报错啦~

```python
>>> utils.sum(1,2,"3")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/Users/MING/utils.py", line 4, in sum
    result += arg
TypeError: unsupported operand type(s) for +=: 'int' and 'str'
```

由于这里的报错是我刻意触发的，从报错来看，是很容易定位的。

但是在实际应用中，难免会遇到一些无法从报错信息直接判断 bug 所在的情况。

这个时候，如果可以在报错后，切换到 pdb 的调试模式就好了~

**事实上，pdb 是支持这种用法的。**

只要你在当前的会话中，导入 pdb，再执行 `pdb.pn()`，就可以切换到熟悉的 pdb 调试界面，并在抛错的地方打上断点，然后你就可以任意的查看运行时的变量信息。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-792252.png)

如果你不是想等报错了再调试，而是一开始就想进入调试模式，可以使用 `pdb.runcall()` 函数

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python中文指南-20211128-171029-806254.png)

有的同学可能还会想到 `pdb.run()`  和 `pdb.runeval()` 这两个函数，但这两种方法，是需要提前在函数调试断点的，这就比较麻烦了，一般情况下不推荐使用。

综上所述，今天 给大家介绍了两种新的 pdb 调试入口：

1.  `pdb.pm()`：在出错后直接切换到调试模式，并定位到报错位置。 -- **今天的重点**
2.  `pdb.runcall()`：可以在不设置断点的情况下，直接调试代码片段。

