# 默默无闻的省略号很好用

在Python中，一切皆对象，省略号也不例外。

在 Python 3 中你可以直接写  `...` 来得到它 

```python
>>> ...
Ellipsis
>>> type(...)
<class 'ellipsis'>
```

而在 Python 2 中没有`...` 这个语法，只能直接写Ellipsis来获取。

```python
>>> Ellipsis
Ellipsis
>>> type(Ellipsis)
<type 'ellipsis'>
>>>
```

它转为布尔值时为真

```python
>>> bool(...)
True
```

最后，这东西是一个单例。

```python
>>> id(...)
4362672336
>>> id(...)
4362672336
```

那这东西有啥用呢？

1. 它是 Numpy 的一个语法糖
2. 在 Python 3 中可以使用 ... 代替 pass

```shell
$ cat demo.py
def func01():
    ...

def func02():
    pass

func01()
func02()

print("ok")

$ python3 demo.py
ok
```



#  使用 end 来结束代码块

有不少编程语言，循环、判断代码块需要用 end 标明结束，这样一定程度上会使代码逻辑更加清晰一点。

但是其实在 Python 这种严格缩进的语言里并没有必要这样做。

如果你真的想用，也不是没有办法，具体你看下面这个例子。

```python
__builtins__.end = None


def my_abs(x):
    if x > 0:
        return x
    else:
        return -x
    end
end

print(my_abs(10))
print(my_abs(-10))
```

执行后，输出如下

```shell
[root@localhost ~]$ python demo.py 
10
10
```





#  可直接运行的 zip 包



我们可以经常看到有 Python 包，居然可以以 zip 包进行发布，并且可以不用解压直接使用。

这与大多数人的认识的 Python 包格式不一样，正常人认为 Python 包的格式要嘛 是 egg，要嘛是whl 格式。

那么这个zip 是如何制作的呢，请看下面的示例。

```shell
[root@localhost ~]# ls -l demo
total 8
-rw-r--r-- 1 root root 30 May  8 19:27 calc.py
-rw-r--r-- 1 root root 35 May  8 19:33 __main__.py
[root@localhost ~]# 
[root@localhost ~]# cat demo/__main__.py
import calc

print(calc.add(2, 3))
[root@localhost ~]# 
[root@localhost ~]# cat demo/calc.py 
def add(x, y):
    return x+y
[root@localhost ~]# 
[root@localhost ~]# python -m zipfile -c demo.zip demo/*
[root@localhost ~]# 
```

制作完成后，我们可以执行用 python 去执行它

```shell
[root@localhost ~]# python demo.zip
5
[root@localhost ~]#
```





#  反斜杠的倔强: 不写最后



`\` 在 Python 中的用法主要有两种

**1、在行尾时，用做续行符**

   ```python
[root@localhost ~]$ cat demo.py 
print("hello "\
      "world")
[root@localhost ~]$ 
[root@localhost ~]$ python demo.py
hello world
   ```



**2、在字符串中，用做转义字符，可以将普通字符转化为有特殊含义的字符。**

```python
>>> str1='\nhello'　　＃换行
>>> print(str1)

hello
>>> str2='\thello'　　＃tab
>>> print(str2)
	hello
```

但是如果你用单`\`结尾是会报语法错误的

```python
>>> str3="\"
  File "<stdin>", line 1
    str3="\"
           ^
SyntaxError: EOL while scanning string literal
```

就算你指定它是个 raw 字符串，也不行。

```python
>>> str3=r"\"
  File "<stdin>", line 1
    str3=r"\"
            ^
SyntaxError: EOL while scanning string literal
```





#  如何修改解释器提示符



这个当做今天的一个小彩蛋吧。应该算是比较冷门的，估计知道的人很少了吧。

正常情况下，我们在 终端下 执行Python 命令是这样的。

```python
>>> for i in range(2):
...     print (i)
...
0
1
```

你是否想过 `>>>` 和 `...` 这两个提示符也是可以修改的呢？

```python
>>> import sys                      
>>> sys.ps1                         
'>>> '                              
>>> sys.ps2                         
'... '                              
>>>                                 
>>> sys.ps2 = '---------------- '                 
>>> sys.ps1 = 'Python编程时光>>>'       
Python编程时光>>>for i in range(2):     
----------------    print (i)                    
----------------                                 
0                                   
1                                   
```





#  简洁而优雅的链式比较



先给你看一个示例：

```python
>>> False == False == True
False
```

你知道这个表达式为什么会会返回 False 吗？

它的运行原理与下面这个类似，是不是有点头绪了：

```python
if 80 < score <= 90:
    print("成绩良好")
```

如果你还是不明白，那我再给你整个第一个例子的等价写法。

```python
>>> False == False and False == True
False
```

这个用法叫做链式比较。





#  and 和 or 的短路效应



and 和 or 是我们再熟悉不过的两个逻辑运算符，在 Python 也有它的妙用。

- 当一个 **or 表达式**中所有值都为真，Python会选择第一个值

- 当一个 **and 表达式** 所有值都为真，Python 会选择最后一个值。

示例如下：

```python
>>>(2 or 3) * (5 and 6 and 7)
14  # 2*7
```





#  连接多个列表最极客的方式



```python
>>> a = [1,2]
>>> b = [3,4]
>>> c = [5,6]
>>>
>>> sum((a,b,c), [])
[1, 2, 3, 4, 5, 6]
```





#  字典居然是可以排序的？



在 Python 3.6 之前字典不可排序的思想，似乎已经根深蒂固。

```python
# Python2.7.10
>>> mydict = {str(i):i for i in range(5)}
>>> mydict
{'1': 1, '0': 0, '3': 3, '2': 2, '4': 4}
```

假如哪一天，有人跟你说字典也可以是有序的，不要惊讶，那确实是真的

在 Python3.6 + 中字典已经是有序的，并且效率相较之前的还有所提升，具体信息你可以去查询相关资料。

```python
# Python3.6.7
>>> mydict = {str(i):i for i in range(5)}
>>> mydict
{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}
```







#  哪些情况下不需要续行符？



在写代码时，为了代码的可读性，代码的排版是尤为重要的。

为了实现高可读性的代码，我们常常使用到的就是续行符 `\`。

```python
>>> a = 'talk is cheap,'\
...     'show me the code.'
>>>
>>> print(a)
talk is cheap,show me the code.
```

那有哪些情况下，是不需要写续行符的呢？

经过总结，在这些符号中间的代码换行可以省略掉续行符：`[]`,`()`,`{}`

```python
>>> my_list=[1,2,3,
...          4,5,6]

>>> my_tuple=(1,2,3,
...           4,5,6)

>>> my_dict={"name": "MING",
...          "gender": "male"}
```

另外还有，在多行文本注释中  `'''` ，续行符也是可以不写的。

```python
>>> text = '''talk is cheap,
... show me code.'''
>>>
```

但是这种写法回车会自动转化为 `\n`

```python
>>> text = '''talk is cheap,
... show me code.'''
>>> text
'talk is cheap,\nshow me code.'
```



#  用户无感知的小整数池

为避免整数频繁申请和销毁内存空间，Python 定义了一个小整数池 [-5, 256] 这些整数对象是提前建立好的，不会被垃圾回收。

以下代码请在 终端Python环境下测试，如果你是在IDE中测试，由于 IDE 的影响，效果会有所不同。

```python
>>> a = -6
>>> b = -6
>>> a is b
False

>>> a = 256
>>> b = 256
>>> a is b
True

>>> a = 257
>>> b = 257
>>> a is b
False

>>> a = 257; b = 257
>>> a is b
True
```

**问题又来了：最后一个示例，为啥是True？**

因为当你在同一行里，同时给两个变量赋同一值时，解释器知道这个对象已经生成，那么它就会引用到同一个对象。如果分成两行的话，解释器并不知道这个对象已经存在了，就会重新申请内存存放这个对象。





#  神奇的 intern 机制



字符串类型作为Python中最常用的数据类型之一，Python解释器为了提高字符串使用的效率和使用性能，做了很多优化。

例如：Python解释器中使用了 intern（字符串驻留）的技术来提高字符串效率，什么是intern机制？就是同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，是共用的，当然，肯定不能改变，这也决定了字符串必须是不可变对象。

```python
>>> s1="hello"
>>> s2="hello"
>>> s1 is s2
True

# 如果有空格，默认不启用intern机制
>>> s1="hell o"
>>> s2="hell o"
>>> s1 is s2
False

# 如果一个字符串长度超过20个字符，不启动intern机制
>>> s1 = "a" * 20
>>> s2 = "a" * 20
>>> s1 is s2
True

>>> s1 = "a" * 21
>>> s2 = "a" * 21
>>> s1 is s2
False

>>> s1 = "ab" * 10
>>> s2 = "ab" * 10
>>> s1 is s2
True

>>> s1 = "ab" * 11
>>> s2 = "ab" * 11
>>> s1 is s2
False
```





#  site-packages和 dist-packages



如果你足够细心，你会在你的机器上，有些包是安装在 **site-packages** 下，而有些包安装在 **dist-packages** 下。

**它们有什么区别呢？**

一般情况下，你只见过 site-packages 这个目录，而你所安装的包也将安装在 这个目录下。

而 dist-packages 其实是 debian 系的 Linux 系统（如 Ubuntu）才特有的目录，当你使用 apt 去安装的 Python 包会使用 dist-packages，而你使用 pip 或者 easy_install 安装的包还是照常安装在 site-packages 下。

Debian 这么设计的原因，是为了减少不同来源的 Python 之间产生的冲突。

如何查找 Python 安装目录

```python
>>> from distutils.sysconfig import get_python_lib
>>> print(get_python_lib())
/usr/lib/python2.7/site-packages
```





#  argument 和 parameter 的区别?



arguments 和 parameter 的翻译都是参数，在中文场景下，二者混用基本没有问题，毕竟都叫参数嘛。

但若要严格再进行区分，它们实际上还有各自的叫法

- parameter：形参（**formal parameter**），体现在函数内部，作用域是这个函数体。
- argument ：实参（**actual parameter**），调用函数实际传递的参数。

举个例子，如下这段代码，`"error"` 为 argument，而 msg 为 `parameter`。

```python
def output_msg(msg):
	print(msg)
	
output_msg("error")
```







#  /usr/bin/env python 有什么用？



我们经常会在别人的脚本或者项目的入口文件里看到第一行是下面这样

```shell
#!/usr/bin/python
```

或者这样

```shell
#!/usr/bin/env python
```

这两者有什么区别呢？

稍微接触过 linux 的人都知道 `/usr/bin/python` 就是我们执行 `python` 进入console 模式里的 `python` 

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-669807.png)

而当你在可执行文件头里使用 `#!` + `/usr/bin/python` ，意思就是说你得用哪个软件 （python）来执行这个文件。

那么加和不加有什么区别呢？

不加的话，你每次执行这个脚本时，都得这样： `python xx.py` ，

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-700809.png)

有没有一种方式？可以省去每次都加 `python` 呢？

当然有，你可以文件头里加上`#!/usr/bin/python` ，那么当这个文件有可执行权限 时，只直接写这个脚本文件，就像下面这样。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-687809.png)

明白了这个后，再来看看 `!/usr/bin/env python` 这个 又是什么意思 ？

当我执行 `env python` 时，自动进入了 python console 的模式。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-715812.png)

这是为什么？和 直接执行 python 好像没什么区别呀

当你执行 `env python` 时，它其实会去 `env | grep PATH` 里（也就是 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin ）这几个路径里去依次查找名为python的可执行文件。

找到一个就直接执行，上面我们的 python 路径是在 `/usr/bin/python`  里，在 `PATH` 列表里倒数第二个目录下，所以当我在  `/usr/local/sbin` 下创建一个名字也为 python 的可执行文件时，就会执行 `/usr/local/sbin/python` 了。

具体演示过程，你可以看下面。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-729806.png)

那么对于这两者，我们应该使用哪个呢？

个人感觉应该优先使用 `#!/usr/bin/env python`，因为不是所有的机器的 python 解释器都是 `/usr/bin/python` 。



#  dict() 与 {} 生成空字典有什么区别？



在初始化一个空字典时，有的人会写 dict()，而有的人会写成 {}

很多人会想当然的认为二者是等同的，但实际情况却不是这样的。

在运行效率上，{} 会比 dict() 快三倍左右。

使用 timeit 模块，可以轻松测出这个结果

```shell
$ python -m timeit -n 1000000 -r 5 -v "dict()"
raw times: 0.0996 0.0975 0.0969 0.0969 0.0994
1000000 loops, best of 5: 0.0969 usec per loop
$
$ python -m timeit -n 1000000 -r 5 -v "{}"
raw times: 0.0305 0.0283 0.0272 0.03 0.0317
1000000 loops, best of 5: 0.0272 usec per loop
```

那为什么会这样呢？

探究这个过程，可以使用 dis 模块

当使用 {} 时

```shell
$ cat demo.py
{}
$
$ python -m dis demo.py
  1           0 BUILD_MAP                0
              2 POP_TOP
              4 LOAD_CONST               0 (None)
              6 RETURN_VALUE
```

当使用 dict() 时：

```shell
$ cat demo.py
dict()
$
$ python -m dis demo.py
  1           0 LOAD_NAME                0 (dict)
              2 CALL_FUNCTION            0
              4 POP_TOP
              6 LOAD_CONST               0 (None)
              8 RETURN_VALUE
```

可以发现使用 dict()，会多了个调用函数的过程，而这个过程会有进出栈的操作，相对更加耗时。





#  有趣但没啥用的 import 用法



import 是 Python 导包的方式。

你知道 Python 中内置了一些很有（wu）趣（liao）的包吗？

**Hello World**

```
>>> import __hello__
Hello World!
```

**Python之禅**

```
>>> import this

The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let's do more of those!
```

**反地心引力漫画**

在 cmd 窗口中导入`antigravity`

```
>>> import antigravity
```

就会自动打开一个网页。
![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-579808.png)





#  正负得负，负负得正



从初中开始，我们就开始接触了`负数` ，并且都知道了`负负得正` 的思想。

Python 作为一门高级语言，它的编写符合人类的思维逻辑，包括 `负负得正` 。

```python
>>> 5-3
2
>>> 5--3
8
>>> 5+-3
2
>>> 5++3
8
>>> 5---3
2
```







#  return不一定都是函数的终点



众所周知，try…finally… 的用法是：不管try里面是正常执行还是有报异常，最终都能保证finally能够执行。

同时我们又知道，一个函数里只要遇到 return 函数就会立马结束。

那问题就来了，以上这两种规则，如果同时存在，Python 解释器会如何选择？哪个优先级更高？

写个示例验证一下，就明白啦

```python
>>> def func():
...     try:
...         return 'try'
...     finally:
...         return 'finally'
...
>>> func()
'finally'
```

从输出中，我们可以发现：在try…finally…语句中，try中的 return 会被直接忽视（这里的 return 不是函数的终点），因为要保证 finally 能够执行。

**如果 try 里的 return 真的是直接被忽视吗？**

我们都知道如果一个函数没有 return，会隐式的返回 None，假设 try 里的 return 真的是直接被忽视，那当finally  下没有显式的 return 的时候，是不是会返回None呢？

还是写个 示例来验证一下：

```python
>>> def func():
...     try:
...         return 'try'
...     finally:
...         print('finally')
... 
>>> 
>>> func()
finally
'try'
>>> 
```

从结果来看，当 finally 下没有 reutrn ，其实 try 里的 return 仍然还是有效的。

那结论就出来了，如果 finally 里有显式的 return，那么这个 return 会直接覆盖 try 里的 return，而如果 finally 里没有 显式的 return，那么 try 里的 return 仍然有效。





#  字符串里的缝隙是什么？



在Python中求一个字符串里，某子字符（串）出现的次数。

大家都懂得使用  count() 函数，比如下面几个常规例子：

```python
>>> "aabb".count("a")
2
>>> "aabb".count("b")
2
>>> "aabb".count("ab")
1
```

但是如果我想计算空字符串的个数呢？

```python
>>> "aabb".count("")
5
```

**奇怪了吧？**

不是应该返回 0 吗？怎么会返回 5？

实际上，在 Python 看来，两个字符之间都是一个空字符，通俗的说就是缝隙。

因此 对于 `aabb` 这个字符串在 Python 来看应该是这样的

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-819816.png)

理解了这个“**缝隙**” 的概念后，以下这些就好理解了。

```python
>>> (" " * 10).count("")
11
>>> 
>>> "" in ""
True
>>> 
>>> "" in "M"
True
```





#  Python2下 也能使用 print(“”)



可能会有不少人，觉得只有 Python 3 才可以使用 print()，而 Python 2 只能使用`print ""`。

但是其实并不是这样的。

在Python 2.6之前，只支持

```python
print "hello"
```

在Python 2.6和2.7中，可以支持如下三种

```python
print "hello"
print("hello")
print ("hello")
```

在Python3.x中，可以支持如下两种

```python
print("hello")
print ("hello")
```

虽然 在 Python 2.6+ 可以和 Python3.x+ 一样，像函数一样去调用 print ，但是这仅用于两个 python 版本之间的代码兼容，并不是说在 python2.6+下使用 print() 后，就成了函数。



#  字母也玩起了障眼法



以下我分别在 Python2.7 和 Python 3.7 的 console 模式下，运行了如下代码。

**在Python 2.x 中**

```
>>> valuе = 32
  File "<stdin>", line 1
    valuе = 32
        ^
SyntaxError: invalid syntax
```

**在Python 3.x 中**

```
>>> valuе = 32
>>> value
11
```

什么？没有截图你不信？

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-790810.png)



如果你在自己的电脑上尝试一下，结果可能是这样的

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-804823.png)



**怎么又好了呢？**

如果你想复现的话，请复制我这边给出的代码：`valuе = 32`



**这是为什么呢？**

原因在于，我上面使用的 value 变量名里的 `е` 又不是我们熟悉的 `e`，它是 Cyrillic（西里尔）字母。

```
>>> ord('е') # cyrillic 'e' (Ye)
1077
>>> ord('e') # latin 'e', as used in English and typed using standard keyboard
101
>>> 'е' == 'e'
False
```

细思恐极，在这里可千万不要得罪同事们，万一离职的时候，对方把你项目里的 `e` 全局替换成 `e`，到时候你就哭去吧，肉眼根本看不出来嘛。



#  数值与字符串的比较



在 Python2 中，数字可以与字符串直接比较。结果是数值永远比字符串小。

```Python
>>> 100000000 < ""
True
>>> 100000000 < "hello"
True
```

但在 Python3 中，却不行。

```python
>>> 100000000 < ""
TypeError: '<' not supported between instances of 'int' and 'str'
```







#  时有时无的切片异常



这是个简单例子，alist 只有5 个元素，当你取第 6 个元素时，会抛出索引异常。这与我们的认知一致。

```python
>>> alist = [0, 1, 2, 3, 4]
>>> alist[5]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
```

但是当你使用 alist[5:] 取一个区间时，即使 alist 并没有 第 6个元素，也不抛出异常，而是会返回一个新的列表。

```python
>>> alist = [0, 1, 2, 3, 4]
>>> alist[5:]
[]
>>> alist[100:]
[]
```







#  迷一样的字符串



示例一

```python
# Python2.7
>>> a = "Hello_Python"
>>> id(a)
32045616
>>> id("Hello" + "_" + "Python")
32045616

# Python3.7
>>> a = "Hello_Python"
>>> id(a)
38764272
>>> id("Hello" + "_" + "Python")
32045616
```

示例二

```python
>>> a = "MING"
>>> b = "MING"
>>> a is b
True

# Python2.7
>>> a, b = "MING!", "MING!"
>>> a is b
True

# Python3.7
>>> a, b = "MING!", "MING!"
>>> a is b
False
```

示例三

```python
# Python2.7
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
False

# Python3.7
>>> 'a' * 20 is 'aaaaaaaaaaaaaaaaaaaa'
True
>>> 'a' * 21 is 'aaaaaaaaaaaaaaaaaaaaa'
True
```





#  x 与 +x 等价吗？



在大多数情况下，这个等式是成立的。

```python
>>> n1 = 10086
>>> n2 = +n1
>>>
>>> n1 == n2
True
```

什么情况下，这个等式会不成立呢？

由于Counter的机制，`+` 用于两个 Counter 实例相加，而相加的结果如果元素的个数 `<=` 0，就会被丢弃。

```python
>>> from collections import Counter
>>> ct = Counter('abcdbcaa')
>>> ct
Counter({'a': 3, 'b': 2, 'c': 2, 'd': 1})
>>> ct['c'] = 0
>>> ct['d'] = -2
>>>
>>> ct
Counter({'a': 3, 'b': 2, 'c': 0, 'd': -2})
>>>
>>> +ct
Counter({'a': 3, 'b': 2})
```





#  += 不等同于=+



对列表 进行`+=` 操作相当于 extend，而使用 `=+` 操作是新增了一个列表。

因此会有如下两者的差异。

```python
# =+
>>> a = [1, 2, 3, 4]
>>> b = a
>>> a = a + [5, 6, 7, 8]
>>> a
[1, 2, 3, 4, 5, 6, 7, 8]
>>> b
[1, 2, 3, 4]


# += 
>>> a = [1, 2, 3, 4]
>>> b = a
>>> a += [5, 6, 7, 8]
>>> a
[1, 2, 3, 4, 5, 6, 7, 8]
>>> b
[1, 2, 3, 4, 5, 6, 7, 8]
```







#  循环中的局部变量泄露

在Python 2中 x 的值在一个循环执行之后被改变了。

```python
# Python2
>>> x = 1
>>> [x for x in range(5)]
[0, 1, 2, 3, 4]
>>> x
4
```

不过在Python3 中这个问题已经得到解决了。

```python
# Python3
>>> x = 1
>>> [x for x in range(5)]
[0, 1, 2, 3, 4]
>>> x
1
```





#  局部/全局变量傻傻分不清



在开始讲之前，你可以试着运行一下下面这小段代码。

```python
# demo.py
a = 1

def add():
    a += 1

add()
```

看似没有毛病，但实则已经犯了一个很基础的问题，运行结果如下：

```python
$ python demo.py
Traceback (most recent call last):
  File "demo.py", line 6, in <module>
    add()
  File "demo.py", line 4, in add
    a += 1
UnboundLocalError: local variable 'a' referenced before assignment
```

回顾一下，什么是局部变量？在非全局下定义声明的变量都是局部变量。

当程序运行到 `a += 1` 时，Python 解释器就认为在函数内部要给 `a` 这个变量赋值，当然就把 `a` 当做局部变量了，但是做为局部变量的 a 还没有被还没被定义。

因此报错是正常的。

理解了上面的例子，给你留个思考题。为什么下面的代码不会报错呢？

```python
$ cat demo.py
a = 1

def output():
    print(a)

output()

$ python demo.py
1
```







#  break /continue 和 上下文管理器哪个优先级高？



众所周知，在循环体中（无论是 for 还是 while），continue 会用来跳入下一个循环，而 break 则用来跳出某个循环体。

同时我们又知道：在上下文管理器中，被包裹的程序主体代码结束会运行上下文管理器中的一段代码（通常是资源的释放）。

但如果把上下文管理器放在一个循环体中，而在这个上下文管理器中执行了 break ，是否会直接跳出循环呢？

换句话说，上下文管理器与 break/continue 这两个规则哪一个优先级会更高一些？

这个问题其实不难，只要做一下试验都能轻易地得出答案，难就难在很多对这个答案都是半猜半疑，无法肯定地回答。

试验代码如下：

```python
import time
import contextlib

@contextlib.contextmanager
def runtime(value):
    time.sleep(1)
    print("start: a = " + str(value))
    yield
    print("end: a = " + str(value))


a = 0
while True:
    a+=1
    with runtime(a):
        if a % 2 == 0:
            break
```

从输出的结果来看，当 a = 2 时执行了 break ，此时的并不会直接跳出循环，依然要运行上下文管理器里清理释放资源的代码（示例中，我使用 print 来替代）。

```
start: a = 1
end: a = 1
start: a = 2
end: a = 2
```



另外还有几个与此类似的问题，我这里也直接给出答案，不再细说了

1. continue 与 break 一样，如果先遇到上下文管理器会先进行资源的释放
2. 上面只举例了 while 循环体，而 for 循环也是同样的。





# 如何像 awk一样分割字符串？



若你使用过 Shell 中的 awk 工具，会发现用它来分割字符串是非常方便的。特别是多个连续空格会被当做一个处理。

```shell
[root@localhost ~]# cat demo.txt 
hello      world
[root@localhost ~]# 
[root@localhost ~]# awk '{print$1,$2}' demo.txt 
hello world
```

可是转换到 Python 上面来呢？结果可能是这样的。

```python
>>> msg='hello    world'
>>> msg.split(' ')
['hello', '', '', '', 'world']
```

与我预想的结果不符，多个空格会被分割多次。

那有什么办法可以达到 awk 一样的效果呢？

有两种方法。

## 第一种方法

split函数不加参数，就能达到 awk 的效果

```python
>>> msg='hello    world'
>>> msg.split()
['hello', 'world']
```

其实不仅是空格，严格来说，只要是空字符（比如制表符、换行符），就可以使用

```python
>>> msg='hello \t \r\n world'
>>> msg.split()
['hello', 'world']
```

## 第二种方法

使用 filter 来辅助，这种适用于所有的分隔符，下面以 `-` 为分隔符来举例。

```python
>>> msg='hello----world'
>>> msg.split('-')
['hello', '', '', '', 'world']
>>> 
>>> filter(None, msg.split('-'))
['hello', 'world']
```

是不是很神奇，filter 印象中第一个参数接收的是 函数，这里直接传 None 居然有奇效。

查看了注释，原来是这个函数会适配 None 的情况，当第一个参数是None的时候，返回第二个参数（可迭代对象）中非空的值，非常方便。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-166969.png)

换用函数的写法，可以这样

```python
>>> msg='hello----world'
>>> msg.split('-')
['hello', '', '', '', 'world']
>>> 
>>> filter(lambda item: True if item else False, msg.split('-'))
['hello', 'world']
```





#  如何让大数变得更易于阅读？

当一个数非常大时，可能过百万，也可能上亿，太多位的数字 ，会给我们阅读带来很大的障碍。

比如下面这个数，你能一下子说出它是多少万呢，还是多少亿呢？

```
281028344
```

是不是没法很快的辩识出来？

这时候，你可以使用 `_` 来辅助标识，写成这样子就清晰多了

```
281_028_344
```

关键这种写法，在代码中并不会报错噢（Python2 不支持）

```python
>>> number=281_028_344
>>> number
281028344
```



