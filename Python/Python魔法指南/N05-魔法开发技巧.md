#  嵌套上下文管理的另类写法

当我们要写一个嵌套的上下文管理器时，可能会这样写

```python
import contextlib

@contextlib.contextmanager
def test_context(name):
    print('enter, my name is {}'.format(name))

    yield

    print('exit, my name is {}'.format(name))

with test_context('aaa'):
    with test_context('bbb'):
        print('========== in main ============')
```

输出结果如下

```python
enter, my name is aaa
enter, my name is bbb
========== in main ============
exit, my name is bbb
exit, my name is aaa
```

除此之外，你可知道，还有另一种嵌套写法

```python
with test_context('aaa'), test_context('bbb'):
    print('========== in main ============')
```





#  将嵌套 for 循环写成单行

我们经常会写如下这种嵌套的 for 循环代码

```python
list1 = range(1,3)
list2 = range(4,6)
list3 = range(7,9)
for item1 in list1:
    for item2 in list2:
      	for item3 in list3:
        	  print(item1+item2+item3)
```

这里仅仅是三个 for 循环，在实际编码中，有可能会有更多层。

这样的代码，可读性非常的差，很多人不想这么写，可又没有更好的写法。

这里介绍一种我常用的写法，使用 itertools 这个库来实现更优雅易读的代码。

```python
from itertools import product
list1 = range(1,3)
list2 = range(4,6)
list3 = range(7,9)
for item1,item2,item3 in product(list1, list2, list3):
    print(item1+item2+item3)
```

输出如下

```shell
$ python demo.py
12
13
13
14
13
14
14
15
```





#  单行实现 for 死循环如何写？

如果让你在不借助 while ，只使用 for 来写一个死循环？

**你会写吗？**

**如果你还说简单，你可以自己试一下。**

...

如果你尝试后，仍然写不出来，那我给出自己的做法。

```python
for i in iter(int, 1):pass
```



**是不是傻了？iter 还有这种用法？这为啥是个死循环？**

关于这个问题，你如果看中文网站，可能找不到相关资料。

还好你可以通过 IDE 看py源码里的注释内容，介绍了很详细的使用方法。

原来iter有两种使用方法。

- 通常我们的认知是第一种，将一个列表转化为一个迭代器。

- 而第二种方法，他接收一个 callable对象，和一个sentinel 参数。第一个对象会一直运行，直到它返回 sentinel 值才结束。

那`int` 呢？

这又是一个知识点，int 是一个内建方法。通过看注释，可以看出它是有默认值0的。你可以在console 模式下输入 `int()` 看看是不是返回0。 

由于int() 永远返回0，永远返回不了1，所以这个 for 循环会没有终点。一直运行下去。



#  如何关闭异常自动关联上下文？



当你在处理异常时，由于处理不当或者其他问题，再次抛出另一个异常时，往外抛出的异常也会携带原始的异常信息。

就像这样子。

```python
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError("Something bad happened")
```

从输出可以看到两个异常信息

```python
Traceback (most recent call last):
  File "demo.py", line 2, in <module>
    print(1 / 0)
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "demo.py", line 4, in <module>
    raise RuntimeError("Something bad happened")
RuntimeError: Something bad happened
```

如果在异常处理程序或 finally 块中引发异常，默认情况下，异常机制会隐式工作会将先前的异常附加为新异常的 `__context__`属性。这就是 Python 默认开启的自动关联异常上下文。

如果你想自己控制这个上下文，可以加个 from 关键字（`from` 语法会有个限制，就是第二个表达式必须是另一个异常类或实例。），来表明你的新异常是直接由哪个异常引起的。

```python
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError("Something bad happened") from exc
```

输出如下

```python
Traceback (most recent call last):
  File "demo.py", line 2, in <module>
    print(1 / 0)
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "demo.py", line 4, in <module>
    raise RuntimeError("Something bad happened") from exc
RuntimeError: Something bad happened
```



当然，你也可以通过`with_traceback()`方法为异常设置上下文`__context__`属性，这也能在`traceback`更好地显示异常信息。

```python
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError("bad thing").with_traceback(exc)
```



最后，如果我想彻底关闭这个自动关联异常上下文的机制？有什么办法呢？

可以使用 `raise...from None`，从下面的例子上看，已经没有了原始异常

```python
$ cat demo.py
try:
    print(1 / 0)
except Exception as exc:
    raise RuntimeError("Something bad happened") from None
$
$ python demo.py
Traceback (most recent call last):
  File "demo.py", line 4, in <module>
    raise RuntimeError("Something bad happened") from None
RuntimeError: Something bad happened
(PythonCodingTime)
```





#  自带的缓存机制不用白不用



缓存是一种将定量数据加以保存，以备迎合后续获取需求的处理方式，旨在加快数据获取的速度。

数据的生成过程可能需要经过计算，规整，远程获取等操作，如果是同一份数据需要多次使用，每次都重新生成会大大浪费时间。所以，如果将计算或者远程请求等操作获得的数据缓存下来，会加快后续的数据获取需求。

为了实现这个需求，Python 3.2 + 中给我们提供了一个机制，可以很方便地实现，而不需要你去写这样的逻辑代码。

这个机制实现于 functool 模块中的 lru_cache 装饰器。

```python
@functools.lru_cache(maxsize=None, typed=False)
```

参数解读：

- maxsize：最多可以缓存多少个此函数的调用结果，如果为None，则无限制，设置为 2 的幂时，性能最佳
- typed：若为 True，则不同参数类型的调用将分别缓存。

举个例子

```python
from functools import lru_cache

@lru_cache(None)
def add(x, y):
    print("calculating: %s + %s" % (x, y))
    return x + y

print(add(1, 2))
print(add(1, 2))
print(add(2, 3))
```

输出如下，可以看到第二次调用并没有真正地执行函数体，而是直接返回缓存里的结果

```shell
calculating: 1 + 2
3
3
calculating: 2 + 3
5
```





#  如何流式读取数G超大文件



使用 with...open... 可以从一个文件中读取数据，这是所有 Python 开发者都非常熟悉的操作。

但是如果你使用不当，也会带来很大的麻烦。

比如当你使用了 read 函数，其实 Python 会将文件的内容一次性地全部载入内存中，如果文件有 10 个G甚至更多，那么你的电脑就要消耗的内存非常巨大。

```python
# 一次性读取
with open("big_file.txt", "r") as fp:
    content = fp.read()
```

对于这个问题，你也许会想到使用 readline 去做一个生成器来逐行返回。

```python
def read_from_file(filename):
    with open(filename, "r") as fp:
        yield fp.readline()
```

可如果这个文件内容就一行呢，一行就 10个G，其实你还是会一次性读取全部内容。

最优雅的解决方法是，在使用 read 方法时，指定每次只读取固定大小的内容，比如下面的代码中，每次只读取 8kb 返回。

```python
def read_from_file(filename, block_size = 1024 * 8):
    with open(filename, "r") as fp:
        while True:
            chunk = fp.read(block_size)
            if not chunk:
                break

            yield chunk
```

上面的代码，功能上已经没有问题了，但是代码看起来还是有些臃肿。

 借助偏函数 和 iter 函数可以优化一下代码

```python
from functools import partial

def read_from_file(filename, block_size = 1024 * 8):
    with open(filename, "r") as fp:
        for chunk in iter(partial(fp.read, block_size), ""):
            yield chunk
```

如果你使用的是 Python 3.8 +，还有一种更直观、易于理解的写法，既不用使用偏函数，也不用掌握 iter 这种另类的用法。而只要用利用 海象运算符就可以，具体代码如下

```python
def read_from_file(filename, block_size = 1024 * 8):
    with open(filename, "r") as fp:
        while chunk := fp.read(block_size):
            yield chunk
```





#  实现类似 defer 的延迟调用



在 Golang 中有一种延迟调用的机制，关键字是 defer，例如下面的示例

```go
import "fmt"

func myfunc() {
    fmt.Println("B")
}

func main() {
    defer myfunc()
    fmt.Println("A")
}
```

输出如下，myfunc 的调用会在函数返回前一步完成，即使你将 myfunc 的调用写在函数的第一行，这就是延迟调用。

```
A
B
```

那么在 Python 中否有这种机制呢？

当然也有，只不过并没有 Golang 这种简便。

在 Python 可以使用 **上下文管理器** 达到这种效果

```python
import contextlib

def callback():
    print('B')

with contextlib.ExitStack() as stack:
    stack.callback(callback)
    print('A')
```

输出如下

```
A
B
```





#  如何快速计算函数运行时间

计算一个函数的运行时间，你可能会这样子做

```python
import time

start = time.time()

# run the function

end = time.time()
print(end-start)
```

你看看你为了计算函数运行时间，写了几行代码了。
​
有没有一种方法可以更方便地计算这个运行时间呢？
​
有。
​
有一个内置模块叫 timeit
​
使用它，只用一行代码即可

```python
import time
import timeit

def run_sleep(second):
    print(second)
    time.sleep(second)

# 只用这一行
print(timeit.timeit(lambda :run_sleep(2), number=5))
```

运行结果如下

```python
2
2
2
2
2
10.020059824
```





#  重定向标准输出到日志

假设你有一个脚本，会执行一些任务，比如说集群健康情况的检查。

检查完成后，会把各服务的的健康状况以 JSON 字符串的形式打印到标准输出。

如果代码有问题，导致异常处理不足，最终检查失败，是很有可能将一些错误异常栈输出到标准错误或标准输出上。

由于最初约定的脚本返回方式是以 JSON 的格式输出，此时你的脚本却输出各种错误异常，异常调用方也无法解析。

如何避免这种情况的发生呢？

我们可以这样做，把你的标准错误输出到日志文件中。

```python
import contextlib

log_file="/var/log/you.log"

def you_task():
	pass

@contextlib.contextmanager
def close_stdout():
    raw_stdout = sys.stdout
    file = open(log_file, 'a+')
    sys.stdout = file

    yield

    sys.stdout = raw_stdout
    file.close()
    
with close_stdout():
    you_task()
```



#  快速定位错误进入调试模式



当你在写一个程序时，最初的程序一定遇到不少零零散散的错误，这时候就免不了调试一波。

如果你和我一样，习惯使用 pdb 进行调试的话，一定有所体会，通常我们都要先把 `pdb.set_trace()` 去掉，让程序畅通无阻，直到它把异常抛出来。

出现异常后，再使用 vim 跳转到抛出异常的位置，敲入 `import pdb;pdb.set_trace()` ，然后再到运行，进入调试模式，找到问题并修改代码后再去掉我们加上的那行 pdb 的代码。

如此反复这样一个过程，直到最后程序没有异常。

你应该能够感受到这个过程有多繁锁，令人崩溃。

接下来介绍一种，可以让你不需要修改源代码，就可以在异常抛出时，快速切换到调试模式，进入 『案发现场』排查问题。

方法很简单，只需要你在执行脚本时，加入 `-i` 参考 

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-880030.png)

如果你的程序没有任何问题，加上 `-i` 后又会有什么不一样呢？

从下图可以看出，程序执行完成后会自动进入 console 交互模式。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-722633.png)





#  在程序退出前执行代码的技巧

使用 atexit 这个内置模块，可以很方便地注册退出函数。

不管你在哪个地方导致程序崩溃，都会执行那些你注册过的函数。

示例如下

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-834868.png)

如果`clean()`函数有参数，那么你可以不用装饰器，而是直接调用`atexit.register(clean_1, 参数1, 参数2, 参数3='xxx')`。

可能你有其他方法可以处理这种需求，但肯定比不上使用 atexit 来得优雅，来得方便，并且它很容易扩展。

但是使用 atexit 仍然有一些局限性，比如：

- 如果程序是被你没有处理过的系统信号杀死的，那么注册的函数无法正常执行。
- 如果发生了严重的 Python 内部错误，你注册的函数无法正常执行。
- 如果你手动调用了`os._exit()`，你注册的函数无法正常执行。



#  逗号也有它的独特用法

逗号，虽然是个很不起眼的符号，但在 Python 中也有他的用武之地。

**第一个用法**

元组的转化

```shell
[root@localhost ~]# cat demo.py 
def func():
    return "ok",

print(func())
[root@localhost ~]# python3 demo.py 
('ok',)
```

**第二个用法**

print 的取消换行

```shell
[root@localhost ~]# cat demo.py 
for i in range(3):
    print i
[root@localhost ~]# 
[root@localhost ~]# python demo.py 
0
1
2
[root@localhost ~]# 
[root@localhost ~]# vim demo.py 
[root@localhost ~]# 
[root@localhost ~]# cat demo.py 
for i in range(3):
    print i,
[root@localhost ~]# 
[root@localhost ~]# python demo.py 
0 1 2
[root@localhost ~]#
```





#  如何在运行状态查看源代码？

查看函数的源代码，我们通常会使用 IDE 来完成。

比如在 PyCharm 中，你可以 Ctrl + 鼠标点击 进入函数的源代码。

那如果没有 IDE 呢？

当我们想使用一个函数时，如何知道这个函数需要接收哪些参数呢？

当我们在使用函数时出现问题的时候，如何通过阅读源代码来排查问题所在呢？



这时候，我们可以使用 inspect 来代替 IDE 帮助你完成这些事

```python
# demo.py
import inspect


def add(x, y):
    return x + y

print("===================")
print(inspect.getsource(add))
```

运行结果如下

```shell
$ python demo.py
===================
def add(x, y):
    return x + y
```



#  单分派泛函数如何写？

泛型，如果你尝过java，应该对他不陌生吧。但你可能不知道在 Python 中（3.4+ ），也可以实现 简单的泛型函数。

在Python中只能实现基于单个（第一个）参数的数据类型来选择具体的实现方式，官方名称 是 `single-dispatch`。你或许听不懂，说人话，就是可以实现第一个参数的数据类型不同，其调用的函数也就不同。

`singledispatch` 是 PEP443 中引入的，如果你对此有兴趣，PEP443 应该是最好的学习文档：https://www.python.org/dev/peps/pep-0443/

它使用方法极其简单，只要被`singledispatch` 装饰的函数，就是一个`single-dispatch` 的泛函数（`generic functions`）。

- **单分派**：根据一个参数的类型，以不同方式执行相同的操作的行为。
- **多分派**：可根据多个参数的类型选择专门的函数的行为。
- **泛函数**：多个函数绑在一起组合成一个泛函数。

这边举个简单的例子。

```python
from functools import singledispatch

@singledispatch
def age(obj):
    print('请传入合法类型的参数！')

@age.register(int)
def _(age):
    print('我已经{}岁了。'.format(age))

@age.register(str)
def _(age):
    print('I am {} years old.'.format(age))


age(23)  # int
age('twenty three')  # str
age(['23'])  # list
```

执行结果

```
我已经23岁了。
I am twenty three years old.
请传入合法类型的参数！
```

说起泛型，其实在 Python 本身的一些内建函数中并不少见，比如 `len()` ， `iter()`，`copy.copy()` ，`pprint()` 等

你可能会问，它有什么用呢？实际上真没什么用，你不用它或者不认识它也完全不影响你编码。

我这里举个例子，你可以感受一下。

大家都知道，Python 中有许许多的数据类型，比如 str，list， dict， tuple 等，不同数据类型的拼接方式各不相同，所以我这里我写了一个通用的函数，可以根据对应的数据类型对选择对应的拼接方式拼接，而且不同数据类型我还应该提示无法拼接。以下是简单的实现。

```python
def check_type(func):
    def wrapper(*args):
        arg1, arg2 = args[:2]
        if type(arg1) != type(arg2):
            return '【错误】：参数类型不同，无法拼接!!'
        return func(*args)
    return wrapper


@singledispatch
def add(obj, new_obj):
    raise TypeError

@add.register(str)
@check_type
def _(obj, new_obj):
    obj += new_obj
    return obj


@add.register(list)
@check_type
def _(obj, new_obj):
    obj.extend(new_obj)
    return obj

@add.register(dict)
@check_type
def _(obj, new_obj):
    obj.update(new_obj)
    return obj

@add.register(tuple)
@check_type
def _(obj, new_obj):
    return (*obj, *new_obj)

print(add('hello',', world'))
print(add([1,2,3], [4,5,6]))
print(add({'name': 'wangbm'}, {'age':25}))
print(add(('apple', 'huawei'), ('vivo', 'oppo')))

# list 和 字符串 无法拼接
print(add([1,2,3], '4,5,6'))
```

输出结果如下

```
hello, world
[1, 2, 3, 4, 5, 6]
{'name': 'wangbm', 'age': 25}
('apple', 'huawei', 'vivo', 'oppo')
【错误】：参数类型不同，无法拼接!!
```

如果不使用singledispatch 的话，你可能会写出这样的代码。

```python
def check_type(func):
    def wrapper(*args):
        arg1, arg2 = args[:2]
        if type(arg1) != type(arg2):
            return '【错误】：参数类型不同，无法拼接!!'
        return func(*args)
    return wrapper

@check_type
def add(obj, new_obj):
    if isinstance(obj, str) :
        obj += new_obj
        return obj

    if isinstance(obj, list) :
        obj.extend(new_obj)
        return obj

    if isinstance(obj, dict) :
        obj.update(new_obj)
        return obj

    if isinstance(obj, tuple) :
        return (*obj, *new_obj)

print(add('hello',', world'))
print(add([1,2,3], [4,5,6]))
print(add({'name': 'wangbm'}, {'age':25}))
print(add(('apple', 'huawei'), ('vivo', 'oppo')))

# list 和 字符串 无法拼接
print(add([1,2,3], '4,5,6'))
```

输出如下

```
hello, world
[1, 2, 3, 4, 5, 6]
{'name': 'wangbm', 'age': 25}
('apple', 'huawei', 'vivo', 'oppo')
【错误】：参数类型不同，无法拼接!!
```



#  让我爱不释手的用户环境

当你在机器上并没有 root 权限时，如何安装 Python 的第三方包呢？

可以使用 `pip install --user pkg` 将你的包安装在你的用户环境中，该用户环境与全局环境并不冲突，并且多用户之间相互隔离，互不影响。

```shell
# 在全局环境中未安装 requests
[root@localhost ~]$ pip list | grep requests
[root@localhost ~]$ su - wangbm

# 由于用户环境继承自全局环境，这里也未安装
[wangbm@localhost ~]$ pip list | grep requests
[wangbm@localhost ~]$ pip install --user requests
[wangbm@localhost ~]$ pip list | grep requests
requests (2.22.0)
[wangbm@localhost ~]$

# 从 Location 属性可发现 requests 只安装在当前用户环境中
[wangbm@localhost ~]$ pip show requests
---
Metadata-Version: 2.1
Name: requests
Version: 2.22.0
Summary: Python HTTP for Humans.
Home-page: http://python-requests.org
Author: Kenneth Reitz
Author-email: me@kennethreitz.org
Installer: pip
License: Apache 2.0
Location: /home/wangbm/.local/lib/python2.7/site-packages
[wangbm@localhost ~]$ exit
logout

# 退出 wangbm 用户，在 root 用户环境中发现 requests 未安装
[root@localhost ~]$ pip list | grep requests
[root@localhost ~]$
```





#  字符串的分割技巧

当我们对字符串进行分割时，且分割符是 `\n`，有可能会出现这样一个窘境：

```python
>>> str = "a\nb\n"
>>> print(str)
a
b

>>> str.split('\n')
['a', 'b', '']
>>>
```

会在最后一行多出一个元素，这可就太多余了吧。

实际上对于这种情况，你可以直接这样子

```python
>>> str = "a\nb\n"
>>>
>>> str.split()
['a', 'b']
```

即使是多个换行符，也照样适用

```python
>>> str = "a\n\nb\n\n"
>>>
>>> str.split()
['a', 'b']
```

有的人还会建议使用 `splitlines`

```python
>>> str = "a\nb\n"
>>>
>>> str.splitlines()
['a', 'b']
```

但其实，splitlines 方法只有在上面这种仅一个换行符的场景下，才能达到如上预期的。比如下边的案例，就无法适用：

```python
>>> str = "a\n\nb\n\n"
>>>
>>> str.splitlines()
['a', '', 'b', '']
```

在这里有必要补充下，对 splitlines 的原理做一些说明

其实 splitlines  函数还有一个 keepends 参数 ，意思是 **是否要保留换行符** ('\r', '\r\n', '\n')

默认值为 False，也正是这个原因，上面的例子才有那样的效果 -- **去掉了最后一个元素**

试着指定该参数为 True，你就会发现，原来 splitlines 是为换行符为界将字符串分成多个，但并不是直接拿掉换行符。

```python
>>> str = "a\nb\n"
>>> str.splitlines(True)
['a\n', 'b\n']
```

因此在多个换行符的情况下，请务必使用 split 方法。



#  反转字符串/列表最优雅的方式

反转序列并不难，但是如何做到最优雅呢？

先来看看，正常是如何反转的。

最简单的方法是使用列表自带的reverse()方法。

```python
>>> ml = [1,2,3,4,5]
>>> ml.reverse()
>>> ml
[5, 4, 3, 2, 1]
```

但如果你要处理的是字符串，reverse就无能为力了。你可以尝试将其转化成list，再reverse，然后再转化成str。转来转去，也太麻烦了吧？需要这么多行代码（后面三行是不能合并成一行的），一点都不Pythonic。

```python
mstr1 = 'abc'
ml1 = list(mstr1)
ml1.reverse()
mstr2 = str(ml1)
```

对于字符串还有一种稍微复杂一点的，是自定义递归函数来实现。

```python
def my_reverse(str):
    if str == "":
        return str
    else:
        return my_reverse(str[1:]) + str[0]
```

在这里，介绍一种最优雅的反转方式，使用切片，不管你是字符串，还是列表，简直通杀。

```python
>>> mstr = 'abc'
>>> ml = [1,2,3]
>>> mstr[::-1]
'cba'
>>> ml[::-1]
[3, 2, 1]
```



#  如何将 print 内容输出到文件

Python 3 中的 print 作为一个函数，由于可以接收更多的参数，所以功能变为更加强大。

比如今天要说的使用 print 将你要打印的内容，输出到日志文件中（但是我并不推荐使用它）。

```python
>>> with open('test.log', mode='w') as f:
...     print('hello, python', file=f, flush=True)
>>> exit()

$ cat test.log
hello, python
```



#  改变默认递归次数限制

上面才提到递归，大家都知道使用递归是有风险的，递归深度过深容易导致堆栈的溢出。如果你这字符串太长啦，使用递归方式反转，就会出现问题。

那到底，默认递归次数限制是多少呢？

```python
>>> import sys
>>> sys.getrecursionlimit()
1000
```

可以查，当然也可以自定义修改次数，退出即失效。

```python
>>> sys.setrecursionlimit(2000)
>>> sys.getrecursionlimit()
2000
```





#  让你晕头转向的 else 用法

if else 用法可以说是最基础的语法表达式之一，但是今天不是讲这个的。

if else 早已烂大街，但我相信仍然有很多人都不曾见过 for else 和 try else 的用法。为什么说它曾让我晕头转向，因为它不像 if else 那么直白，非黑即白，脑子经常要想一下才能才反应过来代码怎么走。

先来说说，for ... else ...

```python
def check_item(source_list, target):
    for item in source_list:
        if item == target:
            print("Exists!")
            break

    else:
        print("Does not exist")

```

在往下看之前，你可以思考一下，什么情况下才会走 else。是循环被 break，还是没有break？

给几个例子，你体会一下。

```python
check_item(["apple", "huawei", "oppo"], "oppo")
# Exists!

check_item(["apple", "huawei", "oppo"], "vivo")
# Does not exist
```

可以看出，没有被 break 的程序才会正常走else流程。

再来看看，try else 用法。

```python
def test_try_else(attr1 = None):
    try:
        if attr1:
            pass
        else:
            raise
    except:
        print("Exception occurred...")
    else:
        print("No Exception occurred...")
```

同样来几个例子。当不传参数时，就抛出异常。

```python
test_try_else()
# Exception occurred...

test_try_else("ming")
# No Exception occurred...
```

可以看出， try 里面的代码块没有抛出异常的，会正常走else。

总结一下，for else 和 try else 相同，只要代码正常走下去不被 break，不抛出异常，就可以走else。



#  字典访问不存在的key时不再报错

当一个字典里没有某个 key 时，此时你访问他是会报 KeyError 的。

```python
>>> profile={}
>>> profile["age"]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'age'
```

这里有一个小技巧，使用 collections 的 defaultdict 方法，可以帮你处理这个小问题，当你访问一个不存在的 key 时，会返回默认值。

defaultdict 接收一个工厂方法，工厂方法返回的对象就是字典的默认值。

常用的工厂方法有，我们常见的 int，str，bool 等

```python
>>> a=int()
>>> a
0
>>> 
>>> b=str()
>>> b
''
>>>
>>> c=bool()
>>> c
False
```

因为 defaultdict 可以这样子用。

```python
>>> import collections
>>> profile=collections.defaultdict(int)
>>> profile
defaultdict(<class 'int'>, {})
>>> profile["age"]
0
>>> profile=collections.defaultdict(str)
>>> profile
defaultdict(<class 'str'>, {})
>>> profile["name"]
''
```

当然既然是工厂方法，你也可以使用 lambda 匿名函数来实现自定义的效果，比如我们使用 str 就会设置一个空字符串，但这并不是我想要的，我想要的是设置一个其他字符串，你就可以像下面这样子。

```python
>>> info=collections.defaultdict(lambda: "default value")
>>> info
defaultdict(<function <lambda> at 0x10ff10488>, {})
>>>
>>> info["msg"]
'default value'
```



#  如何实现函数的连续调用？

现在我想写一个函数可以实现把所有的数进行求和，并且可以达到反复调用的目的。

比如这样子。

```python
>>> add(2)(3)(4)(5)(6)(7)
27
```

当只调用一次时，也必须适用。

```python
>>> add(2)
2
```

每次调用的返回结果都是一个 int 类型的实例，要实现将一个实例看做一个函数一样调用，那就不得不使用到 `__call__` 这个魔法方法。

```python
>>> class AddInt(int):
...     def __call__(self, x):
...         print("calling __call__ function")
...         return AddInt(self.numerator + x)
...
>>>
>>> age = AddInt(18)
>>> age
18
>>> age(1)
calling __call__ function
19
```

有了上面的铺垫，可以在 AddInt 外层再加一层封装即可。

```python
>>> def add(x):
...     class AddInt(int):
...         def __call__(self, x):
...             return AddInt(self.numerator + x)
...     return AddInt(x)
...
>>> add(2)
2
>>> add(2)(3)(4)(5)(6)(7)
27
>>>
```



#  如何实现字典的多级排序

在一个列表中，每个元素都是一个字典，里面的每个字典结构都是一样的。

里面的每个字典会有多个键值对，根据某个 key 或 value 的值大小，对该列表进行排序，使用 sort 函数就可以轻松实现。

```python
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 17, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: student['score'])
>>> students
[{'age': 17, 'score': 80, 'name': 'Julia'}, {'age': 16, 'score': 80, 'name': 'Tom'}, {'age': 17, 'score': 89, 'name': 'Jack'}]
```

如果两名同学的成绩一样，那谁排在前面呢？

那就再额外定个第二指标呗，成绩一样，就再看年龄，年龄小的，成绩还能一样，那不是更历害嘛 。

规则定下了：先按成绩升序，如果成绩一致，再按年龄升序。

问题来了，这样的规则，代码该如何实现呢？

用字典本身的 sort 函数也能实现，方法如下：

```python
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 17, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: (student['score'], student['age']))
>>> students
[{'age': 16, 'score': 80, 'name': 'Tom'}, {'age': 17, 'score': 80, 'name': 'Julia'}, {'age': 17, 'score': 89, 'name': 'Jack'}]
```

那如果一个降序，而另一个是升序，那又该怎么写呢？

很简单，只要在对应的 key 上，前面加一个负号，就会把顺序给颠倒过来。

还是以上面为例，我现在要实现先按成绩降序，如果成绩一致，再按年龄升序。可以这样写

```python
>>> students = [{'name': 'Jack', 'age': 17, 'score': 89}, {'name': 'Julia', 'age': 17, 'score': 80}, {'name': 'Tom', 'age': 16, 'score': 80}]
>>> students.sort(key=lambda student: (-student['score'], student['age']))
>>> students
[{'age': 17, 'score': 80, 'name': 'Julia'}, {'age': 16, 'score': 80, 'name': 'Tom'}, {'age': 17, 'score': 89, 'name': 'Jack'}]
```





#  对齐字符串的两种方法

## 第一种：使用 format

左对齐

```python
>>> "{:<10}".format("a")
'a         '
>>> 
```

右对齐

```python
>>> "{:>10}".format("a")
'         a'
>>> 
```

居中

```python
>>> "{:^10}".format("a")
'    a     '
>>> 
```

当你不指定 `<` 、`>`、`^` 时，对字符串，默认左对齐；对数值，默认右对齐

```python
>>> "{:10}".format("a")
'a         '
>>> 
```

有了上面的铺垫，写一个整齐的 1-10 的平方、立方表就很容易了。

```python
>>> for x in range(1, 11):
...        print('{:2d} {:3d} {:4d}'.format(x, x*x, x*x*x))
...
 1   1    1
 2   4    8
 3   9   27
 4  16   64
 5  25  125
 6  36  216
 7  49  343
 8  64  512
 9  81  729
10 100 1000
```

对齐的思想其实就是在不足的位自动给你补上空格。

如果不想使用空格，可以指定你想要的字符进行填充，比如下面我用 `0` 来补全。

```python
>>> for x in range(1, 11):
...     print('{:02d} {:03d} {:04d}'.format(x, x*x, x*x*x))
... 
01 001 0001
02 004 0008
03 009 0027
04 016 0064
05 025 0125
06 036 0216
07 049 0343
08 064 0512
09 081 0729
10 100 1000
```



## 第二种：使用 ljust, rjust

左对齐

```python
>>> "a".ljust(10)
'a         '
>>> 
```

右对齐

```python
>>> "a".rjust(10)
'         a'
>>> 
```

居中

```python
>>> "a".center(10)
'    a     '
>>> 
```

同样写一个整齐的 1-10 的平方、立方表

```python
>>> for x in range(1, 11):
...     print(' '.join([str(x).ljust(2), str(x * x).ljust(3), str(x * x * x).ljust(4)]))
... 
1  1   1   
2  4   8   
3  9   27  
4  16  64  
5  25  125 
6  36  216 
7  49  343 
8  64  512 
9  81  729 
10 100 1000
```

如果不想使用空格，而改用 0 来补齐呢？可以这样

```python
>>> for x in range(1, 11):
...     print(' '.join([str(x).rjust(2, "0"), str(x*x).rjust(3, "0"), str(x*x*x).rjust(4, "0")]))
... 
01 001 0001
02 004 0008
03 009 0027
04 016 0064
05 025 0125
06 036 0216
07 049 0343
08 064 0512
09 081 0729
10 100 1000
```



#  将位置参数变成关键字参数

在 Python 中，参数的种类，大概可以分为四种：

1. `必选参数`，也叫`位置参数`，调用函数时一定指定的参数，并且在传参的时候必须按函数定义时的顺序来
2. `可选参数`，也叫`默认参数`，调用函数时，可以指定也可以不指定，不指定就按默认的参数值来。
3. `可变参数`，就是参数个数可变，可以是 0 个或者任意个，但是传参时不能指定参数名，通常使用 `*args` 来表示。
4. `关键字参数`，就是参数个数可变，可以是 0 个或者任意个，但是传参时必须指定参数名，通常使用 `**kw` 来表示 

使用单独的 `*`，可以将后面的位置参数变成关键字参数，关键字参数在你传参时，必须要写参数名，不然会报错。

```python
>>> def demo_func(a, b, *, c):
...     print(a)
...     print(b)
...     print(c)
... 
>>> 
>>> demo_func(1, 2, 3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: demo_func() takes 2 positional arguments but 3 were given
>>> 
>>> demo_func(1, 2, c=3)
1
2
3
```

#  如何获取一个函数设定的参数

在 Python 中有一个叫 inspect 的库，非常的好用，利用它可以获取一些数据，这在写一些框架时非常有用。

比如有下面这样一个函数

```python
def demo(name, age, gender="male", *args, **kw):
    pass
```

使用 inspect 可以直接获取 

```python
>>> from inspect import signature
>>> 
>>> sig = signature(demo) # # 获取函数签名
>>> sig
<Signature (name, age, gender='male', *args, **kw)>
```

利用 inspect 还可以检查传参是否匹配签名

```python
>>> sig.bind("王炳明", 27)
<BoundArguments (name='王炳明', age=27)>
>>> 
>>> sig.bind("王炳明")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib64/python3.6/inspect.py", line 2997, in bind
    return args[0]._bind(args[1:], kwargs)
  File "/usr/lib64/python3.6/inspect.py", line 2912, in _bind
    raise TypeError(msg) from None
TypeError: missing a required argument: 'age'
```



#  如何进行版本的比较

## 使用 distutils

`distutils` 是 Python 的内置模块，它做为最古老的 python 分发工具，本身也实现了版本的比较与检查的功能。

```python
>>> from distutils.version import LooseVersion, StrictVersion
>>> LooseVersion("2.3.1") < LooseVersion("10.1.2")
True
>>> StrictVersion("2.3.1") < StrictVersion("10.1.2")
True
```

## 使用 packaging 

如果你的环境中安装过 `setuptools`，那么一定会附带安装了 packaging 这个包，而如果你的环境中并没有 setuptools ，也可以通过 pip 来快速安装

```shell
$ python3 -m pip install packaging
```

在 packaging 中有一个 version 模块，专门用来为 setuptools 提供包版本的版本解析。

```python
>>> from packaging import version
>>> version.parse("2.3.1") < version.parse("10.1.2")
True
>>> version.parse("1.3.a4") < version.parse("10.1.2")
True
```





#  如何捕获警告?(注意不是捕获异常)

##  警告不是异常

你是不是经常在使用一些系统库或者第三方模块的时候，会出现一些既不是异常也不是错误的警告信息？

这些警告信息，有时候非常多，对于新手容易造成一些误判，以为是程序出错了。

实则不然，异常和错误，都是程序出现了一些问题，但是警告不同，他的紧急程度非常之低，以致于大多数的警告都是可以直接忽略的。

如果不想显示这些告警信息，可以直接加上参数  `-W ignore` 参数，就不会再显示了。

##  警告能捕获吗

能捕获的只有错误异常，但是通过一系列的操作后，你可以将这些警告转化为异常。

这样一来，你就可以像异常一样去捕获他们了。

在不进行任何设置的情况下，警告会直接打印在终端上。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-271124.png)

##  捕获警告方法一

在 warnings 中有一系列的过滤器。

| 值          | 处置                                                   |
| :---------- | :----------------------------------------------------- |
| `"default"` | 为发出警告的每个位置（模块+行号）打印第一个匹配警告    |
| `"error"`   | 将匹配警告转换为异常                                   |
| `"ignore"`  | 从不打印匹配的警告                                     |
| `"always"`  | 总是打印匹配的警告                                     |
| `"module"`  | 为发出警告的每个模块打印第一次匹配警告（无论行号如何） |
| `"once"`    | 无论位置如何，仅打印第一次出现的匹配警告               |

当你指定为 error 的时候，就会将匹配警告转换为异常。

之后你就可以通过异常的方式去捕获警告了。

```python
import warnings
warnings.filterwarnings('error')    

try:
    warnings.warn("deprecated", DeprecationWarning)
except Warning as e:
    print(e)
```

运行后，效果如下

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-287183.png)

##  捕获警告方法二

如果你不想对在代码中去配置将警告转成异常。

```python
import warnings

try:
    warnings.warn("deprecated", DeprecationWarning)
except Warning as e:
    print(e)
```

可以在执行的时候，只要加上一个参数 `-W error` ，就可以实现一样的效果

```shell
$ python3 -W error demo.py
deprecated
```

##  捕获警告方法三

除了上面的方法之外 ，warnings 还自带了个捕获警告的上下文管理器。

当你加上 `record=True` 它会返回一个列表，列表里存放的是所有捕获到的警告，我将它赋值为 `w`，然后就可以将它打印出来了。

```python
import warnings

def do_warning():
    warnings.warn("deprecated", DeprecationWarning)

with warnings.catch_warnings(record=True) as w:
    do_warning()
    if len(w) >0:
        print(w[0].message)
```

运行后，效果如下

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-301189.png)

#  如何禁止对象深拷贝?

当你使用 copy 模块的 deepcopy 拷贝一个对象后，会创建出来一个全新的的对象。

```python
>>> from copy import deepcopy
>>> 
>>> profile = {"name": "wangbm"}
>>> id(profile)
21203408
>>> 
>>> new_profile = deepcopy(profile)
>>> id(new_profile)
21236144
```

但是有的时候，我们希望基于我们的类实例化后对象，禁止被深拷贝，这时候就要用到 Python 的魔法方法了。

在如下代码中，我们重写了 Sentinel 类的 `__deepcopy__` 和  `__copy__` 方法

```python
class Sentinel(object):
    def __deepcopy__(self, memo):
        # Always return the same object because this is essentially a constant.
        return self

    def __copy__(self):
        # called via copy.copy(x)
        return self
```

此时你如果对它进行深度拷贝的话，会发现返回的永远都是原来的对象

```python
>>> obj = Sentinel()
>>> id(obj)
140151569169808
>>> 
>>> new_obj = deepcopy(obj)
>>> id(new_obj)
140151569169808
```



#  如何将变量名和变量值转为字典？

千言万语，不如上示例演示下效果

```python
>>> name="wangbm"
>>> age=28
>>> gender="male"
>>> 
>>> convert_vars_to_dict(name, age, gender)
{'name': 'wangbm', 'age': 28, 'gender': 'male'}
```

`convert_vars_to_dict` 是我要自己定义的这么一个函数，功能如上，代码如下。

```python
import re
import inspect

def varname(*args):
    current_frame = inspect.currentframe()
    back_frame = current_frame.f_back
    back_frame_info = inspect.getframeinfo(back_frame)

    current_func_name = current_frame.f_code.co_name

    caller_file_path = back_frame_info[0]
    caller_line_no = back_frame_info[1]
    caller_type = back_frame_info[2]
    caller_expression = back_frame_info[3]

    keys = []

    for line in caller_expression:
        re_match = re.search(r'\b{}\((.*?)\)'.format(current_func_name), line)
        match_string = re_match.groups(1)[0]
        keys = [match.strip() for match in match_string.split(',') if match]

    return dict(zip(keys, args))
```

附上 ：[inspect 学习文档](https://docs.python.org/zh-cn/3.7/library/inspect.html)



#  替换实例方法的最佳实践

## 思路一：简单替换

当你想对类实例的方法进行替换时，你可能想到的是直接对他进行粗暴地替换

```python
class People:
    def speak(self):
        print("hello, world")


def speak(self):
    print("hello, python")

p = People()
p.speak = speak
p.speak()
```

但当你试着执行这段代码的时候，就会发现行不通，它提示我们要传入 self 参数

```
Traceback (most recent call last):
  File "/Users/MING/Code/Python/demo.py", line 12, in <module>
    p.speak()
TypeError: speak() missing 1 required positional argument: 'self'
```

不对啊~ self 不是实例本身吗？函数不是一直就这么写的？

实际上你这么替换，speak 就变成了一个 function，而不是一个和实例绑定的 method ，你可以把替换前后的 speak 打印出来

```python
p = People()
print(p.speak)
p.speak = speak
print(p.speak)
```

输出结果如下，区别非常明显

```
<bound method People.speak of <__main__.People object at 0x10cfa7fd0>>
<function speak at 0x10ca10040>
```

这种方法，只能用在替换不与实例绑定的静态方法上，不然你每次调用的时候，就得手动传入实例本身，但这样调用就会变得非常怪异。

## 思路二：利用 im_func

有 Python 2 使用经验的朋友，可以会知道类实例的方法，都有 `im_func` 和 `im_class` 属性，分别指向了该方法的函数和类。

![](http://image.iswbm.com/20210328111610.png)

很抱歉的是，这些在 Python3 中全都取消了，意味你无法再使用  `im_func` 和 `im_class` 。

但即使你身处 Python 2 的环境下，你想通过 `im_func` 去直接替换函数，也仍然是有问题的。

因为在 Python2 中不推荐普通用户对类实例的方法进行替换，所以 Python 给类实例的方法赋予了只读属性

![](http://image.iswbm.com/20210328111904.png)

## 思路三：非常危险的字节码替换

表层不行，但这个方法在字节码层面却是可行的

![](http://image.iswbm.com/20210328112231.png)

这种方法，非常的粗暴且危险，他会直接影响到使用 People 的所有实例的 speak 方法，因此这种方法千万不要使用。

![](http://image.iswbm.com/20210328112501.png)

## 思路四：利用 types 绑定方法

在 types 中有一个 MethodType，可以将普通方法与实例进行绑定。

绑定后，就可以直接替换掉原实例的 speak 方法了，完整代码如下：

```python
import types

class People:
    def speak(self):
        print("hello, world")


def speak(self):
    print("hello, python")

p = People()
p.speak = types.MethodType(speak, p)
p.speak()
```

这种方法，最为安全，不会影响其他实例。并且 Python 2 和 Python 3 都适用，是官方推荐的一种做法。



#  如何动态创建函数？

在下面的代码中，每一次 for 循环都会创建一个返回特定字符串的函数。

```python
from types import FunctionType


for name in ("world", "python"):
    func = FunctionType(compile(
        ("def hello():\n"
        "    return '{}'".format(name)),
    "<string>",
    "exec").co_consts[0], globals())

    print(func())
```

输出如下

```
world
python
```



#  如何规定函数的参数类型？

在定义函数时，通常都需要带有各样各样的参数。

## 认识参数的种类

从函数定义的角度来看，参数可以分为两种：

1.  `必选参数`：调用函数时必须要指定的参数，在定义时没有等号
2.  `可选参数`：也叫`默认参数`，调用函数时可以指定也可以不指定，不指定就默认的参数值来。

例如下面的代码中，a 和 b 属于必选参数， c 和 d 属于可选参数

```python
def func(a,b,c=0, d=1):
    pass
```

从函数调用的角度来看，参数可以分为两种：

1.  `关键字参数`：调用时，使用 key=value 形式传参的，这样传递参数就可以不按定义顺序来。
2.  `位置参数`：调用时，不使用关键字参数的 key-value 形式传参，这样传参要注意按照函数定义时参数的顺序来。

```python
def func(a,b,c=0, d=1):
    pass

  # 关键字参数传参方法
func(a=10, c=30, b=20, d=40)

  # 位置参数传参方法
func(10, 20, 30, 40)
```

最后还有一种非常特殊的参数，叫做`可变参数`。

意思是参数个数可变，可以是 0 个或者任意个，但是传参时不能指定参数名，通常使用 `*args` 和 `**kw` 来表示：

-   `*args`：接收到的所有按照位置参数方式传递进来的参数，是一个元组类型
-   `**kw` ：接收到的所有按照关键字参数方式传递进来的参数，是一个字典类型

```python
def func(*args, **kw):
    print(args)
    print(kw)

func(10, 20, c=20, d=40)
```

输出如下

```
(10, 20)
{'c': 20, 'd': 40}
```

## 两个神奇的符号

除了以上关于参数类型的基础知识，其实还有一个知识点，这是基础所有的 Python 基础教程都不会提及的。

仔细回看上面关于 `关键字参数` 和 `位置参数` 的区别，无需是在传参时是否以 key-value 的形式而不同。

这是从调用者的角度去区分，如果是这样，那你应该也会觉得  `关键字参数` 和 `位置参数` 这两个概率除了区分两种传参方式之外 ，好像没有实际的作用。



实则不然， `关键字参数` 和 `位置参数` 

实际上，当你在定义函数时，函数是可以限定调用者该以何种方式来进行传参。

实现的方式就是依靠两个符号：

-   `/`：在 `/` 之前的参数都是位置参数，不能以 key-value 传参，至于后面是什么参数它不管
-   `*`：在 `*` 之后都是关键字参数，都应该以 key-value 传参，至于前面是什么参数它也不管

下边以标准的正确示例和两个错误范例进行演示。

**正确示例**

```python
def func(a,b,/,c,d):
    pass

func("a", "b", c="c", d="d")
```

**错误示例一**

```python
def func(a,b,/,c,d):
    pass

func("a", b="b", c="c", d="d")
```

运行报错如下，意思是 b 是位置参数，不能使用 `b="b"` 这种 key-value 传参

```python
Traceback (most recent call last):
  File "/Users/MING/demo.py", line 4, in <module>
    func("a", b="b", c="c", d="d")
TypeError: func() got some positional-only arguments passed as keyword arguments: 'b'
```

**错误示例三**

```python
def func(a,b,*,c,d):
    pass

func("a", "b", "c", d="d")
```

运行报错如下，意思是函数中只定义了两个位置参数，却给了三个，第三个是 c ，它是关键字参数，不能使用 `c="c"` 必须使用 key-value 传参

```python
Traceback (most recent call last):
  File "/Users/MING/demo.py", line 4, in <module>
    func("a", "b", "c", d="d")
TypeError: func() takes 2 positional arguments but 3 positional arguments (and 1 keyword-only argument) were given
```

