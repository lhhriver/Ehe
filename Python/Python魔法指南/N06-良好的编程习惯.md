#  不要直接调用类的私有方法

大家都知道，类中可供直接调用的方法，只有公有方法（protected类型的方法也可以，但是不建议）。也就是说，类的私有方法是无法直接调用的。

这里先看一下例子

```python
class Kls():
    def public(self):
        print('Hello public world!')
        
    def __private(self):
        print('Hello private world!')
        
    def call_private(self):
        self.__private()

ins = Kls()

# 调用公有方法，没问题
ins.public()

# 直接调用私有方法，不行
ins.__private()

# 但你可以通过内部公有方法，进行代理
ins.call_private()
```

既然都是方法，那我们真的没有办法可以直接调用吗？

当然有啦，只是建议你千万不要这样弄，这里只是普及，让你了解一下。

```python
# 调用私有方法，以下两种等价
ins._Kls__private()
ins.call_private()
```



#  默认参数最好不为可变对象

函数的参数分三种

- 可变参数
- 默认参数
- 关键字参数

当你在传递默认参数时，有新手很容易踩雷的一个坑。

先来看一个示例

```python
def func(item, item_list=[]):
    item_list.append(item)
    print(item_list)

func('iphone')
func('xiaomi', item_list=['oppo','vivo'])
func('huawei')
```

在这里，你可以暂停一下，思考一下会输出什么？

思考过后，你的答案是否和下面的一致呢

```
['iphone']
['oppo', 'vivo', 'xiaomi']
['iphone', 'huawei']
```

如果是，那你可以跳过这部分内容，如果不是，请接着往下看，这里来分析一下。

Python 中的 def 语句在每次执行的时候都初始化一个函数对象，这个函数对象就是我们要调用的函数，可以把它当成一个一般的对象，只不过这个对象拥有一个可执行的方法和部分属性。

对于参数中提供了初始值的参数，由于 Python 中的函数参数传递的是对象，也可以认为是传地址，在第一次初始化 def 的时候，会先生成这个可变对象的内存地址，然后将这个默认参数 item_list 会与这个内存地址绑定。在后面的函数调用中，如果调用方指定了新的默认值，就会将原来的默认值覆盖。如果调用方没有指定新的默认值，那就会使用原来的默认值。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-534807.png)



#  增量赋值的性能更好

诸如 `+=` 和 `*=` 这些运算符，叫做 增量赋值运算符。

这里使用用 += 举例，以下两种写法，在效果上是等价的。

```python
# 第一种
a = 1 ; a += 1

# 第二种
a = 1; a = a + 1
```

`+=` 其背后使用的魔法方法是 `__iadd__`，如果没有实现这个方法则会退而求其次，使用 `__add__` 。

这两种写法有什么区别呢？

用列表举例 a += b，使用 `__add__` 的话就像是使用了a.extend(b),如果使用 `__add__` 的话，则是 a = a+b,前者是直接在原列表上进行扩展，而后者是先从原列表中取出值，在一个新的列表中进行扩展，然后再将新的列表对象返回给变量，显然后者的消耗要大些。

所以在能使用增量赋值的时候尽量使用它。



#  别再使用 pprint 打印了

##  吐槽问题

pprint 你应该很熟悉了吧？

随便在搜索引擎上搜索如何打印漂亮的字典或者格式化字符串时，大部分人都会推荐你使用这货 。

比如这下面这个 json 字符串或者说字典（我随便在网上找的），如果不格式化美化一下，根本无法阅读。

```json
[{"id":1580615,"name":"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":"2011-2017 你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":"斗鱼271934 走过路过不要错过，这里有最好的鸡儿"}]
```

如果你不想看到一堆密密麻麻的字，那就使用大伙都极力推荐的 pprint 看下什么效果（以下在 Python 2 中演示，Python 3 中是不一样的效果）。

```python
>>> info=[{"id":1580615,"name":"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":"2011-2017 你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":"斗鱼271934 走过路过不要错过，这里有最好的鸡儿"}]
>>> 
>>> from pprint import pprint
>>> pprint(info)
[{'des': '2011-2017 \xe4\xbd\xa0\xe7\x9a\x84\xe9\x93\x81\xe5\xa4\xb4\xe5\xa8\x83\xe4\xb8\x80\xe7\x9b\xb4\xe5\x9c\xa8\xe8\xbf\x99\xe5\x84\xbf\xe3\x80\x82\xe4\xb8\xad\xe5\x9b\xbd\xe6\x9c\x80\xe5\xa4\xa7\xe7\x9a\x84\xe5\xae\x9e\xe5\x90\x8d\xe5\x88\xb6SNS\xe7\xbd\x91\xe7\xbb\x9c\xe5\xb9\xb3\xe5\x8f\xb0\xef\xbc\x8c\xe5\xab\xa9\xe5\xa4\xb4\xe9\x9d\x92',
  'downloadUrl': 'app/com.renren.mobile.android/com.renren.mobile.android.apk',
  'iconUrl': 'app/com.renren.mobile.android/icon.jpg',
  'id': 1580615,
  'name': '\xe7\x9a\xae\xe7\x9a\x84\xe5\x98\x9b',
  'packageName': 'com.renren.mobile.android',
  'size': 21803987,
  'stars': 2},
 {'des': '\xe6\x96\x97\xe9\xb1\xbc271934 \xe8\xb5\xb0\xe8\xbf\x87\xe8\xb7\xaf\xe8\xbf\x87\xe4\xb8\x8d\xe8\xa6\x81\xe9\x94\x99\xe8\xbf\x87\xef\xbc\x8c\xe8\xbf\x99\xe9\x87\x8c\xe6\x9c\x89\xe6\x9c\x80\xe5\xa5\xbd\xe7\x9a\x84\xe9\xb8\xa1\xe5\x84\xbf',
  'downloadUrl': 'app/com.ct.client/com.ct.client.apk',
  'iconUrl': 'app/com.ct.client/icon.jpg',
  'id': 1540629,
  'name': '\xe4\xb8\x8d\xe5\xad\x98\xe5\x9c\xa8\xe7\x9a\x84',
  'packageName': 'com.ct.client',
  'size': 4794202,
  'stars': 2}]
```

好像有点效果，真的是 “神器”呀。

但是你告诉我， **\xe4\xbd\xa0\xe7\x9a** 这些是什么玩意？本来想提高可读性的，现在变成完全不可读了。

好在我懂点 Python 2 的编码，知道 Python 2 中默认（不带u）的字符串格式都是 str 类型，也是 bytes 类型，它是以 byte 存储的。

行吧，好像是我错了，我改了下，使用 unicode 类型来定义中文字符串吧。

```python
>>> info = [{"id":1580615,"name":u"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":u"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":u"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":u"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]
>>> 
>>> from pprint import pprint
>>> pprint(info)
[{'des': u'2011-2017\u4f60\u7684\u94c1\u5934\u5a03\u4e00\u76f4\u5728\u8fd9\u513f\u3002\u4e2d\u56fd\u6700\u5927\u7684\u5b9e\u540d\u5236SNS\u7f51\u7edc\u5e73\u53f0\uff0c\u5ae9\u5934\u9752',
  'downloadUrl': 'app/com.renren.mobile.android/com.renren.mobile.android.apk',
  'iconUrl': 'app/com.renren.mobile.android/icon.jpg',
  'id': 1580615,
  'name': u'\u76ae\u7684\u561b',
  'packageName': 'com.renren.mobile.android',
  'size': 21803987,
  'stars': 2},
 {'des': u'\u6597\u9c7c271934\u8d70\u8fc7\u8def\u8fc7\u4e0d\u8981\u9519\u8fc7\uff0c\u8fd9\u91cc\u6709\u6700\u597d\u7684\u9e21\u513f',
  'downloadUrl': 'app/com.ct.client/com.ct.client.apk',
  'iconUrl': 'app/com.ct.client/icon.jpg',
  'id': 1540629,
  'name': u'\u4e0d\u5b58\u5728\u7684',
  'packageName': 'com.ct.client',
  'size': 4794202,
  'stars': 2}]
```

确实是有好点了，但是看到下面这些，我崩溃了，我哪里知道这是什么鬼，难道是我太菜了吗？当我是计算机呀？

```
u'\u6597\u9c7c271934\u8d70\u8fc7\u8def\u8fc7\u4e0d\u8981\u9519\u8fc7\uff0c\u8fd9\u91cc\u6709\u6700\u597d\u7684\u9e21\u513f'
```

除此之外，我们知道 json 的严格要求必须使用 **双引号**，而我定义字典时，也使用了双引号了，为什么打印出来的为什么是 **单引号**？我也太难了吧，我连自己的代码都无法控制了吗？

到这里，我们知道了 pprint 带来的两个问题：

1. 没法在 Python 2 下正常打印中文
2. 没法输出 JSON 标准格式的格式化内容（双引号）

##  解决问题

### 打印中文

如果你是在 Python 3 下使用，你会发现中文是可以正常显示的。

```python
# Python3.7
>>> info = [{"id":1580615,"name":u"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":u"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":u"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":u"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]
>>> 
>>> from pprint import pprint
>>> pprint(info)
[{'des': '2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青',
  'downloadUrl': 'app/com.renren.mobile.android/com.renren.mobile.android.apk',
  'iconUrl': 'app/com.renren.mobile.android/icon.jpg',
  'id': 1580615,
  'name': '皮的嘛',
  'packageName': 'com.renren.mobile.android',
  'size': 21803987,
  'stars': 2},
 {'des': '斗鱼271934走过路过不要错过，这里有最好的鸡儿',
  'downloadUrl': 'app/com.ct.client/com.ct.client.apk',
  'iconUrl': 'app/com.ct.client/icon.jpg',
  'id': 1540629,
  'name': '不存在的',
  'packageName': 'com.ct.client',
  'size': 4794202,
  'stars': 2}]
>>> 

```

但是很多时候（在公司的一些服务器）你无法选择自己使用哪个版本的 Python，本来我可以选择不用的，因为有更好的替代方案（**这个后面会讲**）。

但是我出于猎奇，正好前两天不是写过一篇关于 编码 的文章吗，我自认为自己对于 编码还是掌握比较熟练的，就想着来解决一下这个问题。

索性就来看下 pprint 的源代码，还真被我找到了解决方法，如果你也想挑战一下，不防在这里停住，自己研究一下如何实现，我相信对你阅读源码会有帮助。

**以下是我的解决方案，供你参考**：

写一个自己的 printer 对象，继承自 PrettyPrinter （pprint 使用的printer）

并且复写 format 方法，判断传进来的字符串对象是否 str 类型，如果不是 str 类型，而是 unicode 类型，就用 uft8 编码成 str 类型。

```python
# coding: utf-8
from pprint import PrettyPrinter

# 继承 PrettyPrinter，复写 format 方法
class MyPrettyPrinter(PrettyPrinter):
    def format(self, object, context, maxlevels, level):
        if isinstance(object, unicode):
            return (object.encode('utf8'), True, False)
        return PrettyPrinter.format(self, object, context, maxlevels, level)

info = [{"id":1580615,"name":u"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":u"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":u"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":u"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]

MyPrettyPrinter().pprint(info)
```

输出如下，已经解决了中文的显示问题：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-744807.png)

### 打印双引号

解决了中文问题后，再来看看如何让 pprint 打印双引号。

在实例化 PrettyPrinter 对象的时候，可以接收一个 stream 对象，它表示你要将内容输出到哪里，默认是使用 sys.stdout 这个  stream，也就是标准输出。

现在我们要修改输出的内容，也就是将输出的单引号替换成双引号。

那我们完全可以自己定义一个 stream 类型的对象，该对象不需要继承任何父类，只要你实现 write 方法就可以。

有了思路，就可以开始写代码了，如下：

```python
# coding: utf-8
from pprint import PrettyPrinter

class MyPrettyPrinter(PrettyPrinter):
    def format(self, object, context, maxlevels, level):
        if isinstance(object, unicode):
            return (object.encode('utf8'), True, False)
        return PrettyPrinter.format(self, object, context, maxlevels, level)

class MyStream():
    def write(self, text):
        print text.replace('\'', '"')

info = [{"id":1580615,"name":u"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":u"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":u"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":u"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]
MyPrettyPrinter(stream=MyStream()).pprint(info)
```

尝试执行了下，我的天，怎么是这样子的。

```json
[
{
"des"
: 
2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青
,
  "downloadUrl": 
"app/com.renren.mobile.android/com.renren.mobile.android.apk"
,
  "iconUrl": 
"app/com.renren.mobile.android/icon.jpg"
,
  "id": 
1580615
,
  "name": 
皮的嘛
,
  "packageName": 
"com.renren.mobile.android"
,
  "size": 
21803987
,
  "stars": 
2
}
,
 
{
"des"
: 
斗鱼271934走过路过不要错过，这里有最好的鸡儿
,
  "downloadUrl": 
"app/com.ct.client/com.ct.client.apk"
,
  "iconUrl": 
"app/com.ct.client/icon.jpg"
,
  "id": 
1540629
,
  "name": 
不存在的
,
  "packageName": 
"com.ct.client"
,
  "size": 
4794202
,
  "stars": 
2
}
]
```

经过一番研究，才知道是因为 print 函数默认会将打印的内容后面加个 **换行符**。

那如何将使 print 函数打印的内容，不进行换行呢？

方法很简单，但是我相信很多人都不知道，只要在 print 的内容后加一个 **逗号** 就行。

就像下面这样。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-760809.png)

知道了问题所在，再修改下代码

```python
# coding: utf-8
from pprint import PrettyPrinter

class MyPrettyPrinter(PrettyPrinter):
    def format(self, object, context, maxlevels, level):
        if isinstance(object, unicode):
            return (object.encode('utf8'), True, False)
        return PrettyPrinter.format(self, object, context, maxlevels, level)

class MyStream():
    def write(self, text):
        print text.replace('\'', '"'),

info = [{"id":1580615,"name":u"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":u"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":u"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":u"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]

MyPrettyPrinter(stream=MyStream()).pprint(info)
```

终于成功了，太不容易了吧。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180412-775809.png)

##  何必折腾

通过上面的一番折腾，我终于实现了我 **梦寐以求** 的需求。

代价就是我整整花费了两个小时，才得以实现，而对于小白来说，可能没有信心，也没有耐心去做这样的事情。

**所以我想说的是，Python 2 下的 pprint ，真的不要再用了**。

为什么我要这么说，因为明明有更好的替代品，人生苦短，既然用了 Python ，当然是怎么简单怎么来咯，何必为难自己呢，一行代码可以解决的事情，偏偏要去写两个类，那不是自讨苦吃吗？（我这是在骂自己吗？

如果你愿意抛弃 pprint ，那我推荐你用 json.dumps ，我保证你再也不想用 pprint 了。

### 打印中文

其实无法打印中文，是 Python 2 引来的大坑，并不能全怪 pprint 。

但是同样的问题，在 json.dumps 这里，却只要加个参数就好了，可比 pprint 简单得不要太多。

具体的代码示例如下：

```python
>>> info = [{"id":1580615,"name":"皮的嘛","packageName":"com.renren.mobile.android","iconUrl":"app/com.renren.mobile.android/icon.jpg","stars":2,"size":21803987,"downloadUrl":"app/com.renren.mobile.android/com.renren.mobile.android.apk","des":"2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青"},{"id":1540629,"name":"不存在的","packageName":"com.ct.client","iconUrl":"app/com.ct.client/icon.jpg","stars":2,"size":4794202,"downloadUrl":"app/com.ct.client/com.ct.client.apk","des":"斗鱼271934走过路过不要错过，这里有最好的鸡儿"}]
>>> 
>>> import json
>>> 
>>> 
>>> print json.dumps(info, indent=4, ensure_ascii=False)
[
    {
        "downloadUrl": "app/com.renren.mobile.android/com.renren.mobile.android.apk", 
        "iconUrl": "app/com.renren.mobile.android/icon.jpg", 
        "name": "皮的嘛", 
        "stars": 2, 
        "packageName": "com.renren.mobile.android", 
        "des": "2011-2017你的铁头娃一直在这儿。中国最大的实名制SNS网络平台，嫩头青", 
        "id": 1580615, 
        "size": 21803987
    }, 
    {
        "downloadUrl": "app/com.ct.client/com.ct.client.apk", 
        "iconUrl": "app/com.ct.client/icon.jpg", 
        "name": "不存在的", 
        "stars": 2, 
        "packageName": "com.ct.client", 
        "des": "斗鱼271934走过路过不要错过，这里有最好的鸡儿", 
        "id": 1540629, 
        "size": 4794202
    }
]
>>> 
```

json.dumps 的关键参数有两个：

- **indent=4**：以 4 个空格缩进
- **ensure_ascii=False**：接收非 ASCII 编码的字符，这样才能使用中文

与 pprint 相比 json.dumps 可以说完胜：

1. 两个参数就能实现所有我的需求（打印中文与双引号）
2. 就算在 Python 2 下，使用中文也不需要用 `u'中文'` 这种写法
3. Python2 和 Python3 的写法完全一致，对于这一点不需要考虑兼容问题

##  总结一下

本来很简单的一个观点，我为了证明 pprint 实现那两个需求有多么困难，花了很多的时间去研究了 pprint 的源码（各种处理其实还是挺复杂的），不过好在最后也能有所收获。

本文的分享就到这里，阅读本文，我认为你可以获取到三个知识点

1. 核心观点：Python2 下不要再使用 pprint
2. 若真要使用，且有和我一样的改造需求，可以参考我的实现
3. Python 2 中的 print 语句后居然可以加 逗号



#  变量名与保留关键字冲突怎么办？

所有的编程语言都有一些保留关键字，这是代码得以编译/解释的基础。

有了这些关键字就组成了语法，当你的变量名和这些保留关键字冲突时，该怎么办呢？

在回答这个问题前，先要看看 Python 中的保留关键字有哪些？

Python 的关键字，可以通过 keyword 这个模块列出来，一共有 33 个。

```python
>>> import keyword;
>>> print('\n'.join(keyword.kwlist))
False
None
True
and
as
assert
break
class
continue
def
del
elif
else
except
finally
for
from
global
if
import
in
is
lambda
nonlocal
not
or
pass
raise
return
try
while
with
yield
>>> len(keyword.kwlist)
33
```

使用这些关键字来做为变量名，是会报语法错误的。

```python
>>> try = True
  File "<stdin>", line 1
    try = True
        ^
SyntaxError: invalid syntax
```

关于这个问题，[PEP8](https://www.python.org/dev/peps/pep-0008/) 建议当你想使用的变量名被关键字所占用时，可以使用 `变量_` 这样在变量后面加一个单下划线的形式来命名，这种后缀一下划线的方式优先于缩写或拼写错误。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-180968.png)

有了 PEP8 做为指导，我们可以这样子写了

```python
>>> try_ = True
```



#  不想让子类继承的变量名该怎么写？

先来看下面这段代码

```python
class Parent:
    def __init__(self):
        self.name = "MING"

class Son(Parent):
    def __init__(self):
        self.name = "Xiao MING"

bar = Son()
print(bar.name)
# 输出： Xiao MING
```

Bar 作为 Foo 的子类，会继承父类的 name 属性。

如果有一些属性，是父类自己独有的，不想被子类继承，该怎么写呢？

可以在属性前面加两个下划线，两个类的定义如下

```python
class Parent:
    def __init__(self):
        self.name = "MING"
        self.__wife = "Julia"

class Son(Parent):
    def __init__(self):
        self.name = "Xiao MING"
        super().__init__()
```

从本章节的第一篇文章（[6.1 不要直接调用类的私有方法](https://magic.iswbm.com/c06/c06_01.html)）我们知道了私有的变量或函数，是不能直接调用的，需要用这样的形式才能访问 `_类名__变量名`。

从上面的代码中，可以看到 Son 类的实例并没有初始化 `__wife` 属性，虽然 Parent 类的实例有该属性，但由于这个属性是父类私有的，子类是无法访问的。因此当子类想要访问时，是会提示该变量不存在。

验证过程如下：

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/Python魔法指南-20211130-180413-195991.png)



#  利用 any 代替 for 循环

在某些场景下，我们需要判断是否满足某一组集合中任意一个条件

这时候，很多同学自然会想到使用 for 循环。

```python
found = False
for thing in things:
    if thing == other_thing:
        found = True
        break
```

但其实更好的写法，是使用 `any()` 函数，能够使这段代码变得更加清晰、简洁

```python
found = any(thing == other_thing for thing in things)
```

使用 any 并不会减少 for 循环的次数，只要有一个条件为 True，any 就能得到结果。

同理，当你需要判断是否满足某一组集合中所有条件，也可以使用 `all()` 函数。

```python
found = all(thing == other_thing for thing in things)
```

只要有一个不满足条件，all 函数的结果就会立刻返回 False



#  不同条件分支里应减少重合度

如下是一个简单的条件语句模型

```python
if A:
  <code_block_1>
elif B:
  <code_block_2>
else:
  <code_block_3>
```

如果 code_block_2 和 code_block_1 的代码完全一致，那么应该想办法减少代码冗余。

这边举个例子，下面这段代码中

```python
def process_payment(payment):
    if payment.currency == 'USD':
        process_standard_payment(payment)
    elif payment.currency == 'EUR':
        process_standard_payment(payment)
    else:
        process_international_payment(payment)
```

其实更好的做法是用 in 来合并条件一和条件二

```python
def process_payment(payment):
    if payment.currency in ('USD', 'EUR'):
        process_standard_payment(payment)
    else:
        process_international_payment(payment)
```



#  如无必要，勿增实体噢

## 删除没必要的调用`keys()`

字典是由一个个的键值对组成的，如果你遍历字典时只需要访问键，用不到值，有很多同学会用下面这种方式：

```python
for currency in currencies.keys():
    process(currency)
```

在这种情况下，不需要调用keys（），因为遍历字典时的默认行为是遍历键。

```python
for currency in currencies:
    process(currency)
```

现在，该代码更加简洁，易于阅读，并且避免调用函数会带来性能改进。

## 简化序列比较

我们经常要做的是在尝试对列表或序列进行操作之前检查列表或序列是否包含元素。

```python
if len(list_of_hats) > 0:
    hat_to_wear = choose_hat(list_of_hats)
```

使用Python的方法则更加简单：如果Python列表和序列具有元素，则返回为True，否则为False：

```python
if list_of_hats:
    hat_to_wear = choose_hat(list_of_hats)
```

## 仅使用一次的内联变量

我们在很多代码中经常看到，有些同学分配结果给变量，然后马上返回它，例如，

```python
def state_attributes(self):
    """Return the state attributes."""
    state_attr = {
        ATTR_CODE_FORMAT: self.code_format,
        ATTR_CHANGED_BY: self.changed_by,
    }
    return state_attr
```

如果直接返回，则更加直观、简洁，

```python
def state_attributes(self):
    """Return the state attributes."""
    return {
        ATTR_CODE_FORMAT: self.code_format,
        ATTR_CHANGED_BY: self.changed_by,
    }
```

这样可以缩短代码并删除不必要的变量，从而减轻了读取函数的负担。





#  保持代码的简洁与可诗性

## 将条件简化为return语句

如果，我们实现的函数要返回一个布尔型的结果，通常会这样去做，

```python
def function():
    if isinstance(a, b) or issubclass(b, a):
        returnTrue
    returnFalse
```

但是，对比这样，直接返回结果会更加明智：

```python
def function():
    return isinstance(a, b) or issubclass(b, a)
```





#  给模块的私有属性上保险

## 保护对象

有的朋友，喜欢简单粗暴的使用 `from x import *` 来导入 x 模块中的所有对象，实际上有一些对象或者变量，是实现细节，不需要暴露给导入方的，因为导入了也用不上。

对于这些变量或者对象，就可以在前面其名字前加上下划线，只要在变量名前加上下划线，就属于 "保护对象"。

使用 `from x import *` 后，这些 "保护对象" 是会直接跳过导入。

比如下面这些代码中，只有 drive 函数才会被  `from x import *`  所导入

```python
_moto_type = 'L15b2'
_wheel_type = 'michelin'

def drive():
    _start_engine()
    _drive_wheel()

def _start_engine():
    print('start engine %s'%_moto_type)
    
def _drive_wheel():
    print('drive wheel %s'%_wheel_type)
```

## 突破保护

前面之所以说是“保护”并不是“私有”，是因为Python没有提供解释器机制来控制访问权限。我们依然可以访问这些属性：

```python
import tools
tools._moto_type = 'EA211'
tools.drive()
```

以上代码，以越过“保护属性”。此外，还有两种方法能突破这个限制，一种是将“私有属性”添加到tool.py文件的`__all__`列表里，使`from tools import *`也导入这些本该隐藏的属性。

```python
__all__ = ['drive','_moto_type','_wheel_type']
```

另一种是导入时指定“受保护属性”名。

```python
from tools import drive,_start_engine
_start_engine()
```

甚至是，使用`import tools`也可以轻易突破保护限制。所以可见，“保护属性”是一种简单的隐藏机制，只有在`from tools import *`时，由解释器提供简单的保护，但是可以轻易突破。这种保护更多地依赖程序员的共识：不访问、修改“保护属性”。除此之外，有没有更安全的保护机制呢？有，就是下一部分讨论的私有变量。



#  变量不能与保留关键字重名

在 Python 中有很多的保留关键字，这些关键字的使用，不需要我们定义，也不需要我们导入，只要你进入到了 Python 的环境中，就可以立即使用。

使用如下方法，可以查看 Python 中的保留关键字

```python
>>> import keyword
>>> keyword.kwlist
['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

而很尴尬的是，如果你在日常编码中，不经意地用到其中的一些关键字，就会产生冲突。

比如说 class，这个有类别的意思，可能你也想使用它来作为变量名，如果直接使用，会发生冲突

更好的做法是，使用下划线来避免冲突

```python
def type_obj_class(name,class_):
    pass

def tag(name,*content,class_):
    pass
```

