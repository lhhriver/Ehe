# 第01章 PSTN与VoIP基础
# 第02章 PSTN、PBX及呼叫中心业务
# 第03章 初识FreeSWITCH
# 第04章 运行FreeSWITCH
# 第05章 FreeSWITCH架构

# 第06章 拨号计划
# 第07章 SIP协议
# 第08章 媒体
# 第09章 SIP模块
# 第10章 基本技能

通过前面的章节的学习，我们了解了FreeSWITCH必备的一些背景资料和基础知识，并掌握了FreeSWITCH中的基本概念和基本理论。有了这些概念和理论为基础，我们接下来就可以着手进行实际练习了。

在本章，我们先来学习一些基本的技能，为以后的实践打下一个好的基础。

## 调试与排错

在实际的应用场景中，我们不可避免地会遇到各种各样的问题，而要解决这些问题一般需要根据问题的现象、系统提供的日志、线索等查找原因。因此，在进一步练习之前，我们先来学习一下解决问题的思路、方法和技巧。熟练掌握了这些方法和技艺，以后无论遇到什么样的问题就都会很容易解决了。

解决问题首先要找到相关的线索，并加以分析。在前面的章节中我们也穿插着介绍过一些调试的手段，在本节我们再系统讲解一下。

### 解决问题的一般方法和流程

解决问题一般要经过以下几个步骤：发现问题、定位问题、分析问题、解决问题。下面我们在对这些步骤进行讲解时并不上纲上线，而是以一个例子来简单地进行说明，目的就是教会大家如何发现并准确地定位问题。当定位了问题故障点后，就比较容易分析和解决该问题了。

假设我们遇到这样一个问题：Alice向我们报告说，她通过FreeSWITCH呼叫Bob，能呼通，但没有声音。

这确实是一个问题，因为电话的基本功能就是为了双方能互相听到对方的声音。不过，在这里我们虽然收到了这个问题报告，但对该问题的实际情况还了解得不够清楚。比方说，首先，也是最基本的，是两端都听不到声音，还是只有一方没有声音？其次，是每次都听不到，还是偶尔听不到？如果是偶尔，在什么情况下听不到？再次，Alice和Bob使用的是什么UA，软电话还是硬件的SIP话机？都是什么型号的？还有，他们所在的网络情况是什么样的？他们是用ADSL、小区宽带，还是用手机上网？……

一般来说，Alice只是个普通的电话用户，她可能不知道这些技术细节。但在这种情况下，我们就需要多问一下Alice，以确认这些问题实际上否与Alice描述的一致，以及能否重现等。了解了这些信息，我们才能进行下一步的定位和分析。总之，在这里，有两个问题是很值得考虑的：

- 核实问题的现象。即假定Alice是不可信的，就算她没说谎，但有时问题的实际现象Alice可能描述不清楚，或者可能跟她描述的完全不一样。如果有条件最好亲自试验一下。
- 问题能否重现。大家解决问题多了就会知道，如果一个问题总是能重现，那么一般是比较容易解决的。最难解决的问题就是不能重现的问题，或者不知道什么时候能重现的问题。说白了，就是电话有时候好，有时候不好，但至于什么时候好，什么时候不好，说不上来，总之就是没有任何规律。

在发现问题之后，就要尝试定位问题，即找出该问题出在什么地方。要想定位问题，要先有一个思路。笔者一般建议使用“分段法”和“换位思考法”来定位问题。所谓分段法，就是说，一个问题可能涉及很多环节，我们首先要把这些环节从逻辑上和功能上分开，一段一段地检查。所谓换位思考法，结合我们本节的例子可以理解为，如果Alice打给Bob没有声音，那么，Bob打给Alice有没有声音？能不能把Alice和Bob的话机对调一下再试一次？或者，有条件的话，给Alice或Bob换其他的话机试试。

这种定位问题的方法在对整个系统不了解的情况下，可以首先确定是不是话机终端的问题。使用这种方法不需要很高级的技术，但它却很有效，因为话机终端出现问题的情况会比较常见。比如，如果一方用的是软电话，还可以考虑是否是声卡有问题。好多人也会将喇叭静音，甚至出现音箱没开电源或耳机没插到正确的插孔里的情况。

当上面这些方法找不到具体原因时，就考虑分段法。如，首先让Alice拨打默认的9196，看能否听到自己的声音。到现在我们都很熟悉了，9196是默认的回音测试（echo）功能，如果Alice打9196都听不到声音，就先不要管Bob了，因为呼叫还没到达Bob，到目前为止还跟他一点关系都没有呢，所以要先集中精力解决Alice打9196的问题再说。

当然Alice打9196听不到声音的原因可能有很多，我们还需要一步一步地查。在这里首先建议关掉防火墙——Linux上的iptables、Windows防火墙等。对新手而言，这些太容易导致问题了。因此，简单地关掉，会省掉很多麻烦 [1]。

确认防火墙没有问题后，可以通过抓包看有没有RTP流到达或从服务器发出。我们将在下一节讲解使用Wireshark抓包的知识。在本节，我们来学习一个uuid_debug_media API命令。这是一个很有用但常常被忽略的命令。首先，在FreeSWITCH控制台上可以使用show channels命令来找到当前通话的Channel的UUID，然后使用uuid_debug_media调试媒体相关的信息。下面是笔者调试echo的情况（排版需要，截断了一些无关紧要的过长的行）。

首先找到当前通话的UUID，下列命令的结果中显示的第一个字段就是UUID：

```
freeswitch> show channels
```

```
uuid,direction,created,created_epoch,name,state,cid_name,cid_num,ip_addr,......
b4fae306-3f78-4d91-bcde-a2e95b0f9c1d,inbound,2013-07-23 12:04:38,1374552278,......
```

然后，使用uuid_debug_media命令查看调试输出。其中，该命令的第一个参数是Channel的UUID，接下来是欲调试的方向。方向有read和write两种（即读和写，也即收和发，都是相对于FreeSWITCH而言的，下同），也可以使用both参数表示双向都调试。最后一个参数是on或off，分别表示打开或关闭调试。命令的输出如下：

```
freeswitch> uuid_debug_media b4fae306-3f78-4d91-bcde-a2e95b0f9c1d both on
```

```
+OK Success
R sofia/internal/1002@192.168.7.5 b=172 192.168.7.5:17318 192.168.7.5:50050 pt=0 ts=3717002357 m=0
W sofia/internal/1002@192.168.7.5 b=172 192.168.7.5:17318 192.168.7.5:50050 pt=0 ts=3717002357 m=0
R sofia/internal/1002@192.168.7.5 b=172 192.168.7.5:17318 192.168.7.5:50050 pt=0 ts=3717002517 m=0
W sofia/internal/1002@192.168.7.5 b=172 192.168.7.5:17318 192.168.7.5:50050 pt=0 ts=3717002517 m=0
```

R与W分别表示Read和Write，即收和发。如果能看到R和W了，说明已正确收发媒体流。如果还是听不到声音，那可能需要更深入地检查了。更深入的检查在这里我们就不过多地展开了。我们在此再简单说一下上面调试输出的意义。b=172表示收、发172字节，它等于160字节的PCMU语音净荷（20ms）加上12个字节的RTP包头。17138和50050分别为本地和远端端口号。pt=0说明Payload Type（载荷类型）为0，即PCMU编码的语音数据。ts为时间戳，可以看出它在收和发方向上分别是以160递增的。最后m为RTP的Marker位，一般是0。

注意，上述我们使用了echo进行测试，它一般用于简单测试双向语音的情况，即FreeSWITCH作为一个“回音壁”，会等待客户端将RTP包发过来然后原样返回。如果由于防火墙或某种原因导致FreeSWITCH收不到RTP包，则它也就没有数据可发了。

在某些情况下，会只有单向的语音流，这种情况称为单通。测试单通的情况，可以用上面的uuid_debug_media对“收”和“发”分别测试。在没法执行上述命令的情况下，也可以使用更直观的方法进行测试。例如，出于简单起见，我们先测试“发”。拨打默认的9664，FreeSWITCH就会播放保持音乐，如果对方听不到的话，就需要在对方的电脑或话机上抓包看RTP包是否到达。如果没有到达，说明网络有问题，如果到达了还没有声音，那就可能是对方终端的问题，或扬声器或耳机的问题。

然后，倒过来测试是否能“收”到RTP流。先建一个Dialplan路由到record App进行录音，录音完成后听一下录音文件是否完整即可判断是否正确收到RTP流。录音的Dialplan设置如下：

```xml
<action application="record" data="/tmp/test.wav"/>
```

或者直接使用如下回拨命令进行录音：

```
freeswitch> originate user/1002 &record(/tmp/test.wav)
```

如果一切正常，说明Alice端没有问题了。如果有问题我们也可以使用上面的步骤定位到问题并进行解决。总之，当我们解决完了Alice端的问题后，再用同样的方法解决Bob的问题。保证两端都没有问题后，再尝试直接从Alice呼叫Bob，看bridge后是否还有其他问题。一步一步，直到问题解决。

最后需要说明，没有媒体流或者媒体流不正常也可能是收到SIP消息错误引起的，我们后面还会讲到跟踪SIP消息的方法。

### 查看日志

在有些情况下，呼叫可能直接不通，即无法正常建立呼叫。这时候我们就需要查看系统的日志。

在日志中，“警告”（WARNING）和“错误”（ERROR）是级别比较高的日志，“调试”（DEBUG）是级别比较低的日志，但其能显示更多的细节。在FreeSWITCH控制台上，可以通过console loglevel debug命令打开DEBUG级别的日志。

我们还是以Alice呼叫Bob为例，如果Alice发起呼叫后什么日志也不显示，那么肯定呼叫没有到达FreeSWITCH，此时应检查客户端是否配错了IP地址或防火墙是否有问题。如果呼叫到达了，还是出错，那么参照第6章中的介绍，查看是不是Dialplan设置的问题（还记得“从绿色的行开始看”吗？）。另外，日志中一般有挂机原因（Hangup Cause），比方说CALL_REJECTED一般代表呼叫被拒绝，可能是认证的用户名或密码不对。如果Alice方面没什么问题，错误也可能是Bob那端引起的，比如Hangup Casuse为USER_NOT_REGISTERED就说明Bob没有注册，因而呼叫无法继续进行。

有时候，呼叫Bob可能需要经过一个网关出去，这时候也可以采取“分段”的调试方法，如使用类似如下的命令看看呼叫的后半段有没有问题（即从FreeSWITCH中直接呼叫Bob有没有问题）：

```
freeswitch> originate sofia/gateway/gw1/Bob &echo
```

其中，gw1为呼叫Bob使用的网关的名字。上述命令是阻塞的，因而在Bob对应的网关没有任何反应的时候（不回任何SIP消息），可能会阻塞较长时间。当FreeSWITCH控制台被阻塞时，将不能输入任何命令。如果要解决这个问题，可以打开另一个终端，用fs_cli连接FreeSWITCH，然后使用show channels找到对应的Channel，并且用uuid_kill<channel UUID>将该Channel释放。当然，为了避免产生这种阻塞的情况，可以提前使用bgapi，如：

```
freeswitch> bgapi originate sofia/gateway/gw1/Bob &echo
```

bgapi可以使originate在后台（新的线程中）执行，因而不会阻塞控制台。

另外，在社区中（邮件列表或QQ群）中提问时，帮助你的人通常也会要求提供DEBUG级别的日志，以便于进行分析。

除了看日志以外，FreeSWITCH也支持现场抓包，使用下列命令可以在FreeSWITCH控制台上实时看到SIP消息，如：

```
freeswitch> sofia profile internal siptrace on
freeswitch> sofia profile external siptrace on
```

上面的命令可以开启不同Profile的SIP抓包。当a-leg和b-leg分别在不同的Profile上时可以分别来看，避免消息太多造成干扰。当然，初学者可能不知道实际的SIP消息应该走哪个Profile，这时可以使用以下命令打开所有Profile的抓包：

```
freeswitch> sofia global siptrace on
```

当然，也可以随时关闭抓包：

```
freeswitch> sofia global siptrace off
```

有时候，还能遇到更奇怪的情况，在试上了述各种办法后还是找不到原因。如果怀疑是SIP协议栈底层的问题（那么可能是SIP兼容性的问题或FreeSWITCH本身的BUG），就要打开底层协议栈的调试信息。开启Sofia协议栈底层的调试器的方法是使用以下命令：

```
freeswitch> sofia loglevel all 9
```

可以使用以下命令关闭所有底层的调试：

```
freeswitch> sofia loglevel all 0
```

Sofia层的日志信息会有很多，如果你比较熟悉的话（一般是开发者），也可以仅打开某一类的日志，如：

```
freeswitch> sofia loglevel nua 9
```

具体可以参考sofia命令的帮助信息，如直接输入sofia命令不带任何参数会显示一个帮助，里面可以看到下面一行：

```
sofia loglevel <all|default|tport|iptsec|nea|nta|nth_client|nth_server|nua|soa| sresolv|stun> [0-9]
```

上述帮助信息中可选的参数表示，可以选择调试Sofia协议栈的各个部分。协议栈底层的知识超出了本书的范围，我们在此就不多介绍了。

`小技巧`

有时候，尤其开启了测试以及SIP Trace后可能会收到大量的消息，不停滚动屏幕会令人很难定位到有问题的消息。笔者在调试时遇到这类问题时一般会使用fs_cli连接到FreeSWITCH，开启相应的DEBUG级别和跟踪，打个测试电话，然后使用Ctrl+D快捷键或/exit命令退出，这样就可以避免屏幕滚动了。

在实际应用中，遇到的问题可能还有很多。不要慌，冷静地思考和分析一下，一般很容易定位到问题。即使自己不能准确地定位问题，在寻找帮助时，把你通过上述步骤了解到的情况跟有经验的人说一下，一般他们就能很快帮你定位到问题。最忌讳的就是什么也不做，直接上QQ群里发问：“我装了FreeSWITCH，怎么打不通电话啊？”那样的话，问了等于白问，谁都帮不了你。

[1] 注意，如果你在病毒很多或者很容易受坆击的电脑或服务器上学习FreeSWITCH而又不明白关掉防火墙的风险的话，建议不要这样做。如何部署防火墙已超出了本书的范围，故这里不过多介绍了。

## 使用外部工具抓包

虽然在FreeSWITCH内部也可以抓包，但有时候需要对IP包进行更全面的分析，或者存档，因此经常需要使用外部的工具抓包。

现有的大部分工具都是基于libpcap实现的，它们在不同的场景下各有优势，这里我们来简单介绍一下 [1]。由于抓包是一种非常底层的操作，因此在大多数平台上通常需要用root或管理员用户来执行。他们大部分也都支持将抓包结果存储在本地PCAP格式的文件中，这种格式的文件后续可以使用其他工具（如rtpplay和Wireshark等）进行重放和分析。

### tcpdump

tcpdump [2]是经典的抓包工具。比如下面的命令可以仅抓取5060端口上的SIP包：

```
# tcpdump -nq -s 0 -A -vvv -i eth0 port 5060
```

其中，-n、-q表示不进行域名翻译及减少输出内容；-s 0表示不限制包长，即争取抓最大的长度；-A表示以ASCII方式输出，这样用眼看起来比较直观；-v表示显示的详细程度，“v”越多则越详细；-i表示使用指定的网卡；port 5060表示过滤器，这里我们只关心5060端口上的SIP包。

另外，可以使用-w将结果写入文件中，如下列命令将结果写入/tmp/dump.pcap文件中：

```
# tcpdump -nq -s 0 -i eth0 -w /tmp/dump.pcap port 5060
```

当还需要分析RTP流时，可以将port 5060简单改成udp，这样就可以抓取所有的UDP包：

```
# tcpdump -nq -s 0 -i eth0 -w /tmp/dump.pcap udp
```

有时候，如果你是在服务器上抓包，并想只抓某个用户的包，可以根据用户的IP地址来进行过滤。当然这需要先找到用户实际的IP地址，通过如下命令可以找到用户1002的Contact地址：

```
freeswitchlocalhost> sofia status profile internal reg 1002

Registrations:
==============================================================================

Call-ID:        ZjUwMGY3ODM5M2E2ZGM0MWFiZGRiNDhkNThkZjk3NzQ
User:           1002@192.168.7.5
Contact:        "Seven" <sip:1002@192.168.7.5:65272;rinstance=2d4d57704e73155d>
Agent:          Bria 3 release 3.5.0b stamp 69410
Status:         Registered(UDP)(unknown) EXP(2013-07-23 15:17:51) EXPSECS(616)
Host:           seven.local
IP:             192.168.7.5
Port:           65272
Auth-User:      1002
Auth-Realm:     192.168.7.5
MWI-Account:    1002@192.168.7.5
```

然后就可以只针对该用户抓包了（从Contact地址中我们知道它的IP和端口号分别是192.168.7.5和65272）：

```
tcpdump -i eth0 -s 0 -A host 192.168.7.5 and port 65272
```

有时候，我们也需要抓取所有的RTP包进行分析。在FreeSWITCH中，默认的端口号范围是16384～32768，因此我们可以使用如下命令抓包：

```
tcpdump -i eth0 -w /tmp/sip-rtp.pcap "udp and (port 5060 or port 5080 or portrange 16384-32768)"
```

上面的命令中，使用or（或）定义了多个过滤器参数，它分别代表抓5060、5080以及端口范围在16384至32768之间的包。

更详细的说明参见http://wiki.freeswitch.org/wiki/Packet_Capture。

### tshark

tshark [3]是Wireshark的命令行版。使用方法与tcpdump类似，如可以直接在命令行上运行tshark。下面是笔者电脑上的输出结果：

```
# tshark

Capturing on en0
  0.000000 192.168.1.119 -> 123.125.115.179 TCP 54 61729 > http [FIN, ACK] Seq=1 Ack=1 Win=16384 Len=0
  0.153641 173.194.79.109 -> 192.168.1.119 TLSv1 164 Application Data
  0.153644 173.194.79.109 -> 192.168.1.119 TLSv1 247 Application Data
  0.153645 173.194.79.109 -> 192.168.1.119 TLSv1 130 Application Data
  0.153672 173.194.79.109 -> 192.168.1.119 TLSv1 568 Application Data
```

其中，Capturing on en0表示从第一块网卡上抓包（注意，笔者用的是Mac系统，Mac上的en0相当于Linux上的eth0）。它等价于以下命令：

```
# tshark -i en0
```

另外，也可以将抓包结果写入pcap文件中，如在Linux上可以这样用：

```
# tshark -i eth0 -w /tmp/dump.pcap
```

与tcpdump比较起来，tshark能“认识”更多的协议，比如下面的命令可以很直观地看到收发的SIP包：

```
# tshark host 192.168.1.9 and port 5060

Capturing on en0
  0.000000 192.168.1.119 -> 192.168.1.9
  SIP 571 Request: REGISTER sip:192.168.1.9    (fetch bindings)
  0.010322  192.168.1.9 -> 192.168.1.119
  SIP 709 Status: 401 Unauthorized    (0 bindings)
  0.010972 192.168.1.119 -> 192.168.1.9
  SIP 817 Request: REGISTER sip:192.168.1.9    (fetch bindings)
  0.030214  192.168.1.9 -> 192.168.1.119
  SIP 587 Status: 403 Forbidden    (0 bindings)
```

上述的SIP包是笔者在调试的时候在本机上抓到的，笔者在注册一个远程服务器时由于密码错误，认证失败，因而收到了403 Forbidden消息。
当然，tshark还有很多其他的命令行参数，我们在这里就不多介绍了。我们将在10.3.1节讲解它对应的图形界面版本的用法。

### ngrep

ngrep [4]也是一个非常好用的抓包工具（类似于经典的UNIX命令行工具grep），它可以提供类似于FreeSWITCH内部的抓包输出的显示方式，显示比较直观。笔者常用的选项组合是：

```
# ngrep -p -q -W byline port 5060
```

其中，-p表示不使用混杂模式 [5]；-q表示使用安静模式，仅输出包头和相关包的载荷（如果有的话）；-W表示选择一种显示输出方式，对于基本文本的协议来说，使用byline可以按换行符进行换行，显示比较直观；最后的port 5060是一个过滤器，即我们只想看我们关心的包。下面是与上一节最后一个例子对应的ngrep抓包的结果：

```
# ngrep -p -q -W byline host 192.168.1.9 and port 5060

interface: en0 (192.168.1.0/255.255.255.0)
filter: (ip) and ( host 192.168.1.9 and port 5060 )
U 192.168.1.119:3454 -> 192.168.1.9:5060
REGISTER sip:192.168.1.9 SIP/2.0.
Via: SIP/2.0/UDP 192.168.1.119:3454;branch=z9hG4bK-d8754z-4d3eaa270f669f7b-1---d8754z-;rport.
Max-Forwards: 70.
Contact: <sip:607@192.168.1.119:3454;rinstance=9066826f34316cd5>.
To: "607"<sip:607@192.168.1.9>.
From: "607"<sip:607@192.168.1.9>;tag=42c9367f.
Call-ID: NTcwNDJhOWE3MDE0OTAwMmQzZDFkNjdlYTZjOGVhMDk.
CSeq: 1 REGISTER.
Expires: 3600.
Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, NOTIFY, MESSAGE, SUBSCRIBE, INFO.
User-Agent: Bria 3 release 3.5.0b stamp 69410.
Content-Length: 0.
.
U 192.168.1.9:5060 -> 192.168.1.119:3454
SIP/2.0 401 Unauthorized.
U 192.168.1.119:3454 -> 192.168.1.9:5060
REGISTER sip:192.168.1.9 SIP/2.0.
U 192.168.1.9:5060 -> 192.168.1.119:3454
SIP/2.0 403 Forbidden.
```

`注意`

上面的抓包结果中，为了节省篇幅，我们仅保留了第一个完整的SIP消息，其他的仅保留了起始行。

从上面的抓包结果中可以很清楚地看出数据包的传输方向以及SIP协议的具体内容。

除了host、port这样的过滤器外，ngrep还支持针对内容的过滤。这在比较繁忙的服务器上（比如有大量SIP包的情况下）比较有用。下面的命令可以过滤仅含有139xxxxxxxx（可能是个手机号码）字符串的内容：

```
# ngrep -p -q '139xxxxxxxx' -W byline port 5060
```

具体的过滤后的结果输出与上面讲到的类似，在这里我们就不多讲了。更多的选项可以查看ngrep的帮助信息。

### pcapsipdump

与上面的抓包工具不同，pcapsipdump [6]有一个很好的特性，它能将不同通话IP包存到不同的文件里，其中某一路通话所有的SIP和RTP数据都存到同一个文件中。这样在同时有大量通话的时候抓包分析比较有用。使用方法如下：

```
pcapsipdump -i eth0 -d /tmp/sipdump/
```

上述命令将抓到的包文件都以PCAP格式存放到/tmp/sipdump这个目录中。后续可以使用其他工具针对个别的呼叫进行分析。这在服务器话务量比较高的时候比较有用。

pcapsipdump工具也有其他参数，在这里我们就不多介绍了。建议读者把这里介绍的各种工具都试一下，这样在遇到问题时就可以比较熟练地使用合适的工具查找并解决问题了。

总之，本节介绍的4种抓包工具中，前两种除了语法稍有不同外，在功能上是差不多的，它们都能抓包并存为PCAP格式的文件，供以后分析。而ngrep主要的特点是类似于UNIX grep，在文本界面下实时看起来比较方便。最后的pcapsipdump是专门针对SIP的抓包工具，在抓包的同时能将不同的通话分别存放到不同文件中。在使用时，可根据需要选用合适的工具。

[1] 我们在以后的章节中更专注于具体应用，因而各种工具的具体安装步骤在此就不多费笔墨了。一般来说，在Linux系统上，都是yum install（CentOS/Redhat）或apt-get install（Ubuntu/Debian）后面加上软件包的名字即可。其他情况也读者也可以根据软件包的名字自行搜索相关的安装资料。 

[2] 参见http://www.tcpdump.org/。 

[3] 参见http://www.wireshark.org。 

[4] 参见http://ngrep.sourceforge.net/。 

[5] 混杂模式即Promiscuous Mode，如果将网卡设置成混杂模式便可以在一台主机上接收局域网上所有主机的包（当然这也取决于Hub或交换机的设置），也就是说有可能抓到发往其他主机的包。 

[6] 参见：http://sourceforge.net/projects/pcapsipdump/。

## 使用Wireshark抓包并分析呼叫

在涉及FreeSWITCH与其他系统的对接时，由于大家对SIP信令及相关RFC的理解有偏差，或者具体实现的取舍不一样，就可能造成信令间细微的差别。虽然在FreeSWITCH内部也可以抓包，但如果系统中有大量的呼叫，使用FreeSWITCH抓包就有些“看不过来了”。这时候，就要使用我们上一节讲到的各种抓包工具。

本节将介绍一款专用的抓包工具——Wireshark，其附带了更多的分析工具，可以比较全面地分析呼叫。

如果Wireshark跟你的FreeSWITCH在同一台机器上，可以直接使用Wireshark抓包；如果你想抓远程Linux服务器上的包，而一般远程机器没有或不打开图形界面，则可以在Linux上安装tcpdmp或Wireshark的命令行版本tshark。

### 使用Wireshark抓包

我们上一节讲到的各种抓包工具都是命令行版本的，比较适合应用在没有图形界面的服务器上。在这一节，我们要讲的是一个图形界面的抓包工具Wireshark，也就是tshark的图形界面版。当然，除了它有一个比较好的图形界面外，它更强大的功能是能识别主流的各种通信协议，因而可以很方便地分析协议的内容（它甚至专门有一个Telephony主菜单，专门用于分析各种电话类协议）。

Wireshark是跨平台的，在主流的平台上都有相关的安装包。关于如何下载和安装Wireshark，在这里我们就不多介绍了。下面我们来看一些实际抓包分析的例子。

在进行抓包前，首先打开Wireshark，按最左边的第一个图标选择一个网卡设备，如图10-1所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-532862.png)

<center>图10-1　选择一个网卡设备进行抓包</center>

在笔者的Mac电脑上，网卡的名字是en0，它相当于Linux上的eth0（在Windows上可能会有其他的名字，名字不确定）。一般来说，在选择网卡的界面上稍微停留一会，相关网卡后面会有带数字的流量指示，应该能比较容易找到对应的网卡。

选择一个网卡后，就可以单击Start开始抓包了。这时候，笔者打开了一个视频电话（默认的9196号码），此时可以看到SIP包以及许多RTP的包 [1]。

我们这时候就可以挂断电话了。电话挂断后，我们可以停止抓包，否则数据量大了以后看起来就比较麻烦了。另外，为了方便以后分析，我们也可以将抓到的数据包保存起来，一般保存为PCAP文件，这样的文件Wireshark能自动打开。

### 使用Wireshark对抓包进行分析

Wireshark可以分析使用tcpdump或pcapsipdump抓下来的pcap包。在这里，我们直接分析上一节抓到的包。

1. 分析SIP包

首先，我们先来看SIP信令。由于我们抓到了很多包，为了看起来方便，可以使用sip过滤器，只看我们关心的包。如图10-2所示，我们可以在“Filter:”一栏中输入“sip”，便可以只显示所有的SIP包。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-546860.png)

<center>图10-2　使用了sip过滤器只显示SIP包</center>

我们可以通过鼠标定位到INVITE消息，如图10-3所示，读者可以在下面的框里看到消息的内容。虽然它看起来不如直接在FreeSWITCH中直接用siptrace抓出来的纯文本的包直观，但是Wireshark可以对SIP消息做深入的分析，可以显示更多的帮助信息。图10-3显示了SIP中的INVITE消息的详细情况。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-561856.png)

<center>图10-3　在Wireshark中查看INVITE消息</center>

Wireshark甚至有专门分析VoIP通话的工具。在主菜单中，选择Telephony→VoIP Calls可以看到所有的VoIP呼叫，如图10-4所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-577859.png)

<center>图10-4　一路VoIP通话</center>

此时，选择一路呼叫并单击Flow按钮，就可以看到详细的SIP呼叫流程，如图10-5所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-592855.png)

<center>图10-5　Wireshark中分析呼叫流程</center>

有了前面的SIP基础，读者就可以按照这个流程自己试一下了。打几个正常的或者不正常的电话，比较一下它们的异同。

另外，在上一步中，Flow按钮的旁边有一个Play按钮，单击这个按钮以后再单击Decode按钮可以将音视频流的数据进行解码，并可以播放音频流里的声音。注意，如果音频不是以PCMU或PCMA格式编码的，则不能播放。关于RTP流的详细分析我们将在下一节进行讨论。

2. 分析RTP包

在Wireshark中也可以分析RTP包。在Filter栏中输入“RTP”就可以看到所有的RTP包。一般来说，可以先肉眼大体看一下收发是否规律。详细的分析可以使用Telephony→RTP→Show All Streams显示所有的RTP流，如图10-6所示，它显示了我们这次呼叫中涉及的两路PCMU的音频流和两路H264的视频流。

先选择一路音频流，通过单击Find Reverse按钮，可以找到并选择反向的流。然后单击Analysis就可以看到两路RTP流的详细分析，如图10-7所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-607854.png)

<center>图10-6　一个呼叫中的4路RTP流</center>

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-622856.png)

<center>图10-7　Wireshark中的RTP流分析</center>

在分析中，也可以通过上一节提到的Play按钮播放音频流，或者使用Save Payload按钮将音频数据存到单独的文件中。如果使用AU格式，则可以在同一个文件中保存双向的音频流；但如果使用RAW格式，只能将单向的音频流分别存到不同的文件里。另外，如前面所说，如果语音编码不是PCM格式的话（如G729），则音频流只能存成RAW格式，然后再用其他工具去分析。

除此之外，还可以使用Graph按钮生成某一路流相关的统计图，如果图表显示比较规律，那一般说明是比较好的，如果生成的图表不是很规律，那就说明可能是网络上有丢包、延迟或抖动等。（我们曾经在第9章讲过这几个指标，这里就不多讲了）。解决音频或视频质量的问题需要具体问题具体分析，读者可以在学习中慢慢积累经验。

最后值得一提的是，如果是分析视频流，可能会在视频分析结果中发现“Incorrect Timestamp”之类的提示，有时候这个提示不一定准确，因为该功能目前只适合分析音频流。

3. 其他技巧

前面我们提到过sip和rtp两个Filter，它们可以在Wireshark中过滤可见包的内容，其他常用的还有根据来源IP地址过滤，如：

ip.src == 192.168.1.143

根据目的地址过滤，如：

ip.dst == 192.168.1.143

还可以是多种条件的组合等，如：

ip.src == 192.168.1.127 && ip.dst == 192.168.1.143 && udp.port == 5060

上面我们抓到的是一个完整的呼叫。有时候，我们可以为了跟踪一路通话的语音问题而从一个通话的中间开始抓包。这时候，由于缺少SIP的上下文信息，所有抓包的内容显示为UDP（即如果没有SIP包的话，Wireshark就认不出这些UDP包是RTP包了）。如果出现这样的情况，我们需要找到类似RTP的包。比方说，如果我们知道呼叫是PCMU编码的，那么它的包长可能是214字节（IP+UDP包头42字节加上RTP包的172字节）。找到这类包以后，可以点击某一个包，然后从右键菜单中选择“Decode As...”，进而选择RTP，就可以将同类的包用RTP包的格式进行解码了。

更多的关于Wireshark的使用方法及技巧请参阅相关资料。

[1] 注意，笔者的FreeSWITCH与Wireshark在同一台机器上，而使用的软电话在另外一部手机上。如果所有设备在同一台机器上则抓不到包（当然有别的办法解决），因为要保证数据包是经过网卡的。如果读者想抓取与远程FreeSWITCH的通话，可以在与Wireshark相同的机器上装软电话，这样也能抓到包，只不过是客户端这一侧的。

## originate命令实例解析

originate命令是我们在调试过程中经常使用的一个命令，通过它几乎可以了解到系统中所有的知识，因此我们也在不厌其烦地对其进行讲解。虽然部分内容与前面的章节有所重复，但为了本节的完整性，笔者还是决定多啰嗦几句。另外，这里我们也将进行很多扩展和延伸。

在FreeSWITCH控制台上输入originate命令后就可以得到一个帮助（后面的小节均根据如下代码讲解）：

```
freeswitch> originate
-USAGE: <call url><exten>|&<application_name>(<app_args>)
        [<dialplan>] [<context>] [<cid_name>] [<cid_num>] [<timeout_sec>]
```

跟其他约定一样，尖括号一般是必选参数，而方括号里面是可选参数。

### 使用格式和参数

上述代码中，第1个参数call url就是我们通常所说的呼叫字符串（Dial String）。originate命令用于从FreeSWITCH中向外发起一个呼叫，这个“外”就是用这里的呼叫字符串指定的。

关于呼叫字符串的概念我们已经在4.5.2节讲过了，这里我们再复习一下。看以下命令：

```
freeswitch> originate user/1000 &echo
```

上述命令中的user/1000就是呼叫字符串。它表示从本地的注册用户中查找该用户的联系地址。呼叫字符串的格式是“类型/参数/参数”，其中第一部分是字符串的类型。下面我们先来做个实验，看输入一个错误的字符串会出现什么：

```
freeswitch> originate test/1000 &echo
```

```
-ERR CHAN_NOT_IMPLEMENTED
[ERR] switch_core_session.c:496 Could not locate channel type test
[NOTICE] switch_ivr_originate.c:2661 Cannot create outgoing channel of type [test] cause: [CHAN_NOT_IMPLEMENTED]
```

其中，CHAN_NOT_IMPLEMENTED表示这种Channel的类型没有实现，因而这不是一个合法的字符串，无法创建这种类型的Channel并进行呼叫。
那么，系统到底提供了多少Channel类型呢？一般来说，每种Endpoint都会提供相应的呼叫字符串，每一种呼叫字符串的类型都属于一个Endpoint Interface，其中一些类型又类似于一种“高级”的呼叫字符串，如user和group。这些呼叫字符串看起来像一个虚拟的Endpoint Interface，它们最终会解析到底层的sofia Endpoint Interface。

另外，我们在前面的章节中也讲过，可以通过逗号（，）或竖线符号（|）将多个呼叫字符串隔开，以达到同振或顺振的目的。如下面命令可同时呼叫1000和1001，两个话机都会振铃，哪个先接听则接通哪个，另一路会自动挂断，这种呼叫方式称为“同振”：

```
freeswitch> originate user/1000,user/1001 &echo
```

下列命令就是“顺振”，即第一个号码呼叫失败则呼叫第二个：

```
freeswitch> originate user/1000|user/1001 &echo
```

### 转入Dialplan

originate的第2个参数是一个exten（可以认为是一个分机号），或者是一个“&”符号加上App。对于后者，我们已经很熟悉了，整个命令的作用是向外发起一个呼叫，建立一个Channel，对方接听后在本端执行一个App，如上面的echo。

对于前者，与上述的情况类似，在向外发起一个呼叫并等待对方接听后，FreeSWITCH就与对方建立了一个Channel，Channel的远端当然是接听电话的用户。在本端与上述App的情形不同的是，它会将Channel转入Dialplan去路由，路由要查找的目的地就是exten。也就是说，在用户接听后，这种情况跟用户呼入的处理是一样的，都是进入Dialplan进行路由，如在默认的配置中，下面的两条命令基本上是等价的：

```
freeswitch> originate user/1000 9196
freeswitch> originate user/1000 &echo
```

前者在1000接听后进入Dialplan，找到9196这个exten，然后再执行echo。

接下来再看第3个参数，它是Dialplan的类型，如果不设置，默认就是XML。我们在第8章曾讲到过inline Dialplan，因此也可以在这里试一下，它与上面的例子也是等价的：

```
freeswitch> originate user/1000 echo inline
```

第4个参数是Dialplan的Context，对于inline Dialplan，它会忽略Context，而对于XML则是有效的，如：

```
freeswitch> originate user/1000 1001 XML public
```

上述命令在1000接听后会进入public Dialplan查找路由。

### 更改主叫号码

接下来的两个参数分别是主叫名称（cid_name，Caller ID Name）和主叫号码（cid_number，Caller ID Number）。比如初学者经常看到0000000000这样的主叫号码，那是FreeSWITCH发起呼叫时默认使用的主叫号码。我们也可以在发起呼叫时自行指定主叫号码，而不使用默认值，如：

```
freeswitch> originate user/1000 &echo XML default 'Seven Du' 7777
```

注意，如果参数中有空格，需要用单引号引起来。上述命令产生的INVITE消息如下，其中主叫号码信息在From和Remote-Party-ID字段中（这里省略了其他字段）。

```
INVITE sip:1000@192.168.1.127:47294;rinstance=a39d7b2af86ea27d SIP/2.0
Via: SIP/2.0/UDP 192.168.1.127;rport;branch=z9hG4bKc0yQ4NU04paXr
Max-Forwards: 70
From: "Seven Du" <sip:7777@192.168.1.127>;tag=y5j452DSQNUBS
To: <sip:1000@192.168.1.127:47294;rinstance=a39d7b2af86ea27d>
Remote-Party-ID: "Seven Du" <sip:7777@192.168.1.127>;party=calling;screen=yes;privacy=off
```

图10-8所示是软电话客户端显示出来的来电信息。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-638857.png)

<center>图10-8　来电时软电话显示的主叫号码</center>

### 处理呼叫超时

最后一个参数是超时的秒数。值得注意的是，它并不是对方不接电话超时的秒数，而是对方在收到我们INVITE消息后，不回复100 Trying消息的时间。一般来说这种情况是IP地址不可达。如下面的例子中，我们使用了一个不存在的IP地址192.168.100.100：

```
freeswitch> sofia profile internal siptrace on
freeswitch> originate sofia/internal/1000@192.168.100.100 &echo XML default 'Seven Du' 7777 10
[NOTICE] switch_channel.c:1030 New Channel ......

send 1141 bytes to udp/[192.168.100.100]:5060 at 10:21:08.564598:
------------------------------------------------------------------------

INVITE sip:1000@192.168.100.100 SIP/2.0
send 1141 bytes to udp/[192.168.100.100]:5060 at 10:21:09.566271:
send 1141 bytes to udp/[192.168.100.100]:5060 at 10:21:11.567140:
send 1141 bytes to udp/[192.168.100.100]:5060 at 10:21:15.568274:

[NOTICE] switch_ivr_originate.c:3410 Hangup
sofia/internal/1000@192.168.100.100 [CS_CONSUME_MEDIA] [NO_ANSWER]
-ERR NO_ANSWER
```

上面我们先打开了siptrace，从输出的信息中我们可以看出，在FreeSWITCH发出INVITE消息后，由于没有收到100 Trying回复，于是在1秒后重发INVITE消息，如果还收不到则于2秒、4秒后重发 [1]，由于我们指定了10秒超时，因此该呼叫于10秒后失败，返回NO_ANSWER。

### 防止命令阻塞

originate命令是阻塞的，因此如果执行上述命令，则无法输入其他命令或取消该呼叫。解决这一问题有两个办法：

- 使用bgapi，如bgapi originate sofia/......
- 开启另外一个fs_cli客户端，使用show channels找到该呼叫的UUID，然后执行uuid_kill；或者，直接执行hupall挂断所有通话。
    以上是在命令行上的解决办法，尤其要注意的是，如果我们在Event Socket方式下使用originate发起呼叫，一般要使用bgapi来避免阻塞，如：

```
freeswitch> bgapi originate user/1000 &echo
```

### 使用通道变量

大家已经知道，通道变量可以影响呼叫的行为。我们在orignate时也可以使用通道变量。到这里，我们又回到呼叫字符串，因为通道变量是加在呼叫字符串上的。

通过使用通道变量，下列命令也能改变主号名称和号码：

```
freeswitch> originate {origination_caller_id_name='Seven Du',
originatioin_caller_id_number=7777}user/1000 &echo
```

多个通道变量之间使用逗号隔开，有时候有的通道变量里会有逗号，可能造成冲突，因而下面的命令都达不到你想要的效果：

```
freeswitch> originate {absolute_codec_string=G729,PCMU}user/1000 &echo
freeswitch> originate {absolute_codec_string='G729,PCMU'}user/1000 &echo
```

上述命令的本意是在呼叫时，在SDP里向对方提供G729和PCMU编码，但我们执行上述命令，却在日志中看到PCMU被丢掉了：

```
freeswitch> originate {absolute_codec_string='G729,PCMU'}user/1000 &echo
[DEBUG] switch_ivr_originate.c:2060 Parsing global variables
[DEBUG] switch_event.c:1615 Parsing variable [absolute_codec_string]=[G729]
```

所以，我们需要对Codec字符串里的逗号进行转义，可以使用一个反斜杠来进行转义，如：

```
freeswitch> originate {absolute_codec_string=G729\,PCMU}user/1000 &echo
```

或者，使用“^^”进行转义，用别的符号代替逗号分隔符，如：

```
freeswitch> originate {absolute_codec_string=^^:G729:PCMU'}user/1000 &echo
```

其中，“^^”后面跟冒号表示以后要用冒号代替逗号，FreeSWITCH在遇到冒号时就会把它用逗号替换回来，这样就可以避免因为逗号冲突而导致错误 [2]。

有时候，这些通道变量参数可能是程序里自动生成的，因而计算何时该用逗号可能要多费一些代码，所以FreeSWITCH也支持将不同的变量写到不同的大括号中，如：

```
freeswitch> originate {var1=1}{var=2}{var3=3}user/1000 &echo
```

还有一类通道变量是在方括号中定义的，称为局部通道变量。它唯一作用于某一条腿。在先呼叫某一用户的办公分机时，如果超时，则通过网关gw1呼叫其手机号，如果再超时，则通过网关gw2呼叫：

```
freeswitch> originate {var1=1}[leg_timeout=10]user/1000|
    [leg_timeout=20]sofia/gateway/gw1/1380000000|
    [leg_timeout=20]sofia/gateway/gw2/1380000000
```

其中，leg_timeout只应用于靠近它的那一条腿上，它用于定义呼叫超时，即等待对方返回媒体（如183或200）的超时时间。而var1=1是全局的，每条腿都会有这个变量。

通过使用局部的通道变量，就可以为不同的腿（不同的网关或不同的呼叫路径）定义不同的参数，如这里使用leg_timeout为不同的腿定义不同的超时时间。

### Early Media对呼叫的影响

一般而言，如果我们呼叫本地的IP话机或软电话，对方回的是180 Ring，同样情况下如果通过网关呼叫PSTN用户的话，则PSTN网络往往会返回Early Media，也就是前期的振铃音或彩铃。PSTN在呼叫失败时也会返回Early Media，如“您拨的电话忙，请稍后再拨……”等。Early Media一般是用183消息指示的。因而，一旦对方返回了183，FreeSWITCH就认为originate成功了。注意，从这里可以看出，前面我们讲到：“在执行originate时，originate命令会一直等待对方接听才返回”，这种说法不是很准确，当时我们只是为了讲起来简单。严格来说，originate命令是在收到媒体指示就返回的，如收到SIP中的183或200消息。一般来说，软电话不会返回183，因而该命令直到软电话接听（即收到200时）才返回，但在通过外部网关拨打PSTN电话的时候往往不是如此，PSTN网络中大多数情况下会在电话应答前返回回铃音（即Eearly Media），然后相连的网关设备就会向FreeSWITCH回复带SDP的183消息，以建立媒体通路。

有时候，有些Early Media对我们没有意义，如我们在主动外呼的应用中（如电话自动催费）希望用户真正接听以后才对他放音，或进入IVR，这时怎么办？有一个参数可以帮我们做到，如下：

```
freeswitch> originate {ignore_early_media=true}sofia/gateway/gw/13800000000
    &playback(/tmp/test.wav)
```

通过指定ignore_early_media变量，FreeSWITCH在发起呼叫时会忽略对方返回的Early Media，直到等到收到正常的应答信号（如200 OK）才返回。

### bridge也使用originate

读到这里读者可能困惑了，为什么bridge也使用originate？何况我们讲过，bridge是一个App而originate是一个API？

带着这个问题我们来看下面这个例子。我们使用originate命令发起一个呼叫，接通1000和1001两个号码：

```
freeswitch> originate user/1000 &bridge(user/1001)
```

当上述originate命令发起呼叫时，建立一个Channel，然后呼叫1000，1000接听后，在该Channel上（它相当于a-leg）执行bridge App，bridge会再建立另一个Channel（即b-leg）来呼叫1001。此时，1000和1001这两个Channel在信令上建立了桥接关系。1001接听后，bridge会把它们的媒体也桥接起来，此时进入正常通话。

实际上，在FreeSWITCH内部，originate和bridge都是调用同一个函数来实现的，为了简单起见，我们使用如下伪代码：

```
originate(session, new_session, dial_string);
```

当originate调用该函数时，session为空，因此相当于调用：

```
originate(NULL, new_session, "user/1000");
```

这时它就建立了一个新的session，即new_session，我们称之为session_a。这里user/1000为呼叫字符串，如果该呼叫字符串包含有{originattion_caller_id_number=1000}，则会以1000作为主叫号码（由于主、被叫号码相同，看起来相当于1000呼1000），否则使用默认的00000000作为主叫号码。

如果a接听了，在调用bridge时，bridge会进行如下函数调用：

```
originate(session_a, new_session, "user/1001");
```

上述函数调用也会建立一个新的new_session（b-leg）来呼叫1001，但与第一次调用不同的是，这次它有参照物了。这个参照物就是我们刚才建立的session_a。比如，它会使用从session_a（a-leg）中获得的主叫号码作为b-leg的主叫号码，它会根据a-leg上的call_timeout参数来决定b-leg的呼叫超时时长等。

总之，a-leg和b-leg现在已经是建立关系了，关于呼叫接下来的进展我们在下一节讨论。

### bridge中的Early Media

在本节我们通过Early Media的例子来进一步讲解bridge。

在上节所述的场景下，如果b-leg返回SIP的183 Session Progress，则FreeSWITCH也会向a-leg发183 Session Progress，因此可以将b-leg上收到的媒体发到a-leg上，a-leg就听到了回铃音（或彩铃、呼叫失败提示音等）。

如果b-leg返回180，则由于a-leg已经接听（a-leg已经处于answered状态，即处于正常通话状态），因此FreeSWITCH无法为a-leg发送180 Ringing消息，因而a-leg在b-leg振铃期间将听不到任何声音。

为了解决这个问题，可以让FreeSWITCH作为一个中间人，为a-leg在这种情况下产生一个假的回铃音，实现方法是在bridge之前设置一个transfer_ringback变量，如我们需要使用下面的方法重新发起呼叫：

```
freeswitch> originate {transfer_ringback=local_stream://moh}user/1000 &bridge(user/1001)
```

这时a-leg接听后，如果b-leg振铃，a-leg将能听到假的回铃音。这里假的回铃音是在收到b-leg的180时开始播放的。有时候，等待收到b-leg的180 Ringing也需要很长时间，因而另外一个参数instant_ringback可以让bridge立即播放回铃音：

```
freeswitch> originate {instant_ringback=true}{transfer_ringback=local_stream://moh}user/1000 &bridge(user/1001)
```

以上的参数都是用在a-leg已经接听的情况，即回呼的情况。关于a-leg正常呼入的情况我们将在下一节介绍。

### bridge中的主叫号码

关于主叫号码的显示（俗称来电显示）是大家普遍关注的一个问题。本节就带领大家了解一下和主叫号码显示的知识。在10.4.4节我们讲过，使用FreeSWITCH发起呼叫时可以使用下面的命令设置主叫号码（下面是将主叫号码设为7777）：

```
freeswitch> originate {origination_caller_id_number=7777}user/1000 &echo
```

设置好以后，假设我们使用bridge呼叫b-leg，具体实现如下：

```
freeswitch> originate {originattion_caller_id_number=7777}user/1000 &bridge(user/1001)
```

由FreeSWITCH发现a-leg是一个回呼，当a-leg接听后，再作为主叫去呼叫b-leg时，会进行主叫号码翻转。在日志中我们就可以看到如下的行：

```
[INFO] switch_channel.c:2978 sofia/internal/sip:1000@192.168.1.127:47294
Flipping CID from "" <7777> to "Outbound Call" <1000>
```

由以上信息可以知道，翻转后a-leg的主叫号码就变成了1000，它去桥接1001时，显示的主叫号码1000是正确的。

但是有的时候，我们想改变1000这个主叫号码（当然这里我们不管是出于什么目的，这里仅进行技术上的讨论），比方说我们想把它变成8888，那么可以使用如下的方法（注意，因为我们这里不关心a-leg在接到电话时显示什么主叫号码，所以省略一些参数，命令行短了一些）：

```
freeswitch> originate user/1000 &bridge({origination_caller_id_number=8888}user/1001)
```

与originate类似，bridge的参数也是一个呼叫字符串（从10.4.8节我们知道，bridge本质上就是originate），因而它也可以使用一样的通道普量以控制主叫号码的显示。

如果直接在b-leg上设置变量不方便，那么改变b-leg上显示的主叫号码还可以在a-leg上做文章。回想一下，bridge在调用originate进行呼叫的时候是知道a-leg的信息的，这个信息的获取就来自于a-leg的effective_caller_id_number这个变量，所以我们可以通过以下命令达到这个目的：

```
freeswitch> originate {effective_caller_id_number=8888}user/1000 &bridge(user/1001)
```

总之effective_caller_id_number变量设置在a-leg上，但影响b-leg的主叫号码显示（俗称来电显示）；origination_caller_id_number可以设置到a-leg，也可以设置到b-leg上，它将影响本leg的来电显示。

最后我们把这个例子做完整。我们使用命令呼叫1000和1001两个号码，在1000上显示7777，在1001上显示8888。下面两种方法是等价的：

```
freeswitch> originate {originatioin_caller_id_number=7777}user/1000
    &bridge({origination_caller_id_number=8888}user/1001)
freeswitch> originate {originatioin_caller_id_number=7777}{effective_caller_id_number=8888}user/1000
    &bridge(user/1001)
```

至此，我们对originate和bridge的讨论就告一个段落了。真正理解和掌握这些内容还需要读者多做练习。

[1] 关于重发隔可以参考RFC3261，也可以把这里的超时时长改大一点，如100，自己跟踪消息看一下。 

[2] 在使用sip_h_、sip_rh_及sip_ph时，这种转义操作不适用，所以还得用反斜杠来解决，如{sip_h_X-My-Header=one\,two\,three}。

## 呼叫是怎样工作的？

本节我们分析一个呼叫在FreeSWITCH里面到底是怎么工作的，若涉及前面的一些基础概念，我们也会简单复习一下，复习不到的请自行翻阅前面的章节。

首先，我们假设你用的是默认的配置，并从1000呼叫1001。我们把1000称为主叫，把1001称为被叫，如图10-9所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-652859.png)

<center>图10-9　FreeSWITCH中的呼叫流程</center>

1000的SIP话机作为UAC会发送INVITE请求到FreeSWITCH的5060端口（见图10-9中的①），也就是到达mod_sofia的internal这个Profile所配置的UAS（见conf/sip_profiles/internal.xml）。该UAS收到正确的INVITE后会返回100响应码，表示我收到你的请求了，稍等片刻。该UAS中对所有收到的INVITE都要进行鉴权（因为auth-calls=true）。它会先检查ACL（访问控制列表。一般用于IP鉴权，我们暂时还没学到ACL，留到后面去讲）。默认ACL检查是不通过的，因此就会走到密码鉴权阶段，SIP没有发明新的鉴权方式，而是使用与HTTP协议中一样的Digest Auth [1]进行鉴权。其特点就是密码并不在网络上传输，因而比较安全。读者可以翻到第7章看一下具体的认证流程，一般是UAS回复401，然后UAC重新发送带鉴权信息的INVITE。UAS收到后，便将鉴权信息提交到上层的FreeSWITCH代码，FreeSWITCH就会到Directory（用户目录）中查找相应的用户（见图10-9中的②），在这里它会找到conf/directory/default/1000.xml文件中配置的用户信息，并根据其中配置的密码信息进行鉴权。如果鉴权不通过，则回送403 Forbidden等错误信息，会话结束。

如果鉴权通过，FreeSWITCH就取到了用户的信息，比较重要的是user_context，在我们的例子中它的值为default。接下来电话进入路由（Routing）阶段，开始查找Dialplan（见图10-9中的③）。由于该用户的Context是default，因此路由就从default这个Dialplan查起（由conf/dialplan/default.xml定义）。Context的对应关系如图10-10所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-666854.png)

<center>图10-10　Context的对应关系</center>

查找Dialplan的流程已经在第6章讲过了，总之它会帮你找到1001这个用户，并执行bridge user/1001。这里，user/1001称为呼叫字符串，它会再次查找Directory，找到conf/directory/default/1001.xml里配置的参数（见图10-9中的④）。由于这里1001是被叫，因此它会进一步查找直到找到1001实际注册的位置。实际上，它实际的注册位置是用dial-string参数来表示的，由于所有用户的规则都一样，因此该参数被放到conf/directory/default.xml中，在该文件中可以看到如下设置：

```xml
<param name="dial-string" value="{sip_invite_domain=${dialed_domain},presence_id=${dialed_user}@${dialed_domain}}$
    {sofia_contact
    (${dialed_user}@${dialed_domain})}"/>
</params>
```

其中，最关键的是sofia_contact这个API调用，它会查找数据库，找到1001实际注册的Contact地址，并返回真正的呼叫字符串。如在笔者的机器上执行如下命令可以返回1001注册的Contact地址：

```
freeswitch> sofia_contact 1001@192.168.1.109
sofia/internal/sip:1001@192.168.1.109:51641
```

找到呼叫字符串后，FreeSWITCH又启动另外一个会话（见图10-9中的⑤）作为一个UAC给1001发送INVITE请求（见图10-9中的⑥），如果1001摘机，则1001向FreeSWITCH回送SIP 200 OK消息，FreeSWITCH再向1000回SIP 200 OK，通话开始。

FreeSWITCH是一个B2BUA，上面的过程建立了一对通话，其中有两个Channel。

参照第7章，读者不妨跟踪SIP消息试一下，在控制台上打开跟踪的命令是：

```
sofia profile internal siptrace on
```

关掉调试的命令是：

```
sofia profile internal siptrace off
```

在FreeSWITCH的默认配置中，external.xml对应的Profile是不鉴权的，因此凡是送到5080端口的INVITE都不需要鉴权。那么什么情况下或者怎样将INVITE会送到5080呢？有以下两种情况：

- FreeSWITCH作为一个客户端，若要添加一个网关，则该网关会被放到sip_profiles/external/的XML文件中，它就会被包含到sip_profiles/external.xml中。它向其他的服务器注册时，其Contact地址就是IP:5080，如果有来话，对方的服务器就会把INVITE送到它的5080端口（跟上面我们呼叫1001时把INVITE送到51641端口是同样的道理）。
- 大部分SIPUA允许你直接把INVITE送到任意一个端口，这一般用在中继方式对接的情况。

读者也可以看到，在external.xml中auth-calls=false。所以，当它收到INVITE时就不会进行鉴权了，而是直接对来话进行路由。

而路由需要一个Context，这个Context从哪里来呢？仔细看一下external.xml，里面有这样一条：

```xml
<param name="context" value="public"/>
```

所以路由就会查找public这个Dialplan，而其中只定义了很少的Extension，也就是说不经过认证的INVITE请求一般只能做比较少的事情，如只处理来话。

读到这里，读者也许会问：我怎么看到internal.xml里的context值也是public呢？

不错，但是internal这个Profile中还有auth-calls=true这一参数。对于一路来话而言，如果经过了认证，就会找到一个用户，然后就会使用我们最前面所说的用户目录中的user_context，而不是使用这个Profile中的context。即用户目录中的user_context比Profile中的context参数优先级要高。

那么，这个Profile中的context什么时候用呢？

前面已经说过我们还没讲到ACL，不过，如果你正确配置了ACL的话，对有些IP地址发来的INVITE请求可以不鉴权，那么自然就不知道是哪个用户打来的电话，因此就无法找到对应的user_context，那就只能使用Profile提供的context了。当然，你可以根据需要把这个context改成任意值，只要你配置了相应的Dialplan进行路由就行了。

值得一提的是，对于没有经过鉴权的呼叫，同样可以有主、被叫号码，只不过主叫号码是不可信的，对方可以指定显示任意号码。如果你讲究严谨的话，就需要多做些工作了，如使用我们10.4.13节说的effective_caller_id_number强制设置显示某些主叫号码等。

[1] http://en.wikipedia.org/wiki/Digest_access_authentication。

## FreeSWITCH图形用户界面简介

图形用户界面即我们通常所说的GUI（Graphic User's Interface）。对于广大开发者和极客们来讲，使用命令行配置和手工修改配置文件是最理想的选择。但对于FreeSWITCH新手或维护人员来讲，可能更喜欢一个图形界面来帮助理解和使用FreeSWITCH。

对于GUI的开发来讲，FreeSWITCH提供了丰富的底层接口支持，因而很容易在上层进行开发。但是，开发一个功能全又适合所有人胃口的GUI也绝非易事。FreeSWITCH官方的wiki [1]上列举了一些现有的GUI产品，有开源的也有商业的，它们各有特点，但到目前为止还没有一个占统治地位的GUI产品。当然，出现这一问题的原因也可能是FreeSWITCH提供的接口和API比较丰富，因而很容易集成到现成的业务系统中去，因此开发通用GUI的需求不是很强烈。

一般来说，开发FreeSWITCH的GUI有两种方法：

- 通过提供图形界面，后台修改FreeSWITCH的XML配置文件，并调用reloadxml或其他重启指令使之生效。这种方法只适合管理一台FreeSWITCH，即适合少量用户的管理。
- 通过使用FreeSWITCH提供的xml_curl接口，提供一个HTTP服务器动态向FreeSWITCH提供XML。这种方法可以管理多台FreeSWITCH，并适合大规模部署。

下面我们来介绍几款典型的开源GUI产品。

### FusionPBX

FusionPBX是使用PHP开发的FreeSWITCH GUI。它支持Linux、Windows、BSD、Mac OS X等多种操作系统，并支持PostgreSQL、MySQL、SQLite等数据库。

它是通过将数据存储到数据库中，并修改本地的XML配置文件实现的。

它支持无限的分机、IVR、呼叫组、传真、会议、队列、呼叫前转、点击拨号，以及实时呼叫状态显示等诸多特性，使用起来比较方便。

FusionPBX一直处于比较活跃的开发中。更多的介绍请参考http://www.fusionpbx.com。

### blue.box

blue.box是2600Hz团队开发的一款开源的GUI产品，使用PHP/MySQL技术开发。它最初的开发是基于著名的Asterisk的GUI FreePBX，号称是FreePBX V3。它也是使用修改本地XML配置文件并重新加载的方式工作。除支持普通的用户、分机、路由管理外，它还支持多语言和多租户。

由于2600Hz团队近几年一直把精力放在基于Erlang的云平台上，所以blue.box的开发一度中断。不过，在ClueCon 2013上，2600Hz团队又宣布了该项目的重生，新的开发计划将基于Python。

更多的介绍请参考：http://www.2600hz.org。

### FreeSWITCH Portal

FreeSWITCH-Portal是笔者发起的一个项目。与其他GUI系统不同的是，该项目并不致力于替代上述的GUI系统，而是作为它们的一个补充，提供一些开发者常用的功能，便于新手进行学习。

首先，FreeSWITCH Portal提供了开箱即用（Out of the Box）功能。上述的各种GUI产品都或多或少依赖于Apache/Nginx等Webserver、PHP等开发语言及PostgreSQL/MySQL等数据库，因此，配置GUI本身就需要一定的知识和基础。而FreeSWITCH Portal内置于FreeSWITCH，它仅依赖于mod_xml_rpc模块提供的内置于FreeSWITCH的Webserver。该模块是默认编译的，但不加载，因此用户只需要加载该模块即可使用它。

在FreeSWITCH控制台上执行下列命令就可以加载该模块：

```
freeswitch> load mod_xml_rpc
```

如果想让该模块随着FreeSWITCH启动而自动加载，可以在conf/autoload_configs/modules.xml中将模块的注释去掉，去掉注释后的配置如下：

```xml
<load module="mod_xml_rpc"/>
```

然后使用浏览器打开http://localhost:8080/portal（如果FreeSWITCH所在主机与要访问的电脑不同，则将localhost换成FreeSWITCH所在主机的IP地址），如果提示分别输入用户名和密码则分别输入“freeswitch”和“works”，该密码可以在conf/autoload_configs/xml_rpc.conf.xml中配置。系统界面如图10-11所示。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-682857.png)

<center>图10-11　FreeSWITCH Portal</center>

系统主菜单一共可以分为以下几个部分：

- Users：显示所有用户。
- Calls：显示当前的呼叫状态，如果选中“Auto Update”复选框，则表示它是实时更新的。
- Channels：显示当前所有Channel的状态，它是实时更新的。
- Show：调用系统的show命令显示很多FreeSWITCH内部的东西，如注册信息、已加载的模块、App、API等。

如果看到绿色的“Socket Connected”，则表示Websocket连接正常。注意，目前Websocket是不认证的，因此可能有安全性问题，如果你在生产系统中使用，请注意安全。

如果你看到右上角红色的“Socket Disconnected”也不用担心，那是因为你的系统不支持Websocket，修改xml_rpc.conf.xml，将“enable-websocket”参数设为true就可以了。

```xml
<param name="enable-websocket" value="true"/>
```

另外，你也需要使用能支持Websocket的浏览器，现代的浏览器如Chrome、FireFox、Opera、IE9及以上版本等都支持Websocket。

如果你的系统不支持Websocket，你也不会损失太多功能。数据的更新会自动变成通过Ajax轮循方式获取。

另外，如果你是一个开发者的话，相信你比较关心系统的事件。我们在5.1.1节的最后讲过在fs_cli中订阅和查看事件的方法，但是好多人会让FreeSWITCH动辄数百行的“大”事件吓倒。在FreeSWITCH Portal里，笔者还留了一个“后门”，可以允许用户用更好的方法查看系统事件。

很多浏览器（如Chrome或FireFox）都具有网页调试功能（FireFox上有著名的FireBug插件）。我们这里以Chome为例来说明。如图10-12所示，在Chrome浏览器页面上右击，单击最下方的“审查元素”（Inspect Elements），即可在页面下方打开调试窗口。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-697858.png)

<center>图10-12　通过浏览器的调试功能查看系统事件</center>

在调试窗口中切换到Console页，输入：

```
event("ALL");
```

即可订阅全部事件。如果这时候打个电话，就可以看到调试窗口中输出各种事件的名字，读者就知道打一个电话大体都会产生哪些事件了。细心的读者也可以做一下“慢动作”，顺便观察不同时间产生的不同事件，如振铃时产生什么事件、接听时产生什么事件、挂机后又产生什么事件等。

另外，通过打开全局的调试事件的选项可以看到更详细的事件信息，在调试窗口中输入：

```
global_debug_evnet = true;
```

如果不想看详细事件了，则把上述变量改成false即可，或直接刷新页面。

当然，任何时候都可以通过api或bgapi函数来直接执行FreeSWITCH的API命令，如：

```
api("status");
api("sofia status");
bgapi("originate user/1000 &echo");
```

总之，FreeSWITCH Portal致力于简单、实用、易用。如果读者发现上面提到的某些功能不好用，可以更新到最新的版本（2013年8月14日以后的版本）。在该系统的About页面上，也列了一些将要完成（Todo）的功能，如增加国际化（如中文）语言的支持等，如果读者有兴趣的话也欢迎贡献自己的力量。

[1] http://wiki.freeswitch.org/wiki/Freeswitch_Gui。

## 小结

本章列举了一些在实战过程中常用的基本技能、调试技巧和实用工具等。这些工具，讲起来都很简单，但在实际使用过程中，需要多多练习才能掌握其要领。熟练使用这些命令和工具，在以后的学习和工作中将能事半功倍。

限于篇幅，本章中提到的部分工具和软件我们没有深入讲解，但在关键的地方，笔者都给出了相关的链接或关键字，有兴趣的读者可以自行查阅相关资料，进行进一步的学习。

另外，本书前面的章节对于各种命令和使用场景都讲得比较详细（因而显得有点啰嗦）。从本章开始，我们就认为读者有一定的理论基础和实践经验了。因此，以后再讲解配置、命令或代码的时候，我们就要简明扼要一些了。