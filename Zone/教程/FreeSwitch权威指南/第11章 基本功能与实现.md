# 第01章 PSTN与VoIP基础
# 第02章 PSTN、PBX及呼叫中心业务
# 第03章 初识FreeSWITCH
# 第04章 运行FreeSWITCH
# 第05章 FreeSWITCH架构
# 第06章 拨号计划
# 第07章 SIP协议
# 第08章 媒体
# 第09章 SIP模块
# 第10章 基本技能
# 第11章 基本功能与实现

FreeSWITCH的功能非常丰富。本章我们带领大家通过一些实际的例子来学习FreeSWITCH的基本功能，并在实践中深入领会各种配置文件的意义。

## 批量创建用户

如何在FreeSWITCH中快速创建大量用户是在社区中经常遇到的一个问题。其实该问题解决起来并不难。我们已经了解现有的用户配置文件是存放在FreeSWITCH安装目录的conf/directory/default目录下，每个用户对应一个XML配置文件，如1000.xml包含了1000这个用户的配置文件。FreeSWITCH默认提供了1000～1019这20个用户，如果要手工创建另外一个用户，如1020，我们只需以1000.xml为模板，将该文件中的内容复制到1020.xml，然后把1020.xml文件中的所有出现1000的地方全部替换成1020即可（这也是我们在3.3节使用的方式）。

当然，除了手工的复制和替换外，上述步骤可以在UNIX系统上的Shell [1]中使用下列命令完成：

```
# sed -e "s/1000/1020/" 1000.xml > 1020.xml
```

其中sed是UNIX系统上经典的流文件编辑器，上面我们使用sed的“s”命令将1000.xml文件中所有出现1000的地方都替换成1020，然后将命令的输出重定向（大于号是Shell中的重定向操作符）到1020.xml文件中。

上述命令用于创建一个用户的情况，如果要创建一批用户怎么办呢？其实也很简单，我们只需要用一下Shell中的for循环就可以了。比如我们要创建1020～1039这20个用户，具体的Shell命令如下：

```
# for i in `seq 1020 1039`; do sed -e "s/1000/$i/" 1000.xml > $i.xml ; done
```

在上述命令中，首先，seq [2]命令会产生一个序列，两个参数分别是序列的起止点，如：

```
$ seq 1 3
```

```
1
2
3
```

有了这个序列以后，for循环就可以从该序列中依次取得每一个值，并将该值赋值给“i”这个变量。do和done之间是循环体，其中的内容就是我们前面的sed命令，只不过我们使用“$i”这个变量引用，它的值都是每次循环时从序列中取得的。注意其中的分号也是有用的，它用于在同一行上隔开多个命令。详细的Shell语法我们就不多讲了，总之用上述命令批量生成用户是很方便的。

另外，在Mac平台上，笔者发现竟然没有seq这个命令，只好自己用Ruby写了一个。下面的Ruby脚本与Linux上的seq功能相似，同样，详细原理我们就不多解释了。

```
#!/usr/bin/env ruby
(ARGV[0].to_i .. ARGV[1].to_i).each { |x| puts x}
```

当然，好多读者也在使用Windows平台。但很遗憾的是，Windows上的Shell功能比较弱，也没有像sed之类的工具，因此做起来不如在UNIX上方便。不过，也有人把经典的UNIX工具软件都移植到了Windows上，称为UnxUtils [3]。安装完UnxUtils后，就可以使用大部分的UNIX命令了。如我们可以使用如下“.bat”脚本完成同样的添加用户的功能（将下列内容存到与1000.xml相同的目录下的扩展名为“.bat”的文件中，用鼠标双击即可执行）：

```
for /L %%i in (1020, 1 1039) do sed -e "s/1000/%%i" 1000.xml > %%i.xml
```

除此之外，在FreeSWITCH源代码目录中的scripts/perl目录下也有一个add_user脚本，该脚本是用Perl写的，也能完成类似的功能，具体命令如下：

```
# ./add_user 1020
```

上述命令将会把用户配置文件安装在默认的安装路径下面（使用默认的Domain——default）。当然，也可以在命令行上改变Domain和安装路径，如下列命令可以将配置文件安装在/opt/freeswitch/conf目录中的directory/my_domain目录下：

```
# ./add_user 1020 --domain=my_domain --confpath=/opt/freeswitch/conf
```

也可以使用“--users”参数指定批量创建的用户的范围，如：

```
# ./add_user --users=1020-1039
```

总之，如果不确定上述脚本的使用方法，最好先试验一下。比如，我们先创建一个新的目录用于测试：

```
# mkdir -p /tmp/directory/my_domain
```

然后使用下列命令可以看出它确实能创建指定的配置文件：

```
# ./add_user 1111 --users=1020-1039 --domain=my_domain --confpath=/tmp

Added 1020 in file /tmp/directory/my_domain/1020.xml
Added 1021 in file /tmp/directory/my_domain/1021.xml
Added 1022 in file /tmp/directory/my_domain/1022.xml
Added ...
```

需要注意的是，add_user脚本创建的用户配置文件不是以1000.xml为模板的，而是内置在脚本中，因此，如果需要创建的用户与add_user脚本中的模板内容不同，需要事先更改脚本中的内容。

总之，不管使用什么方法，创建完用户配置文件后就可以在FreeSWITCH中使用reloadxml命令使之生效了。在配置生效后，使用这些用户进行注册和呼出操作都没有问题，如果这些用户也需要被叫，那就需要修改Dialplan，增加到这部分用户的路由。比如，我们增加了1020～1039这20个用户后，可以简单地将默认的Dialplan中的正则表达式“^(10[01][0-9])$”改为“^(10[0-3][0-9])$”，这样就可以包含我们新创建的用户了。更改后的部分内容如下：

```
<extension name="Local_Extension">
<condition field="destination_number" expression="^(10[0-3][0-9])$">
```

总之，讲起来可能比较啰嗦，但实际使用起来还是挺简单的，读者不妨自己练习一下。

[1] 这里我们假定使用Bourne Shell系列的Shell。UNIX历史上有多种Shell，最典型的是Bourne Shell和C Shell两大类，它们的语法稍有不同。目前使用比较多的都是Bourne Shell的变种，如Burne-Again Shell（即bash）、zsh等。 

[2] 注意，括在seq外面的不是单引号，而是重音符（“`”），即键盘上数字“1”左边那个按键。参见：http://zh.wikipedia.org/wiki/重音符。 

[3] 安装方法可以参考http://www.dujinfang.com/2010/05/27/zai-windows-shang-an-zhuang-unixutils.html。

## 用FreeSWITCH实现IVR

IVR（Interactive Voice Response，交互式语音响应）实际上就是我们经常说的电话语音菜单。在练习IVR的配置之前，我们先来一个感性的认识：FreeSWITCH默认的配置已包含了一个功能齐全的例子。随便拿起一个分机，拨5000，就可以听到菜单提示了。当然，默认的提示是英文的，大意是说欢迎来到FreeSWITCH，按1进入FreeSWITCH会议；按2进入回音（echo）程序（这时候可以听到自己的回音）；按3会听到等待音乐（Music on Hold，MOH）；按4转到FreeSWITCH开发者Brian West的SIP电话上；按5会听到一只猴子的尖叫；按6进入下级菜单；拨9重听；拨1000～1019之间的号码则会转到对应分机。

有条件的读者可以自行测试一下。有了这些直观的感受之后，我们就可以接着进行下面的配置练习了。

### 最简单的菜单

我们先来配置一种最简单的情形。一些廉价的小企业交换机通常会提供这样的功能，当有电话呼入时，会播放：“您好，欢迎致电某某公司，请直拨分机号，查号请拨0”。然后，来话用户就可以输入1000～1019之间的分机号，也可以直接按0转到人工台（如分机1000）进行查号，或要求转接其他分机。

IVR系统默认的配置文件为conf/autoload_configs/ivr.conf.xml，它装入conf/ivr_menus/目录下所有的XML文件。系统有一个示例的IVR配置，叫demo_ivr，也就是我们刚才拨5000听到的那个。

真正的菜单配置信息放到一对“<menus></menus>”标签中，每一对“<menu></menu>”标签就描述一个菜单。每个菜单应该有一个唯一的名字（name），以便在拨号计划（Dialplan）中引用（作为ivr App的参数）。在前面的章节中已经讲过，被装入的XML文件最外层一般都有一对“<include>”标签，以保证XML文档的完整性。为了实现目标菜单，我们创建一个XML配置文件conf/ivr_menus/welcome.xml，内容如下：

```xml
<include>
    <menus>
        <menu name="welcome"
            greet-long="welcome.wav"
            greet-short="welcom_short.wav"
            invalid-sound="ivr/ivr-that_was_an_invalid_entry.wav"
            exit-sound="voicemail/vm-goodbye.wav"
            timeout="15000"
            max-failures="3"
            max-timeouts="3"
            inter-digit-timeout="2000"
            digit-len="4">
            <entry action="menu-exec-app" digits="0" param="transfer 1000 XML default"/>
            <entry action="menu-exec-app" digits="/^(10[01][0-9])$/"
                   param="transfer $1 XML default"/>
        </menu>
    </menus>
</include>
```

在上述配置中，首先，我们指定菜单的名字（name）是welcome，其他各项的含义如下：

- greet-long：指定最开始的欢迎音，即最开始播放的“您好，欢迎致电某某公司，请直拨分机号，查号请拨0”的语音，该语音文件默认的位置应该是在/usr/local/freeswitch/sounds目录下。应该事先把声音文件录好（可以使用Windows系统自带的“录音机”或其他录音软件实现，后面我们还会讲到其他录音的方法），在本例子中，我们都使用相对路径，当然也可以使用绝对路径，如/root/ivr/welcome.wav）。另外，PSTN交换机都是使用PCM编码的，如果与PSTN对接的话，将声音文件存储为单声道、8000Hz的格式，能获得较好的音质并占用较少的系统资源。当然，对于其他采样率的声音文件，FreeSWITCH也能自动转换，只是在Log中会有相关的采样率不匹配的警告，初学者可以暂时不必理会。
- greet-short：该项指定一个简短的提示音。如果用户长时间没有按键，则应重新提示拨号，但重新提示应该简短，比如直接说“请直拨分机号，查号请拨0”，而不用再把公司的欢迎广告再重复播放一遍。所以，可以把这么一个声音文件录制到welcome_short.wav中。
- invalid-sound：如果用户按错了键，则会使用该提示。如果使用“make sounds-install”命令安装了声音文件，则该文件应该是默认存在的。只是它是英文的，如果需要中文的提示，可以自己录一个，并修改这里的路径使其指向自己录制的声音文件。
- exit-sound：该项指定最后菜单退出时（一般是超时没有按键）的声音，默认会提示“Good Bye”。
- timeout：指定超时时间（毫秒），即多长时间没有收到按键就超时，播放其他提示音。
- max-failures：为容忍用户按键错误的次数。如果用户的按键与下面配置的正则表达式不匹配（即没有找到相关的菜单项），就认为是错误的。
- max-timeouts：即最大超时次数。
- inter-digit-timeout：为两次按键的最大间隔（毫秒）。如用户拨分机号1001时，假设拨了10，等3秒，然后再按01，这时系统实际收到的号码为10（后面的01超时后没有收到），则会播放invalid-sound指定的声音文件以提示错误。
- digit-len：说明菜单项的长度，即最大收号位数。在本例中，用户分机号长度为4位，因此我们使用4。

该菜单中有两个菜单项（Entry），第一个是在用户按0（digits="0"）时，通过menu-exec-app执行一个App。在此处它执行transfer，将来话转到default Dialplan中进行路由，并会最终转到分机1000。

如果来电用户知道被叫的分机号，则可以直接拨分机号，而不用经过人工转接，以节约时间。在本例中，第二个菜单项中的digits正则表达式“/^(10[01][0-9])$/”会匹配用户输入的1000～1019之间的分机，也是转到default Dialplan中进行路由，并最终转到对应的分机上。

如果来电用户按其他按键，则由于找不到匹配的菜单项进而提示错误（invalid-sound指定的声音），并提示用户重新输入。

以上菜单设定好后，需要在控制台中执行reloadxml（或按F6键）使配置生效。

配置完成后就可以在控制台上进行如下测试（呼叫1001，接听后进入ivr菜单）：

```
freeswitch> originate user/1001 &ivr(welcome)
```

测试成功后，就可以配置Dialplan把用户来话转接到菜单，在Dialplan中加入一个extension（注意，需要加到正确的Dialplan Context中，如果不确定，则应该加到哪个Context中，在default和public中都加上会比较保险。实际上，如果这里出了问题，应该回去看第6章）：

```xml
<extension name="incoming_call">
    <condition field="destination_number" expression="^1234$">
        <action application="answer" data=""/>
        <action application="sleep" data="1000"/>
        <action application="ivr" data="welcome"/>
    </condition>
</extension>
```

其中，正则表达式“^1234$”匹配1234，即如果用户拨打1234时，就会在Dialplan中路由到这里。其中有三个action，分别指定接下来要执行的动作。首先，执行answer对来话进行应答（必须先应答才能向对方播放声音）；然后使用sleep暂停一秒，以防止由于声音通路没建立好（有时候，特别是当主叫与被叫之间的链路比较复杂时，声音链路的建立需要一个过程）而丢失声音；最后，执行ivr，它的参数就是我们刚刚建立的菜单项的名字welcome。

接下来呼叫1234进行测试，就可以听到我们刚才配置的IVR菜单了。注意，在实际应用中，为了能接受外部来的呼叫，可能要把这里的1234改成实际的DID（Direct Inbound Dial）号码。

### 默认IVR简介

明白了以上简单的IVR配置方法，就很容易理解更复杂一点的配置了。上面我们提到，系统默认提供了一个名叫demo_ivr的菜单。最初的语音提示（greet-long及greet-short）是用Phrase实现的。Phrase是用XML定义的一些短语，虽然最终也是播放相关的声音文件，但在多语言系统中会更灵活。在此我们先不讨论Phrase，可以简单地认为它就是一个声音文件。其他各属性的含义都很直观，我们也不多介绍了。这里我们重点来看一下各菜单项。这些菜单项的配置如下：

```xml
<entry action="menu-exec-app" digits="1"param="bridge sofia/$${domain}/888@conference.freeswitch.org"/>
<entry action="menu-exec-app" digits="2" param="transfer 9196 XML default"/>
<entry action="menu-exec-app" digits="3" param="transfer 9664 XML default"/>
<entry action="menu-exec-app" digits="4" param="transfer 9191 XML default"/>
<entry action="menu-exec-app" digits="5" param="transfer 1234*256 enum"/>
<entry action="menu-sub" digits="6" param="demo_ivr_submenu"/>
```

可以看出，菜单选项大多都是根据用户按键使用menu-exec-app执行相应的App。其中，如果按1，则会执行bridge，连接到FreeSWITCH官方的电话会议平台；如果按2，则执行transfer，转移到XML Dialplan的default Context中的9196这个extension进行处理（对于9196我们已经很熟悉了，它最终会执行echo）；如果按3，则会转到9664（保持音乐）；按4转到9191（ClueCon）；按5转到enum Dialplan进行处理；按6则会使用menu-sub进入一个下级菜单。

menu-sub表示会执行一个下级菜单。其实下级菜单所有的配置项目与主菜单基本上都是一样的，不同的是，在下级菜单中（此处是demo_ivr_submenu），可以使用menu-top来返回上级菜单。默认的例子中下级菜单只包含一个到上级菜单的菜单项，它表示按“*”号键就可以返回主菜单。该菜单项的配置如下：

```xml
<entry action="menu-top" digits="*"/>
```

使用XML方式配置IVR菜单的知识基本上只有上面介绍的这么多了。不过，通过设置多级菜单，以及与Dialplan相配合，根据不同的情况进行跳转，可以实现一些相对复杂的功能。当然，如果这些还不够灵活和强大，我们后面也会讲到使用嵌入式脚本或Event Socket实现更灵活的菜单。

如果在试验过程中遇到非预期的情况，可以打开FreeSWITCH控制台，按F8键或使用“console loglevel debug”命令将日志调到DEBUG级别，在打电话时便能看到详细的执行过程。根据日志中的信息结合自己的使用经验就应该能比较容易定位到问题了。

## 按时间进行路由

有时候，在一些企业应用中，可能需要按时间段进行路由。例如，在上班时间路由到一个IVR，该IVR在报完欢迎语后，可以引导转到人工总机接电话；而在下班后，来电就转到另外一个IVR，工作全部由电脑自动处理。

我们可以构造如下Dialplan：

```xml
<extension name="time_based_ivr">
  <condition wday="2-6" hour="8:30-17:30">
    <action application="ivr" data="ivr_day"/>
    <anti-action application="ivr" data="ivr_night"/>
  </condition>
</extension>
```

其中，我们可以看到，这里的测试条件（Condition）与以前的不同。以前我们大部分以destination_number为测试条件，而在这里，我们有两个测试条件，一个是wday，一个是hour，这两个测试条件是逻辑“与”的关系。其中，wday表示星期（星期日的值为“0”），一般上班的时间都是周一至周五，因而这里wday的值用“2～6”表示；同时，这里的hour表示小时，即工作日的8:30至17:30为上班时间。

在有呼叫到达后，如果系统时间在该条件定义的范围内，则执行在后续的action中定义的App。这里，我们只有一个action，它只是使用ivr App将呼叫转入白天应该播放的IVR（即ivr_day）。如果定义的条件不在这个范围内，FreeSWITCH就会执行anti-action指定的App，它也是执行ivr，不过这次它的参数是另一个IVR——ivr_night。

当然，读到这里读者可能会有疑问，上面的例子没有测试被叫号码，会不会有什么副作用？这种担心不是多余的。这里由于没有限制被叫号码，相当于任何被叫号码都会转到IVR，而实际上，我们只希望有人打我们的DID号码时才转入IVR，所以我们的配置一般会比上面的更复杂一些。

首先，写一个extension，它会根据不同的时间执行不同的动作，如：

```xml
<extension name="time_based_ivr" continue="true">
  <condition wday="2-6" hour="8:30-17:30">
    <action application="set" data="ivr=ivr_day" inline="true"/>
    <anti-action application="set" data="ivr=ivr_night" inline="true/>
  </condition>
</extension>
```

与前面的extension不同的是，此处的extension中使用了“continue=true”属性。保证在Dialplan解析的时候解析完此处会继续往下进行。如果当前的时间可以匹配这里的测试条件（工作日上班时间），便会执行set，设置ivr变量的值为ivr_day；否则，则将ivr变量的值设为ivr_night。

`注意`

上面的action和anti-action都设置了inline属性，它的值为true表示该动作会立即生效，以便后续的Dialplan使用此处设置的ivr变量来进行条件判断。虽然后续我们并没有使用它来进行条件判断，但这里使用该参数仍然是一个好习惯。

总之，在路由阶段检查过这一段Dialplan后，变量ivr的值不是等于ivr_day就是等于ivr_night，具体如何取决于来电的时间。另外，由于该extension的定义中还有“continue=true”参数，因而，Dialplan的解析过程会继续往下执行。如果我们在它后面建立如下的Dialplan，它将通过被叫号码匹配到来话的DID，然后，执行answer进行应答，并执行ivr转到刚才我们设置的ivr变量指定的IVR。

```xml
<extension name="ivr">
  <condition field="destination_number" expression="^DID$">
    <action application="answer" data=""/>
    <action application="ivr" data="${ivr}"/>
  </condition>
</extension>
```

这样，其他的被叫号码可以忽略这里的时间检查及ivr变量照常进行路由，不受这里的时间条件的影响。

当然，要完成完整的例子还需要配置实现ivr_day和ivr_night两个不同的IVR，这部分内容我们在上一节刚刚讲过，读者可以自行练习。

## 配置中文语音提示

FreeSWITCH中默认的提示音都是英文的，有不少中文读者都觉得不方便。几年前，在中文社区网友link的帮助下，笔者制作了中文的语音包，虽然现在看来有些过时，但有总比没有好。这些语音包可以在下面的地址找到：http://wiki.freeswitch.org/wiki/Language_Files#Chinese。

FreeSWITCH对多语言的支持非常强大、灵活，下面我们先从最简单的方法学起。

### 最简单的实现方案

在FreeSWITCH中，默认的声音文件存放在FreeSWITCH安装目录的sounds目录下面，不同语种及嗓音的文件以不同的目录分类存放。在笔者的电脑上，用ls命令显示的目录结构如下：

```
dujinfang@seven:/usr/local/freeswitch/sounds/en/us/callie$ ls
ascii/      currency/   ivr/        time/
base256/    digits/     misc/       voicemail/
conference/ directory/  phonetic-ascii/ zrtp/
```

基中，en/us表示语种，即美国英语；callie是个人名，即这些录音是由callie录的。下面的子目录分别是声音文件的分类，如ascii代表ASCII字符、digits代表数字等。当然，使用tree命令可能看起来更直观一些（为了简单起见我们省略了大部分输出）：

```
dujinfang@seven:/usr/local/freeswitch/sounds/en/us/callie$ tree .
.
├── ascii
│   
└── 8000
│       
├── 100.wav
│       
├── 101.wav
│       
├── 102.wav
.       .
├── digits
│   
└── 8000
│       
├── 0.wav
│       
├── 1.wav
│       
├── 10.wav
│       
├── 2.wav
│       
├── 3.wav
```

可以看出，每个子目录中又都有8000这个子目录，它说明这些声音文件是以8000Hz的采样率存放的 [1]。该目录中最后存放了实际的声音文件（读者可以自己播放来听一下）。

当然，这些文件中的语音都是英文的。我们这里所说的最简单的支持中文的方案就是将这些文件直接用中文语音包中对应的文件替换。这种方法看起来比较“土”，但很有效。

### 使用sound_prefix

在FreeSWITCH的配置文件中，有一个sound_prefix变量用于定义声音文件的具体路径，它在vars.xml中是这样定义的：

```xml
<X-PRE-PROCESS cmd="set" data="sound_prefix=$${sounds_dir}/en/us/callie"/>
```

所以，改变该变量的值也能改变大部分声音文件的参考位置。例如，可以将其指向我们中文的语音文件路径：

```xml
<X-PRE-PROCESS cmd="set" data="sound_prefix=$${sounds_dir}/zh/cn/link"/>
```

当然，也可以在Dialplan中针对每一个Channel进行改变，如：

```xml
<action application="set" data="sound_prefix=$${sounds_dir}/zh/cn/link"/>
```

另外，该变量也可以设置到用户目录中，当特定的用户拨打电话时就能使用该变量。如，我们在1002.xml中可以加入以下设置：

```xml
<variable name="sound_prefix" value="$${sounds_dir}/zh/cn/link"/>
```

然后我们设置如下测试Dialplan：

```xml
<extension name="lang">
  <condition field="destination_number" expression="^1234$">
    <action application="answer"/>
    <action application="playback" data="digits/1.wav"/>
    <action application="playback" data="digits/2.wav"/>
    <action application="playback" data="digits/3.wav"/>
  </condition>
</extension>
```

当1002拨打1234时，便能听到“一二三”，但其他用户拨打时，仍会听到英文的“one two three”。

### 使用Phrase

当然，使用11.4.2节的方式更改的一般只是playback使用的声音文件的路径，而FreeSWITCH中大部分的语音提示，如IVR和Voicemail等，为了支持多语言，都是使用Phrase来实现的。接下来，我们就来看一下Phrase。

1. 认识Phrase

为了屏蔽各种不同语言提示的差异性，FreeSWITCH实现了Phrase（短语）框架。简单来说，通过使用它，可以将不同语言的日期、时间、货币及数字等以相同语法表示，并可以在必要时结合TTS实现更强大的语音提示。

在默认的IVR配置中，就使用了Phrase。如在ivr_menus/demo_ivr.xml中，greet-long的配置如下：

```
greet-long="phrase:demo_ivr_main_menu"
```

该Phrase是在conf/lang/en/demo/demo_ivr.xml中定义的一个宏，该宏定义的前几行代码如下：

```xml
<macro name="demo_ivr_main_menu" pause="100">
    <input pattern="(.*)">
        <match>
        <action function="play-file" data="ivr/ivr-welcome_to_freeswitch.wav"/>
        <action function="play-file" data="ivr/ivr-this_ivr_will_let_you_test_features.wav"/>
        <action function="play-file" data="ivr/ivr-you_may_exit_by_hanging_up.wav"/>
```

其中，name属性定义了该宏的名称，以便在其他地方引用；pause表示在每个action（下面讲到）之间暂停多长时间（毫秒），它匹配（match）指定的模式（pattern）后（我们这里不讨论match和pattern），便执行下面的动作（action）。本例中的动作都是一系列的play-file，即播放后面的data指定的声音文件。

这些声音文件的具体路径是在conf/lang/en/en.xml中定义的，实际上，demo_ivr.xml也是由该文件使用INCLUDE装入的。en.xml的部分内容如下：

```xml
<language name="en" say-module="en"
    sound-prefix="$${sounds_dir}/en/us/callie"
    tts-engine="cepstral" tts-voice="callie">
    <phrases>
        <macros>
            <X-PRE-PROCESS cmd="include" data="demo/*.xml"/>
```

可以看出，en.xml定义了一种语言（language），该语言的名字（name）为en；该语言是由say-module指定的en模块（在mod_say_en模块中实现）支持的；所有支持它的声音文件路径都由sound-prefix指定；如果用到TTS，后面还有tts-engine和tts-voice参数（我们将在11.7节研究TTS）。

然后，在该语言中，定义了一些phrase标签，在phrase中又定义了一些宏（macros），具体的宏都是由后续的XML配置文件定义的，如上面的IVR中使用的宏就是在demo_ivr.xml中定义的。

更多关于Phrase的知识我们就不多介绍了，有兴趣的读者不妨拨打9386试一下。在FreeSWITCH默认的配置中拨打9386将播放一些有趣的声音，这些声音的定义都是在funny_prompts这个Phrase中实现的，读者可以通过这里所学的知识及跟踪FreeSWITCH的日志看是否能找到它们。另外，我们将在11.8.3节再讲一个实际的Phrase Macro的例子。读者也可以参考http://wiki.freeswitch.org/wiki/Speech_Phrase_Management进行更深入的学习。

下面我们以增加中文支持为例来看一下如何修改这些配置文件。

2. 中文Phrase配置

FreeSWITCH默认没有中文的语音文件配置，因此我们需要自己添加。中文与英文的配置大同小异，在此我们将英文的复制一份，并在它的基础上进行修改。

使用如下命令复制整个目录到zh（其中每行的第一个#号为系统提示符，第二个#为笔者加的注释）：

```
# cd conf/lang      #进入lang目录
# cp -R en zh       # 从en目录复制产生zh目录
# cd zh             # 进入zh目录
# mv en.xml zh.xml  # 将en.xml改为zh.xml
```

至此，中文配置文件的基本框架已经完成了，下面修改zh.xml，将其中的name和say-module都修改为zh，并把sound-prefix修改为中文录音文件的路径，修改后的结果如下：

```xml
<language name="zh" say-module="zh"
    sound-prefix="$${sounds_dir}/zh/cn/link"
    tts-engine="mod_tts_commandline" tts-voice="Ting-Ting">
```

关于tts-engine和tts-voice两个参数我们先设置到这里，等后面讲到TTS的时候（见11.7节）再详细讲解。

改好这些配置框架以后，就可以告诉FreeSWITCH将我们新建的中文配置文件包括进来了。在conf/freeswitch.xml中，可以看到如下的行：

```
<X-PRE-PROCESS cmd="include" data="lang/en/*.xml"/>
```

上面是装入英文配置文件的配置，我们只需要在该行后面加入如下的行让它也装入中文的配置：

```
<X-PRE-PROCESS cmd="include" data="lang/zh/*.xml"/>
```

重启FreeSWITCH，中文语言的配置就基本准备好了。

3. “说”中文

另外，FreeSWITCH中的Say接口（Interface）可以通过一些预先录制的声音文件“说”出一些常用的词语组合，如日期、时间、货币、数字等。它相当于一种限制级的TTS实现（之所以说是限制级，就是因为它虽然非常灵活，但只能读特定范围内的词）。

Say接口支持各种语言，如果需要支持中文语言，就需要mod_say_zh模块。该模块默认是不被编译也不被加载的，因此我们需要先编译它。到FreeSWITCH的源代码目录中，执行如下命令即可编译安装：

```
make mod_say_zh-install
```

然后在FreeSWITCH控制台上加载该模块：

```
freeswitch> load mod_say_zh
```

为了让FreeSWITCH在启动时能自动加载该模块，需要在conf/autoload_configs/modules中将下列行的注释去掉，以让FreeSWITCH自动加载该模块。去掉注释后的结果为：

```
<load module="mod_say_zh"/>
```

关于Say的例子我们将在后面讲到，暂时先把它准备好，后面的例子会用到。

### 使用中文语音提示

中文支持准备就绪后，为了能播放中文提示，还需要在Dialplan中指定language或（和）default_language通道变量 [2]。比如，我们修改默认的5000对应的Dialplan，加入以下配置：

```xml
<action application="set" data="language=zh"/>
```

完整的Dialplan如下：

```xml
<extension name="ivr_demo">
    <condition field="destination_number" expression="^5000$">
        <action application="set" data="language=zh"/>
        <action application="answer"/>
        <action application="sleep" data="2000"/>
        <action application="ivr" data="demo_ivr"/>
    </condition>
</extension>
```

另外，该变量也可以加到用户目录中。比如，我们可以在1002的用户配置文件1002.xml的variables标签中添加如下配置，让该语言仅对1002用户生效：

```xml
<variable name="language" value="zh"/>
<variable name="default_language" value="zh"/>
```

也可以将上述配置添加到conf/directory/default.xml中（也就是添加到variables标签中），以使该配置对本域中的所有用户都生效。

总之，不管使用哪种配置，拿起对应的分机拨打5000，就应该能听到中文的语音提示了。

此话题我们就先讲到这里，有条件的读者不妨也试着同步配置一下。在本章后面的部分，我们将看到更多使用中文的语音提示的实例。

[1] 回顾一下3.2.1节中的Linux部分，上面的声音文件是我们使用“make sounds-install”命令安装的。FreeSWITCH中支持多种频率的声音文件，如果在安装时选择了更高频率的声音文件（如使用了“make hd-sounds-install”等），则可能有16000、32000之类的目录。在使用时，FreeSWITCH可以根据当前Channel的语音编码的采样率自动选择适合的声音文件。 

[2] 关于language和default_language，有的情况需要前者，有的情况需要后者，所以，为了保险起见，我们最好两者都配置。

## 录音

在实际使用过程中，经常需要对通话进行录音。FreeSWITCH支持多种录音方式，也支持多种格式的录音文件。在此，我们逐一尝试一下。

### 单腿录音

如在上一节提到的，在创建IVR或比较复杂的呼叫流程时，我们经常需要一些录音文件，除了使用Windows录音机或其他软件外，我们还可以直接通过FreeSWITCH来实现。

笔者经常使用以下命令录音，这种方法非常快速和方便：

```
originate user/1000 &record(/tmp/welcome.wav)
```

上述命令大家已经很熟悉了，我们呼叫1000，1000接听后即可以直接讲话并录音。由于这种录音方式仅涉及一条腿（leg，即一个Channel），因而称为单腿录音。

另外，我们也可以在Dialplan中录音（与上述命令是等价的）：

```xml
<extension name="record">
    <condition field="destination_number" expression="^rec(.*)$">
        <action application="answer"/>
        <action application="playback" data="tone_stream://%(100,1000,800)"/>
        <action application="record" data="/tmp/$1.wav"/>
    </condition>
</extension>
```

通过设置上述Dialplan，呼叫一个rec开头的号码，如recwelcome，就可以开始录音并将录音文件保存到/tmp/welcome.wav中，同样也可以通过拨打其他的号码录不同名称的声音文件。另外，为了在录音前给个提示，可以在record前先用playback播放一段提示音，如“请在嘀声后开始录音”。在本例中，我们仅用playback播放了一个“嘀”声，该声音是用tone_stream产生的。我们后面还会讲到tone_stream。

笔者使用的软电话可以呼叫含有字母的被叫号码。如果不支持呼叫含有字母的号码，也可以把这里的rec换成其他的数字，如123。然后，呼叫1231000就可以将录音存到/tmp/1000.wav。

在这种录音方式中，由于只有一个Channel，所以录音文件是单声道的。我们可以直接用下面的方式使用playback来测试播放刚才的录音：

```
freeswitch> originate user/1000 &playback(/tmp/welcome.wav)
```

上述命令呼叫1000，1000接听后就可以听到刚刚录制的声音了。

### 对两条腿的通话进行录音

一路正常的通话通常由两个Channel组成。而对于每个Channel我们都可以单独录音。在一个Channel中，语音有两个方向。对于SIP客户端或话机而言，两个方向分别为“说”和“听”，而对于FreeSWITCH而言，则分别为“读”（read，r）和“写”（write，w）。

以下API命令可以对正在进行的通话录音（需要事先知道相关Channel的UUID）：

```
uuid_record <channel_uuid> start /tmp/record.wav
```

如果决定不录音了，则可以使用以下命令停止录音：

```
uuid_record <channeL_uuid> stop /tmp/record.wav
```

该录音文件会包含两个声道，以后要使用playback播放这种录音时，会在日志中看到如下的警告信息：

```
freeswitch> originate user/1000 &playback(/tmp/record.wav)
[WARNING] switch_core_file.c:229 File has 2 channels, muxing to mono will occur.
```

这条信息表示，该文件有两个声道，但playback仅是对一个Channel而言的，它仅支持一个声道。因而，FreeSWITCH会先将两个声道混音，变成一个声道后再播放。该警告一般是无害的。只是，由于在播放时会进行混音，会多占用一些CPU，因而在高并发的场合，可以使用一些工具事先将声音文件混为一个声道。如我们可以使用sox命令行进行混音：

```
$ sox record.wav -c 1 record-1.wav
```

其中，“-c”指定Channel的数量。我们这里用的是“-c 1”，就是说将原来的声音文件混成一个声道。可以使用以下ls命令，从中看到混音后的声音文件大小比原来的大约小了一半（从136364到了68204）：

```
$ ls -l /tmp/record*.wav
-rw-r--r--  1 dujinfang  wheel  136364 Sep 23 15:21 record.wav
-rw-r--r--  1 dujinfang  wheel   68204 Sep 23 15:45 record-1.wav
```

另外，也可以使用sox附带的play命令在操作系统命令行上播放声音文件，并查看一些详细的信息，如（注意，该命令在声卡驱动不正常时是不能使用的）：

```
$ play /tmp/record.wav
/tmp/record.wav:
 File Size: 136k      Bit Rate: 256k
  Encoding: Signed PCM
  Channels: 2 @ 16-bit
Samplerate: 8000Hz
Replaygain: off
  Duration: 00:00:04.26
```

可以看到，上述输出中声音编码（Encoding）是有符号的（Signed）PCM数据；有两个16bit的声道（Channel）；采样率（Samplerate）是8000Hz，文件的长度是4.26秒。读者也可以对比一下它与上面单声道录音文件的区别。

实际上，录音使用的是FreeSWITCH中的Media Bug功能（即8.3.4节讲的“三通”），声音媒体数据通过一个“三通”流到录音文件中。FreeSWITCH支持同时创建多个Media Bug，因而可以同时录制多个声音文件，这在需要截取不同时间段的录音时非常有用，如可以在不同的时间点分别执行下列命令：

```
uuid_record <channel_uuid> start /tmp/1.wav
uuid_record <channel_uuid> start /tmp/2.wav
uuid_record <channel_uuid> start /tmp/3.wav
```

可以随时用对应的stop指令停止某个录音，也可以使用特殊的文件名“all”同时停止所有录音，如：

```
uuid_record <channel_uuid> stop all
```

当然，如果在录音过程中电话挂断了，所有录音也就自动停止了。

另外，在Dialplan中，也可以通过record_session达到类似的效果，如：

```xml
<extension name="record">
    <condition field="destination_number" expression="^(100[0-9])$">
        <action application="record_session" data="/tmp/record-$1.wav"/>
        <action application="bridge" data="user/$1"/>
    </condition>
</extension>
```

其中，在执行bridge前使用record_session开始对当前的Channel进行录音。与uuid_record不同的是，record_sesison是一个App，而前者是一个API。相同的是两者在执行时都会为当前的Channel添加一个Media Bug，因而可以实时录音。

另外，与record比起来，record_session是非阻塞的，它可以作用于单腿的呼叫也可以用于桥接（Bridge）的呼叫；而record是阻塞的，它会阻塞直到录音完成，即只能录单腿的呼叫。

### 立体声

通过使用相关参数，可以录制立体声，即可以将通话的两个人的声音分别存在两个声道里。该特性非常有用。笔者最早在做网络远程一对一教学时，就曾使用了该技术。通过将通话中的老师和学生的声音录在不同的声道里，可以在事后很方便地检查出他们对话的内容，并有针对性地提出建议以提高教学质量。另外，我们也可以很方便地将不同的声道分离到不同的声音文件中，进行更高级的自动声音识别和分析。

通过事先将RECORD_STEREO通道变量设置为true可以在录音时直接录成立体声。在Dialplan中使用record_session时的设置如下：

```xml
<action application="set" data="RECORD_STEREO=true"/>
<action application="record_session" data="/tmp/record-$1.wav"/>
```

当然，也可以在使用uuid_record录音前使用uuid_setvar设定该通道变量，从而录制成立体声的声音文件。这种方式与上述方式等价，具体命令如下：

```xml
freeswitch> uuid_setvar <channel_uuid> RECORD_STEREO true
freeswitch> uuid_record <channel_uuid> start /tmp/record.wav
```

### 录音相关的通道变量

除了上面讲到的RECORD_STEREO外，还有一些与录音相关的通道变量，下面简单介绍一下（注意这些变量是区分大小写的）：

- RECORD_HANGUP_ON_ERROR：默认值为false，如果设置为true则会在录音失败时（如文件不可写入、格式错误等）挂断电话。
- RECORD_WRITE_ONLY：只录“写”方向的录音。这里的方向是相对FreeSWITCH而言的，即FreeSWITCH发出，也就是对端能够听到的声音。
- RECORD_READ_ONLY：只录“读”方向的录音，即FreeSWITCH“听”到的录音。
- RECORD_STEREO：立体声录音。
- RECORD_STEREO_SWAP：同立体声录音，但将左、右声道互换。
- RECORD_ANSWER_REQ：默认值为false，如果设为true，则在应答前执行了record_session或uuid_record就暂时不录音，而等到通话被应答后才开始录音。可以防止录上不必要的Early Media（如回铃音或彩铃等）。
- RECORD_BRIDGE_REQ：与RECORD_ANSWER_REQ类似，只是在当前的通道与其他通道桥接了之后才开始录音。
- RECORD_APPEND：在默认情况下，如果指定的录音文件已经存在，再次录音就会覆盖该文件。将该选项设为true可以向已经存在的文件后面追加录音。可用于电话中断重新建立后重新录音时。
- record_sample_rate：可以在录音时指定采样率，以进行实时的转码。合法的采样率在源代码中使用switch_is_valid_rate(rate)宏定义，可能的取值有8000、12000、16000、24000、32000、11025、22050、44100、48000，单位为Hz。
- enable_file_write_buffering：该变量的默认值为true，即默认先写到一个内存缓冲区中，可以大大减小对存储设备（如硬盘）的访问次数，防止产生IO瓶颈。默认的缓冲区大小是65536字节。
- RECORD_MIN_SEC：最小录音秒数。如果录音时长小于该数（默认是3秒），则认为是无效的录音，并删除录音文件。
- RECORD_INITIAL_TIMEOUT_MS：如果从录音开始检测不到声音，则在指定的毫秒后超时，停止录音。
- RECORD_FINAL_TIMEOUT_MS：如果在录音过程中检测不到声音，则在指定的毫秒后超时，停止录音。
- RECORD_SILENCE_THRESHOLD：静音能量阈值，即能量小于该值认为是静音。默认值为200。
- 其他：还有一些变量可以设置声音文件的元信息，名字都很直观，在此就不多介绍了。这些变量有RECORD_TITLE、RECORD_COPYRIGHT、RECORD_SOFTWARE、RECORD_ARTIST、RECORD_COMMENT、RECORD_DATE等。

### 原生格式

为了最大限度地节省系统资源，可以将声音录制成原生（Native）格式 [1]。这种格式是由mod_native_file模块提供的。如果在录音时不提供录音文件的扩展名，就可以以原生的格式录音，例如，下列命令会将录音文件录成/tmp/test.PCMU（假设Channel使用的Codec是PCMU）：

```
freeswitch> originate user/1000 &record(/tmp/test)
```

对于一个两条腿的通话，也可以使用uuid_record进行原生方式的录音，如：

```
freeswitch> uuid_record b40dec66-2f47-480d-88bb-335a025d856e start /tmp/test
[INFO] mod_native_file.c:94 Opening File [/tmp/test-in.PCMU] 8000hz
[INFO] mod_native_file.c:94 Opening File [/tmp/test-out.PCMU] 8000hz
[DEBUG] switch_core_media_bug.c:532 Attaching BUG to sofia/internal/ 1001@123.130.116.42
```

从日志中可以看出，由于该通话有两条腿，而原生的格式不支持混音，因此只能将双向的声道录到两个不同的文件中，如上面的“-in”和“-out”分别代表“入”和“出”。

使用这种录音方式，一个最大的好处是可以直接支持G729编码。G729是受专利保护的编解码器，因而FreeSWITCH中不包含开源的编解码实现。通过使用原生格式录音，不需要进行编码和解码，因而就可以绕开这种限制。另外，使用这种方式也不用在FreeSWITCH中进行编解码处理，因而也会减少对系统CPU的使用。

如果Channel使用G729编码，则原生格式的录音文件扩展名将是.G729。这种格式的文件可以再使用其他的G729工具进行处理，我们就不多介绍了。在本节结束之前，我们再来讲一下PCM格式的文件的处理。

PCM格式的原生文件可以使用sox软件中的play命令播放，如：

```
play -e u-law -r 8000 -t raw test-in.PCMU
```

注意，由于原生格式的录音文件中不包含录音数据的元信息（即编码、采样率、声道等参数），因而需要在播放时指定。在上述命令中，“-e”指定了编码为“u-law”，即μ律；“-r”参数指定采样率为8000Hz；-t raw说明以原生格式播放。

当然，也可以使用如下的sox命令将该原生格式的文件转换成WAV文件：

```
sox -e u-law -r 8000 -t raw test-in.PCMU test-in.wav
sox -e u-law -r 8000 -t raw test-out.PCMU test-out.wav
```

也可以进一步将上述两路文件合成一个文件。下列两条命令都可以将两个声音文件合成到一个中去，其中前者将进行混音，而后者将合成立体声的。

```
sox test-in.wav test-out.wav -m test.wav
sox test-in.wav test-out.wav -M test.wav
```

更多的使用方法请参阅有关资料。

[1] 即直接使用音频媒体数据的原始格式（如PCMU、G729等），而不需要转换成其他编码。

## 放音

上一节我们讲了各种录音方式的参数。实际上，放音也有好多门道。接下来我们来详细看一下。

### playback的参数

我们先回顾一下，在前面的章节中，我们一直使用playback作为放音的例子。下列Dialplan设置可以播放声音文件/tmp/test.wav：

```xml
<action application="playback" data="/tmp/test.wav"/>
```

其中，/tmp/test.wav是一个文件名作为playback的参数。实际上，playback的参数范围比这个广得多，最典型的，playback的参数是一些“音频源”（以后，也可能有视频源），这些音频源大部分是由Format定义的，即我们在5.1.2节讲到的格式、文件接口（Format，File Interface）。这些文件接口一般会有打开（Open）和关闭（Close）、读（Read）和写（Write）等属性。其中，playback会从文件中“读”，而上面讲到的录音（record），实际上也使用这些文件接口，它会往文件中“写”。

这些文件接口有以下几类。

1. 声音文件

对大部分声音文件的支持都是在mod_sndfile模块中实现的。该模块直接调用了libsndfile库，因而libsndfile库所支持的文件FreeSWITCH都能支持，典型的如WAV、AU、AIFF、VOX等。

```xml
<action application="playback" data="/tmp/test.wav"/>
<action application="playback" data="/tmp/test.au"/>
<action application="playback" data="/tmp/test.aiff"/>
```

libsndfile不支持的声音文件则由其他模块实现的。如mod_shout模块实现了对MP3文件的支持。该模块默认是不编译的，可以在源代码目录中使用如下命令编译安装：

```
# make mod_shout-install
```

然后，在FreesSWITCH中使用下列命令加载该模块：

```
freeswitch> load mod_shout
```

然后就可以播放MP3文件了：

```xml
<action application="playback" data="/tmp/test.mp3"/>
```

当然，该模块也支持播放远程SHOUTcast服务器上的MP3文件，如：

```xml
<action application="playback" data="shout://shoutcase-server/test.wav"/>
```

另外，Playback也可以直接播放由mod_native_file模块（C参见11.5.5节）支持的原生文件——只要在播放时不带扩展名。FreeSWITCH会自己查找与本Channel语音编码一致的文件。在以下设置中，如果Channel使用PCMU编码，则播放test.PCMU，如果Channel使用G729编码，则会播放test.G729：

```xml
<action application="playback" data="/tmp/test"/>
```

在FreeSWITCH控制台上使用“show file”命令可以列出哪些模块都实现了哪些文件类型的支持，读者可以自己试验一下，在这里就不多讲了。

2. local_stream

local_stream是在mod_local_stream [1]中实现的。该模块实现了一些Stream，即“流”。它与文件类似，不同的是，每个流在整个系统中只有一个实例，但可以同时被多个Channel读取。这样，当系统中有成千上万个Channel时，便能节省很多系统资源。由于流的这个特性，使得它非常适合做保持音乐（Music on Hold，MOH）。

比如，我们熟悉的FreeSWITCH默认设置中的9664号码就是用下列配置播放了一个流：

```xml
<action application="playback" data="local_stram://moh"/>
```

上述代码中的流的名字是“local_stream://moh”，它是在conf/autoload_configs/local_stream.conf.xml中定义的。我们可以在配置文件中找到如下的配置：

```xml
<directory name="moh/8000" path="$${sounds_dir}/music/8000">
    <param name="rate" value="8000"/>
    <param name="shuffle" value="true"/>
    <param name="channels" value="1"/>
    <param name="interval" value="20"/>
    <param name="timer-name" value="soft"/>
</directory>
```

可以看出，上述代码中的流的名字是moh/8000，FreeSWITCH支持多种采样频率，如果当前Channel为8000Hz，名字为local_stream://moh便可以自动对应到moh/8000这个流。同理，如果是16000Hz的Channel，就会找到moh/16000定义的流。

其后面的path定义了该流所需的声音文件的路径，它指定一个目录，在mod_local_stream模块加载时会预先加载所有声音文件。有时候，如果在最初安装FreeSWITCH时忘了安装声音文件，该流便不能生效，在使用时会遇到类似如下的错误：

```
[WARNING] mod_local_stream.c:469 Unknown source moh, trying 'default'
[ERR] mod_local_stream.c:478 Unknown source default
```

在FreeSWITCH中使用流时，如果找不到指定的流，则会尝试使用default流代替；如果default流也不存在，则会显示“Unknown source default”错误，即在前面看到的出错信息。

出现上述错误一般是在安装FreeSWITCH时忘了安装相关的声音文件，可以尝试到源代码目录中执行如下命令以安装默认的声音文件：

```
# make moh-install
```

然后，到FreeSWITCH控制台上执行下列命令重新加载模块使之生效：

```
freeswitch> reload mod_local_stream
```

3. silence_stream

silence_stream是一个静音流，它是在mod_tone_stream中实现的。使用方法如下：

```xml
<action application="playback" data="silence_stream://2000"/>
```

其中，2000是指定播放的时间，单位是毫秒，即上述配置会播放2秒的静音。

在Dialplan中，有一个sleep App在某种程度上可以达到与playback同样的效果。如下列命令会使当前Channel的执行暂停2秒，表现在对端就是2秒内听不到任何声音：

```xml
<action application="sleep" data="2"/>
```

但两者还是有区别的。slience_stream会播放静音，也就是说，仍然会有RTP数据发送，只是RTP中携带的声音数据中音量全部为0；而sleep会中断RTP流的传输。有时候，中断RTP流的传输后可能会造成对方功能失常，在这种情况下，就可以播放slience_stream以代替sleep。

如果在silence_stream中指定时长为0，则默认为无限长，如下列配置会一直播放静音：

```xml
<action application="playback" data="silence_stream://0"/>
```

使用上面介绍的silence_stream播放的静音称为绝对静音，因为它产生的静音音量绝对为0。但有时候，在电话中听起来，绝对静音与电话断了没什么区别，因而电话的另一端的人有时会误以为电话断了，进而可能会错误地挂断电话。为避免这种情况，最好能像普通电话一样能产生轻微的“嘶嘶”声，这样对方就知道电话还是通的。这种“嘶嘶”声音量不大，恰好能被听到，又不招人讨厌，一般被称为“舒适噪声”（Comfortable Noice，CN）。

可以在silence_stream中使用逗号加上第二个参数让它产生舒适噪声，如下面的配置将产生时长为2秒的舒适噪声：

```xml
<action application="playback" data="silence_stream://2000,1400"/>
```

其中，1400为舒适噪声的参数值，该参数的取值范围是1～10000，值越小噪声的音量越大，通常使用的参数值为600～1400。在不同的场景下具体哪个值合适，读者可以自己试一下。另外，如果将该参数值设为“–1”，则它会产生绝对静音。

4. tone_stream

tone_stream是一个铃流，它是在mod_tone_stream [2]模块中实现的。它可以使用TGML语言生成各种信号音。如我国的回铃音信号为450Hz的信号音，通断时间为1秒通，4秒断。所以，可以用如下参数产生回铃音信号（其中，1000、4000单位均为毫秒）：

```xml
<action application="playback" data="tone_stream://%(1000,4000,450)"/>
```

美国的回铃音信号是440Hz和480Hz交替的，通断时间分别为2000毫秒和4000毫秒：

```xml
<action application="playback" data="tone_stream://%(2000,4000,440,480)"/>
```

而英国的回铃音更复杂一点，读者可以思考一下它的含义：

```xml
<action application="playback"data="tone_stream://%(400,200,400,450);%(400,2000,400,450)"/>
```

conf/vars.xml中还定义了一些其他国家的信号音。

除此之外，也可以在后面再附加别的参数，如loops=3表示循环产生3次信号音：

```xml
<action application="playback" data="tone_stream://%(1000,4000,450);loops=3"/>
```

如果loops=-1，则表示无限循环。更多的参数我们就不多介绍了，读者可以参考http://wiki.freeswitch.org/wiki/TGML进行进一步的学习。

5. file_string

file_string文件接口原先是在mod_file_string [3]模块中实现的，后来被合并到了mod_dptools中。它相当于一种更高级的文件格式。通过它，可以将多个文件串联起来，放到同一个playback命令中播放，如下列配置将会顺序播放三个文件：

```xml
<action application="playback"data="file_string:///tmp/file1.wav!/tmp/file2.wav!/tmp/file3.wav"/>
```

其中，“!”为多个文件之间的分隔符。如果文件名中含有该符号，也可以通过playback_delimiter通道变量来改变它的默认值。例如，在下列配置中将多个文件的分隔符变成“|”（注意，这时“!”就可以作为文件名的一部分，如file3!.wav）：

```xml
<action application="set" data="playback_delimiter=|"/>
<action application="playback"
    data="file_string:///tmp/file1.wav|/tmp/file2.wav|/tmp/file3!.wav"/>
```

另外，也可以指定多个文件间的播放时间间隔，例如下列设置将时间间隔设为500毫秒：

```xml
<action application="set" data="playback_sleep_val=500"/>
<action application="playback" data="file_string://file1.wav!file2.wav"/>
```

6. 其他接口与参数

mod_vlc模块实现了一个vlc的文件接口。VLC是一个跨平台的多媒体播放器，它能播放主流音、视频文件。而libvlc则是从VLC中独立出来的一个库，mod_vlc便使用了该库支持各种libvlc能支持的文件类型。如下列配置可以使用mod_vlc中的vlc文件接口播放一个本地文件：

```xml
<action application="playback" data="vlc:///tmp/test.mp3"/>
```

也可以播放视频文件中的音频部分：

```xml
<action application="playback" data="vlc:///tmp/test.mp4"/>
```

也可以播放远程HTTP服务器上的文件：

```xml
<action application="playback" data="vlc://http://192.168.0.2/test.mp3"/>
```

当然，另外有一个mod_httapi模块直接实现了一个HTTP接口（可能需要事先编译加载），与vlc接口不同的是，它可以将远程文件缓存到本地，使用方法如下：

```xml
<action application="playback" data="http://192.168.0.2/test.mp3"/>
```

除了各种文件接口外，在playback的参数中添加“say:”前缀也可以直接调用TTS功能（关于TTS的功能，我们在11.7节会讲到），如：

```xml
<action application="playback" data="say:tts_commandline:Ting-Ting:
欢迎使用Free-SWITCH"/>
```

或（下列配置与上一行是等价的）：

```xml
<action application="set" data="tts_engine=tts_commandline"/>
<action application="set" data="tts_voice=Ting-Ting"/>
<action application="playback" data="say:
欢迎阅读FreeSWITCH
权威指南"/>
```

当然，上述的playback与下面的speak也是等价的，如：

```xml
<action application="speak" data="tts_commandline|Ting-Ting|
欢迎阅读FreeSWITCH
权威指南"/>
```

另外，也可以在playback中使用“phrase:”前缀播放Phrase宏，如：

```xml
<action application="playback" data="phrase:demo_ivr_main_menu"/>
```

它等价于：

```xml
<action application="phrase" data="demo_ivr_main_menu"/>
```

那么，既然有等价的speak和phrase App，为什么要在playback中实现这种带前缀的格式呢？答案是：它有助于用在其他类似playback的地方，如它可以用于IVR的配置中，默认IVR的配置中的欢迎音就是用带有phrase:前缀的Phrase宏实现的。参考配置如下：

```
greet-long="phrase:demo_ivr_main_menu"
```

另外，这种格式也可以直接用于read或play_and_get_digits App中需要一个声音文件参数的地方，如：

```xml
<action application="set"  data="tts_engine=tts_commandline"/>
<action application="set"  data="tts_voice=Ting-Ting"/>
<action application="read" data="1 1 say:
请您选择提示语言，1
为普通话，2
为英语"/>
```

关于playback的参数的例子我们就讲到这里，读者可以自己多多练习，找到最适合自己的方法。

### 循环播放

有些文件接口类型本身就支持循环播放，如各种Stream的实现有的天生就是循环的，有的可以用参数控制实现循环。而对于单纯的声音文件，则一般无法实现循环，如果要多次播放，则可以多次调用playback，或使用file_string实现。

另外，系统也提供了endless_playback和loop_playback两个App用于多次播放某个文件。顾名思义，前者会无限循环地播放一个声音文件，后者会播放一个声音文件并重复播放指定的次数。比如，不断播放test.wav直至挂机的实现如下：

```xml
<action application="endless_playback" data="/tmp/test.wav"/>
```

循环播放test.wav文件3次后停止播放的命令如下：

```xml
<action application="loop_playback" data="+3 /tmp/test.wav"/>
```

### Say

除了playback外，FreeSWITCH中还有其他放音的方法。本节要讲的Say是一个接口（Interface），它通过定义一个统一的接口屏蔽了语言的多样性。Say也是一个App，它可以通过特定的语法，使用预先录好的声音读出日期、时间等，并通过Say接口支持多语言（语种）。我们先来看一个例子。下面的例子将不使用TTS，而直接使用系统预先录好的文件读出“One Two Three Four”（注意，这里我们选的是英语的发音）：

```xml
<action application="say" data="en number iterated 1234"/>
```

其中，参数en代表语种，这里是英语；number说明我们要播放的数据的类型，这里表示的是数字；iterated是指定播放的方式，这里说明读数字要逐个读出；最后的1234即实际要读的内容。

实际上，Say会根据一定的规则找到1.wav、2.wav、3.wav、4.wav并播放出来。

Say接口能读的数据类型如表11-1所示，但注意并不是所有语言都实现了所有类型的读法。

<center>表11-1　Say能读的数据类型</center>

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-711855.png)

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-727858.png)

在确定了数据类型后，具体的读法有以下三种（以数字27为例）：

- PRONOUNCED：按数字语音语出，如英文“Twenty seven”，中文“二十七”；
- ITERATED：逐个读出，如英文“Two,Seven”，中文“二、七”；
- COUNTED：以序数词方式读出，如英文“Twenty senventh”，中文“第二十七”。

了解了这些以后，我们来看下面几个例子：

```xml
<action application="say" data="en NUMBER ITERATED 1234"/>
<action application="say" data="en NUMBER PRONOUNCED 1234"/>
<action application="say" data="en CURRENCY PRONOUNCED 1234.56"/>
<action application="say" data="en CURRENT_DATE PRONOUNCED ${strepoch()}"/>
```

由于上面这一组使用的是英文，因此电话路由到这里后将依次读出：

- One two three four
- One thousand two hundred thirty-four
- One thousand two hundred thirty-four dollars and fifty-six cents
- October nine,two thousand thirteen

其中${strepoch()}将自动计算当前时间 [4]，所以这里最后一项日期读出的结果取决于当前的时间。

我们接着来看下一组：

```xml
<action application="say" data="zh NUMBER ITERATED 1234"/>
<action application="say" data="zh NUMBER PRONOUNCED 1234"/>
<action application="say" data="zh CURRENCY PRONOUNCED 1234.56"/>
<action application="say" data="zh CURRENT_DATE PRONOUNCED ${strepoch()}"/>
```

这一组使用中文，将依次读出：

- 一二三四
- 一千二百三十四
- 一千二百三十四元五十六分
- 二零一三年十月九日星期三

对比一下可以看出，中文与英文除了日期中多了个星期三外，还有一个很特别的地方，就是货币的读法是非常不符合中文的习惯。

就这个问题，笔者曾与原模块的作者交流过。他说如果改成我们的习惯以后，可能会破坏其他地区中文的朗读习惯。笔者想了想，他说的确实有道理。比方说，在美国的人，即使说中文，但他们指的货币也是美元，可能仍会按照美元的习惯读“五十六分”而不是读“五毛六”。

后来，笔者就又依照zh这个接口，增加了zh_CN接口，让它符合我们中国人的习惯。具体的实现代码及补丁我们后面会讲到。在这里，如果要实现配置和使用这个接口，只需要仿照我们在11.4.3节讲的将conf/lang/zh/zh.xml文件复制一份到conf/lang/zh/zh_CN.xml，并将文件中language标签的name属性改成“zh_CN”就可以了，如：

```
<language name="zh_CN" ...
```

然后，重新启动FreeSWITCH，下面的Say就可以说地道的中文了。如下面的配置读出的结果是“一千二百三十四元五角六分”。

```
<action application="say" data="zh_CN CURRENCY PRONOUNCED 1234.56"/>
```

当然，为了“好玩”，笔者还增加了“厘”的读音。如下面的配置将会读出“一千二百三十四元五角六分七厘八”：

```
<action application="say" data="zh_CN CURRENCY PRONOUNCED 1234.5678"/>
```

当然如果小数点后有更多的位数，也可以原样读出。不过好玩归好玩，它的“忍耐力”也是有限的，实际使用时应该事先将数字截取到合情合理的精度。

最后，我们再讲一个例子。有的读者可能想，能否让它将“1234.56”读成“一千二百三十四点五六元”呢？据笔者所知，目前现成实现是没有的，而且在NUMBER的读法中也没有读小数的功能。不过，我们可以变通一下，用下列配置结合playback达到我们的目的。这样做虽然不是很完美，但总算能达到我们要的效果。具体的原理读者可以自己思考一下，在此就不多讲了。

```xml
<action application="say" data="zh NUMBER PRONOUNCED 1234"/>
<action application="playback" data="digits/point.wav"/>
<action application="say" data="zh NUMBER ITERATED 56"/>
<action application="playback" data="currency/yuan.wav"/>
```

[1] 参见：http://wiki.freeswitch.org/wiki/Mod_local_stream。 

[2] 参见：http://wiki.freeswitch.org/wiki/Mod_tone_stream。 

[3] http://wiki.freeswitch.org/wiki/Mod_file_string。 

[4] strepoch是一个API命令，它会输出当前的UNIX时间戳，比如，作者写本节时该命令的输出结果是1381332083。

## TTS

TTS（Text To Speech）是将文本转换成语音的一项技术，因而又称为语音合成（Synthesis）。下面我们来看一下FreeSWITCH中TTS的用法。

### 使用mod_flite

mod_flite [1]是FreeSWITCH基于Flite [2]语音合成引擎的一个TTS模块。目前，该模块仅支持英文。不过，我们可以先拿它来做个实验，学习一下FreeSWITCH中TTS的用法。

首先，到FreeSWITCH源代码目录中使用下列命令编译安装TTS模块：

```
# make mod_flite-install
```

然后，到FreeSWITCH中加载TTS模块：

```
freeswitch> load mod_flite
```

加载TTS模块后，就可以使用speak App来调用它了。我们先来试一下以下命令：

```
originate user/1000 &speak('flite|kal|Hello, Welcome to FreeSWITCH')
```

上述命令呼叫1000，并执行speak。其中speak的参数是使用竖线隔开的。第一个参数flite表示TTS引擎的名字；第二个参数kal表示一种嗓音（Voice），一般是一个人名。mod_flite目前支持awb、kal、rms、slt四种嗓音。执行上述命令，在分机1000振铃并接听后，将可以听到“Hello,Welcome to FreeSWITCH”。

我们也可以做以下Dialplan进行上述测试：

```xml
<extension name="TTS">
    <condition field="destination_number" expression="^1234$">
        <action application="answer"/>
        <action application="speak" data="flite|rms|Hello, Welcome to FreeSWITCH"/>
    </condition>
</extension>
```

配置好上述Dialplan后，拨打1234，也能听到同样的声音。

除了在speak的参数中指定TTS引擎和嗓音参数外，也可以通过通道变量指定。如下列配置与上述Dialplan是等价的（我们在11.6.1节也讲过这种等待关系）：

```xml
<action application="set" data="tts_engine=flite"/>
<action application="set" data="tts_voice=kal"/>
<action application="speak" data="Hello, Welcome to FreeSWITCH"/>
```

### mod_tts_commandline

许多TTS软件都有命令行版本，可以使用命令行来执行TTS功能。mod_tts_commandline模块可以调用这些命令，生成一个声音文件，进而播放这个声音文件，从而达到利用其他TTS软件执行TTS功能的目的。

1. 使用Mac上的TTS功能

在笔者使用的Mac系统上，有一个内置的say命令可以播放TTS，如在命令行上执行如下命令便可以听到声音：

```
$ say Hello, Welcom to FreeSWITCH
```

下列命令可以将TTS语音合成的结果保存到声音文件（hello.aiff）中，以便后续可以用其他播放软件播放：

```
$ say -o /tmp/hello.aiff Hello, Welcom to FreeSWITCH
```

注意，这里的声音文件我们使用了AIFF格式，因为该命令不支持WAV格式的文件。我们可以使用sox软件包 [3]中的play命令来播放该文件，如：

```
$ play /tmp/hello.aiff
```

也可以使用sox将其转换为WAV格式，如：

```
$ sox /tmp/hello.aiff /tmp/hello.wav
```

使用系统提供的TTS引擎的好处就是它一般比较容易支持更多的语种，例如，我们可以在Mac上增加中文语音的支持。Mac系统默认不带中文的语音库，不过，可以自行安装。安装步骤是：打开“系统偏好”，依次选择“听写与语音”、“文本至语音”，在系统嗓音中选择自定义，就可以选择嗓音为“Ting-Ting”的声音了，如图11-1所示，选择完毕后它会自动安装。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-741856.png)

<center>图11-1　在Mac中安装中文TTS语音支持</center>

在安装完中文支持并将默认的嗓音选为“Ting-Ting”后，就可以使用下列命令让它说中文了：

```
$ say 
欢迎使用FreeSWITCH
```

当然，如果“Ting-Ting”不是默认的嗓音，也可以在say命令后使用“-v”指定使用的噪音，如：

```
$ say -v Ting-Ting 
欢迎使用FreeSWITCH
```

在准备好中文的TTS引擎后，我们下一步就编译安装mod_tts_commandline模块，进入FreeSWITCH的源代码目录，执行如下命令：

```
# make mod_tts_commandline-install
```

安装完毕后，我们修改tts_commandline模块的配置文件，将settings部分修改为如下形式：

```xml
<settings>
    <param name="command" value="say -v ${voice} -o ${file}.aiff ${text}; sox ${file}.aiff ${file}; rm -f ${file}.aiff"/>
</settings>
```

其中，FreeSWITCH在调用该模块时会自动设置这几个变量：voice为嗓音的名字；file为声音文件的名字；text为TTS文本；rate为Channel的采样率。我们通过FreeSWITCH传过来的参数生成一个命令（command），该命令实际上由3个以分号分开的命令组成。第1个命令调用操作系统提供的say，以便从FreeSWITCH传过来的文本（text）产生一个声音文件（$file）。需要指出，该模块默认的扩展名是.wav，而Mac上的Say并不支持.wav格式的声音文件，所以，我们先生成一个.aiff文件，然后在第2条命令中使用sox将该.aiff文件转换为.wav格式的文件，并在第3条命令中使用rm将原先的.aiff删除（FreeSWITCH在使用完毕后会自动删除.wav文件）。

然后到FreeSWITCH中加载该模块：

```
freeswitch> load mod_tts_commandline
```

接着，就可以用如下的Dialplan让FreeSWITCH说中文了（注意，为了支持中文，Dialplan的配置文件应该使用UTF-8编码）：

```xml
<extension name="TTS">
    <condition field="destination_number" expression="^1234$">
        <action application="answer"/>
        <action application="set" data="tts_engine=tts_commandline"/>
        <action application="set" data="tts_voice=Ting-Ting"/>
        <action application="speak" data="欢迎使用FreeSWITCH"/>
    </condition>
</extension>
```

2. 使用Windows平台上的TTS功能

在Windows平台上，也可以使用Microsoft提供的TTS API来使用TTS功能。

首先，建立以下VBS脚本，存放到一个目录下，如C:\src\say.vbs。该脚本的内容如下：

```
set spvoice = CreateObject("SAPI.SpVoice")
set spfilestream = CreateObject("SAPI.SpFileStream")
set args = Wscript.Arguments
wavfile = Replace(args(0), "/", "\")
text = args(1)
Wscript.echo wavfile
spfilestream.open wavfile, 3
set spvoice.AudioOutputStream = spfilestream
spvoice.Speak text
spfilestream.close
```

该脚本首先使用CreateObject创建一个SAPI的语音对象spvoice，然后创建一个文件对象spfilestream，该文件对象将打开一个声音文件准备写入，接下来把spvoice的音频输出（AudioOutputStream）指定为该文件对象，最后调用spvoice的Speak方法进行TTS转换，并把结果写入声音文件中。

我们可以先在命令行中进行实验，如：

```
C:\src> cscript say.vbs test.wav 
欢迎使用FreeSWITCH
```

上述命令将产生声音文件test.wav，我们可以双击该文件听一下内容是否正确。如果听不到中文，那么很可能是没有安装支持中文的语音包。可以选择“开始”菜单→“控制面板”→“语音”项核实一下。如果在弹出的窗口的“语音选择”栏中只有“Microsoft Sam”一项可供选择，那表示没有中文的语音支持，需要单独安装。笔者测试时使用的是Neospeech提供的语音库（见图11-2），另外，据说Microsoft Office中也有中文语音库的支持。如何在Windows上安装中文的语音支持超出了本书的范围，读者可以自行查阅相关资料。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-757856.png)

<center>图11-2　在Windows上选择一个中文语音</center>

如果一切正常，接下来就是配置conf\autoload_configs\tts_commandline.conf.xml文件了，将其中的command参数配置为如下形式：

```xml
<param name="command" value="cscript c:\src\say.vbs ${file} ${text}"/>
```

在Windows上，该模块默认也是不编译的，甚至没有一个VC的工程文件。如果要编译该模块，我们需要自己生成一个工程文件。在Windows上生成一个工程文件的步骤比在UNIX类平台上要复杂一些。但对于熟悉VC的人来说，生成一个工程文件应该不是很难。在此，我们还是找一个简单的方法。步骤如下：

1）找一个差不多的工程文件复制过来，然后稍做修改。笔者使用的是VS2010 Express版，因而将application\mod_fsv目录中的mod_fsv.2010.vcxproj工程文件复制到asr_tts\mod_tts_commandline目录中，并改名为mod_tts_commandline.2010.vcxproj。接着，用记事本或其他文本编辑器打开该文件，将所有的mod_fsv替换为mod_tts_commandline就完成了。

2）打开FreeSWITCH的Solution文件Freeswitch.2010.express.sln，如图11-3所示，右击“解决方案资源管理器”，在弹出的快捷菜单中选择“解决方案Freeswitch.2.10...”，依次选择“添加”→“现有项目”，在弹出的窗口中找到我们刚刚建立的mod_tts_commandline.2010.vcxproj，然后单击“确定”按钮就可以将该工程文件加入解决方案了。接着在“解决方案资源管理器”中找到“mod_tts_commandline”一项，右击，然后在弹出的快捷菜单中选择“生成（U）”命令编译该模块。

![](https://gitee.com/liuhuihe/Ehe/raw/master/images/FreeSwitch权威指南-20211225-182223-771856.png)

<center>图11-3　将mod_tts_commandline工程加入解决方案</center>

编译完毕后就可以在FreeSWITCH中加载该模块了。剩余的步骤与在Mac上的操作是类似的，读者可以自己练习一下。

3. 使用Linux上的TTS功能

在Linux上，也有支持中文的TTS实现，不过笔者没有详细测试过。当然，如果读者运行的FreeSWITCH具有Internet环境，也可以使用Google Translate提供的API自己写一个脚本来与mod_tts_commandline集成。这部分内容留给读者自行练习，在此就不多介绍了。我们将在11.7.4节介绍Google Translate。

### MRCP

MRCP（Media Resource Control Protocol） [4]是一个支持访问网络上的媒体资源的协议。它的典型应用就是TTS和ASR（自动语音识别）。MRCP协议有两个版本，其中，v1 [5]版使用RTSP协议进行媒体资源的协商，v2 [6]版则使用SIP协议（这是我们看到的SIP协议的另外一个用处）。UniMRCP [7]是MRCP协议的一个开源实现，它支持v1和v2两个版本。

mod_unimrcp [8]是在UniMRCP基础上在FreeSWITCH中实现的一个模块，它同时支持TTS和ASR。一般来说，主流的TTS和ASR产品都支持MRCP协议。这类产品专业性比较强，一般都是商业版的软件。在写作本书时，没有找到合适的商业软件作为例子，因而在此就不对具体模块的对接配置做过多介绍了。不过，我们将在17.8.2节讲一个使用MRCP进行语音识别的例子，感兴趣的读者也可以参考相关的配置（配置方法都是类似的）。

如果使用UniMRCP，在Dialplan中TTS引擎的写法是“unimrcp:”加上配置文件中配置项的名字，如：

```xml
<action application="set" data="tts_engine=unimrcp:tts_server1"/>
```

其他的语法都与我们前面讲的类似，在此就不再赘述了。

### Google Translate

Google提供了一些优秀的工具，Google Translate（即谷歌翻译）就是其中之一。笔者在研究过程中偶然发现Google Translate有一个很酷的TTS功能。

在浏览器中访问以下URL [9]就可以播放“Hello and welcome to FreeSWITCH”了：

http://translate.google.com/translate_tts?q=Hello+and+welcome+to+FreeSWITCH&tl=en

若要播放中文也很简单，只需要将en改成zh（代表中文），URL如下：

http://translate.google.com/translate_tts?q=欢迎使用FreeSWITCH&tl=zh

在上面的测试中，读的中文没问题，只是似乎把英文也按中文的习惯来读了，听起来很不习惯 [10]。我们后面再解决这个问题。

为了在FreeSWITCH中使用该功能，我们需要一个命令行版本的API。如下列命令可以使用Google Translate把文字变成MP3声音文件：

```
curl -A "Mozilla" -o google_tts.mp3 
"http://translate.google.com/translate_tts?tl=zh&ie=UTF8&q=%e6%ac%a2%e8%bf%8e%e4%bd%bf%e7%94%a8FreeSWITCH"
```

其中，我们使用了curl命令行工具，它是一个HTTP客户端。-A指定的是客户端使用的User Agent，Google好像不喜欢curl，因此这里我们使用Mozilla替代；-o指定的是输出的文件，这里输出到一个MP3文件；最后是要访问的URL，我们已经将中文用url_encode进行编码了（注意，与浏览器中的URL相比，本URL中多了个ie=UTF8参数，它指定输入文本的编码类型，这里我们使用UTF-8）。

以下的wget命令与上面的命令是等价的，读者可以自己对比相关参数的含义。

```
wget -A "Mozilla" -o google_tts.mp3 "http://translate.google.com/translate_tts?tl=zh&q=%e6%ac%a2%e8%bf%8e%e4%bd%bf%e7%94%a8FreeSWITCH&ie=UTF-8"
```

理论上，有了上述命令行以后，我们就可以编写一个脚本，用11.7节讲到的方法通过mod_tts_commandline来使用Google Translate的TTS功能了。当然，读者也可以自己试一下，我们在这里就不重复该方法了。下面，我们讲两种更简便的方法。

首先，加载mod_shout，以让FreeSWITCH支持MP3。然后，使用如下的Dialplan就可以了：

```xml
<extension name="Free_Google_Text_To_Speech">
    <condition field="destination_number" expression="^1234$">
        <action application="answer" data=""/>
        <action application="playback"
           data="shout://translate.google.com/translate_tts?&tl=zh&ie=UTF-8&q=
欢迎使用+FreeSWITCH"/>
    </condition>
</extension>
```

呼叫1234就应该可以听到测试的声音了。前面，我们在URL中没有使用“http://”，而是使用了“shout://”。shout代表SHOUTcast [11]协议，它是专门用于流媒体广播的，Google Translate和FreeSWITCH中的mod_shout就直接支持该协议，因此我们可以直接使用它，以获得最好的效果。

上面我们提到，Google Translate用中文方式读的英语不好听，这里我们要解决一下。目前看来，最简单也是最有效的办法就是将它拆成中文和英文分别读，具体如下：

```xml
<action application="playback"   data="shout://translate.google.com/translate_tts?&tl=zh&ie=UTF-8&q=欢迎使用"/>
<action application="playback"   data="shout://translate.google.com/translate_tts?&tl=en&q=FreeSWITCH"/>
```

当然，实际上shout也是FreeSWITCH实现的一个文件接口（File Interface）。除此之外，也可以使用mod_httapi提供的HTTP文件接口来解决上述问题，如（我们省略了较长的URL）：

```xml
<action application="playback" data="http://translate.google.com/translate_tts?...
```

或者试一下mod_vlc中提供的HTTP文件接口：

```xml
<action application="playback" data="vlc/http://translate.google.com/translate_tts?...
```

总之，不管以何种方式调用这些API，殊途同归，最后都使用这些API生成我们需要的声音文件（或数据），并播放出来。

### TTS小结

FreeSWITCH支持比较丰富的TTS功能，也能很容易地与大部分TTS产品进行集成，而且它使用起来也比录音文件灵活。那么，什么情况下该使用TTS，什么情况下使用录音呢？

坦白地说，这其实不是个技术问题，也没有标准答案，不过在两者之间进行选择时，我们可以考虑以下几个问题：

- 如果在开发或测试时，使用TTS会比较简单，因为文本内容也比录音文件直观。
- 即使再好的TTS产品，它的发音也像机器的发音，永远不如真人录音好听。
- 如果录音的人不懂得录音的技巧，录出来反而可能不专业，不好听。
- 如果语音提示需要经常改动，那最好用TTS，因为TTS改起来会比较方便。更重要的是，它能保持统一的嗓音；而使用真人录音，可能找不到原先录音的那个人了。
- TTS产品还是比较有技术含量的（如分词断句、多音字等），所以一般来说好的TTS产品都比较贵。

当然，具体问题具体分析。熟练掌握了这些知识，相信大家在真正使用时都能做出正确的选择。就笔者的经验来看，在系统上配置好TTS后，以后写IVR之类的应用程序就比较简单了。因为直接使用TTS，可以避免先录音，也不用确定录音文件名与实际内容的对应关系等，而且在IVR脚本或程序中直接嵌入文件内容，代码看起来也比文件名要直观得多，这样可以减少错误的发生。等到全部IVR应用都写好了以后，可以再选择是否使用商业的TTS软件（也许能增强朗读效果），或者找专业的人员录音实现。在本书后面的例子中，我们在需要声音文件的地方大部分都将使用TTS为例来进行讲解。

[1] 参见http://wiki.freeswitch.org/wiki/Mod_flite。 

[2] Flite是Festival-Lite的缩写。Festival是爱丁堡大学研究出的一款开源语音合成引擎，致力于支持多语言及多平台。而Flite相当于Festival的简易版，致力于运行在小的嵌入式系统上。详见http://www.festvox.org/flite/。 

[3] sox（Sound eXchange）是一个跨平台的音频处理工具。该命令不是内置的，需要单独安装。参见：http://en.wikipedia.org/wiki/SoX。 

[4] 参见http://en.wikipedia.org/wiki/Media_Resource_Control_Protocol。 

[5] 参见http://tools.ietf.org/html/rfc4463。 

[6] 参见http://tools.ietf.org/html/rfc6787。 

[7] 参见http://www.unimrcp.org/。 

[8] 参见http://wiki.freeswitch.org/wiki/Mod_unimrcp。 

[9] 其中的URL字符串都是经过url_encode编码的，不熟悉的读者可以参考一下http://zh.wikipedia.org/wiki/百分号编码。另外，这里有一个站长工具可以帮助进行这种编码或反编码（解码），参见http://tool.chinaz.com/Tools/URLEncode.aspx。 

[10] 或许这也是Google可爱的地方。如它把“FreeSWITCH”读成类似“埃弗啊夷塔八六埃四意吃”。当然，自己试一下就知道了。网上也有好多调侃（或者说调戏）Google Translate的段子。 

[11] SHOUTcast是一个流媒体的广播协议，参见http://en.wikipedia.org/wiki/SHOUTcast。

## 在呼叫失败的情况下向主叫用户播放语音提示

在传统的电话网络中，在呼叫失败的情况下交换机会给主叫用户一个有意义的语音提示，如“您拨打的电话正在通话中，请稍后再拨……”或“您拨打的电话暂时无法接通……”之类。在FreesSWITCH中也可以做到。

### 实现方法

若已经熟练掌握了前面的知识，则再来看具体的实现就觉得很简单了。在此我们在默认的配置上修改，以实现具体的功能。

在默认的配置中，对本地用户的路由都是在conf/dialplan/default.xml中的Local_Extension部分配置的。在呼叫失败时，会将电话转到voicemail（语音信箱），提示用户可留言。为了能给主叫用户一个语音提示，我们可以在电话进入语音信箱之前做点文章，让它播放一个语音提示（当然播放完毕后也可以不进入语音信箱而直接挂机）。

找到<extension name="Local_Extension">部分的最后几行：

```xml
<action application="bridge" data="user/${dialed_extension}@${domain_name}"/>
<action application="answer"/>
<action application="sleep" data="1000"/>
<action application="bridge" data="loopback/app=voicemail:default ${domain_name} ${dialed_extension}"/>
```

其中，第一个bridge用于呼叫被叫号码，如果呼叫失败，则Dialplan会继续往下执行，执行顺序是：

- 应答（answer）；
- “睡”一会（sleep，即暂停1秒钟，其中1000的单位是毫秒）；
- 进入语音信箱（voicemail）。

到这里，我们只需要在最后一个bridge之前加入下面一行：

```xml
<action application="playback" data="/tmp/${originate_disposition}.wav"/>
```

重新打电话试一下，如果被叫忙（或拒接），则originate_disposition变量的值就会是USER_BUSY（有的终端会返回CALL_REJECTED），而如果用户没注册就是USER_NOT_REGISTERED之类的。通过增加上面一行，笔者在拨打一个不存在的用户时，看到如下的日志：

```
EXECUTE sofia/internal/1002@192.168.7.5 playback(USER_NOT_REGISTERED.wav)
[ERR] mod_sndfile.c:202 Error Opening File [/tmp/USER_NOT_REGISTERED.wav][System error : No such file or directory.]
```

上面的日志提示找不到指定的文件。当然这个问题很好解决，我们录一个放上去就可以了，内容可以是“您拨打的电话暂时无法接通……”。当然，对于其他情况，如用户忙，我们也可以录一段提示并放到/tmp/USER_BUSY.wav文件中。

### 进阶

不过，呼叫失败的原因可能有很多，我们不可能录上所有的声音文件，此时有两种方法可以解决这个问题。

1）使用一个Lua（或其他语言）脚本。

我们可以不增加刚才playback一行的配置（即上一小节提到的在最后一个bridge之前加入的代码），而是增加如下的行：

```xml
<action appliction="lua" data="/tmp/xxx.lua"/>
```

在Lua脚本中可以取到originate_disposition变量，从而可以使用if...then...else之类的逻辑选择播放各种声音文件（即只针对有限几种常用的情况播放特定的声音，其他的一律播放同一个文件）。关于Lua开发的知识我们将在第16章讲到，在这里就不多讲了。

2）当然，如果不想使用Lua，也可以使用Dialplan配置做到。实际上，FreeSWITCH的Dialplan功能是非常强大的，你只需要使用如下配置将呼叫转到播放不同声音文件的Dialplan Extension：

```xml
<action application="transfer" data="play-cause-${originate_disposition}"/>
```

然后创建如下Dialplan Extension，以匹配上面转移的目的地：

```xml
<extension name="Local_Extension_play-cause">
    <condition field="destination_number" expression="^play-cause-USER_BUSY$">
        <action application="playback" data="/tmp/user-busy.wav"/>
    </condition>
</extension>
<extension name="Local_Extension_play-cause">
    <condition field="destination_number" expression="^play-cause-USER_NOT_REGISTERED$">
        <action application="playback" data="/tmp/user-not-registered.wav"/>
    </condition>
</extension>
<extension name="Local_Extension_play-cause">
    <condition field="destination_number" expression="^play-cause(.*)$">
        <action application="log" data="WARNING hangup cause: $1"/>
        <!-- 对于其他各种情况，播放该文件 -->
        <action application="playback" data="/tmp/sounds/unknown-error.wav"/>
    </condition>
</extension>
```

这里的Dialplan配置即根据转移的目的地参数的不同播放不同的声音文件。读者可根据前面的知识自行分析。

### 使用TTS

前面我们已经学会了强大的TTS功能，也讲到了TTS的各种好处，所以这里我们用TTS做语音提示。在此，我们使用前面讲过的Phrase Macro功能来实现各种提示音。

首先，我们在11.7.2节的基础上 [1]，在conf/lang/zh/demo目录下创建以下脚本，可以将文件命名为book-demo.xml，内容如下：

```xml
<include>
  <macro name="USER_BUSY">
    <input pattern="(.*)">
      <match>
        <action function="speak-text" data="分机 $1 正在通话，请稍后再拨"/>
      </match>
    </input>
  </macro>
  <macro name="USER_NOT_REGISTERED">
    <input pattern="(.*)">
      <match>
        <action function="speak-text" data="分机"/>
        <action function="say" data="$1" method="iterated" type="number"/>
        <action function="speak-text" data="暂时无法接通，请稍后再拨"/>
      </match>
    </input>
  </macro>
</include>
```

可以看出，我们上面配置了两个宏（Macro），第一个用于在用户忙的时候播放；第二个在用户未注册的时候播放。其中，name为Macro的名字，pattern会使用正则表达式匹配输入的参数（类似于Dialplan中的正则表达式）。在这里，我们会将被叫号码作为输入参数。也就是说，如果呼叫分机1009失败，就会播放“分机1009正在通话，请稍后再拨”。当然，我们在第二个Macro中使用了Say来播放被叫号码，只是为了演示另外一种实现方式。

配置好上述文件后，在FreeSWITCH控制台上执行reloadxml使之生效。然后，在Dialplan中，就可以将11.8.1节的playback的参数换写成以下这样：

```xml
<action application="playback" data="phrase:${originate_disposition}:$1"/>
```

其中，以“phrase:”开头的文件参数表示这里要播放一个Phrase Macro，冒号后面跟的是参数，即我们在Dialplan正则表达式匹配中获得的被叫号码。如果被叫是1009，并且在被叫忙的情况下，上述配置展开后最终的结果是这样的：

```xml
<action application="playback" data="phrase:USER_BUSY:1009"/>
```

当然，也可以在Dialplan中直接使用phrase App，下面的代码与上述配置是等价的（不同的是，这里参数的分隔符是逗号）：

```xml
<action application="phrase" data="${originate_disposition},$1"/>
```

执行reloadxml后，再次拨打一个失败的电话试一下，就可以听到用TTS功能播放的提示音了。

当然，有了Phrase Macro，我们的配置方式就更灵活了，如我们可以只用一个Phrase Macro来搞定所有的情况。先配置如下Dialplan：

```xml
<action application="phrase" data="HangupCause,${originate_disposition}"/>
```

为了配合上述Dialplan，我们需要在Phrase Macro中配置一个名为HangupCause的Macro，并将originate_disposition作为参数传入。然后我们再来配置该Macro，同一个Macro中配置多个input可以针对不同的参数输入执行不同的动作（action），具体如下：

```xml
<macro name="HangupCause">
    <input pattern="USER_BUSY">
        <match>
            <action function="speak-text" data="您拨的电话正在通话，请稍后再拨"/>
        </match>
    </input>
    <input pattern="USER_NOT_REGISTERED">
        <match>
            <action function="speak-text" data="您拨的电话不在线，请稍后再拨"/>
        </match>
    </input>
    <input pattern="(.*)">
        <match>
            <action function="speak-text" data="您拨的电话暂时无法接通，请稍后再拨"/>
        </match>
    </input>
</macro>
```

可以看出，该Phrase Macro对前两种情况播放不同的语音提示，对以后所有的情况都播放同一个语音提示，比在11.8.2节中用Dialplan方式实现显然更简洁，也更容易理解。

当然，最后这一个例子在播放提示时没有播放被叫号码。如果读者也想在提示音中包含被叫号码，可以与originate_disposition参数一起传到Phrase Macro中，使用一个分隔符隔开（如“!”），这样就可以再用类似“^(.*)!(.*)$”这样的正则表达式将两个参数取出来了。具体的实现留给读者练习，在此就不多讲了。

### 原理

当然，在被叫失败后播放我们上面指定的提示音或TTS是有一个前提的——在Dialplan的第一个bridge之前要有以下两行：

```xml
<action application="set" data="hangup_after_bridge=true"/>
<action application="set" data="continue_on_fail=true"/>
```

其中，第一行的作用是：在一个成功的bridge之后，如果被叫用户挂断电话，我们也没有必要再向主叫用户播放提示音了，因此可以直接挂机（Hangup After Bridge的字面意思就是“在Bridge成功后挂断电话”）。当然，这一行也可以没有，这就需要在后面检查originate_disposition变量值的时候，发现如果是“NORMAL_CLEARING”（表示呼叫正常释放），再决定是否播放相关语音文件或挂机。

第二行的作用是：如果呼叫失败（fail，如空号，拒接等），让Dialplan继续往下执行；否则（值为false的情况）Channel在第一次呼叫（bridge）失败时就挂机了。该变量的值除了是笼统的“true”以外，还可是各种用逗号分隔开的挂断原因值。例如，下面的配置表示只有遇到用户忙或无应答这两种情况才播放语音，其他的就直接挂机。

```xml
<action application="set" data="continue_on_fail=USER_BUSY,NO_ANSWER"/>
```

常见的挂断原因取值除了上述代码中的外还有NORMAL_TEMPORARY_FAILURE（普通临时失败）、TIMEOUT（超时）、NO_ROUTE_DESTINATION（空号/无法路由）等几种。更详细的失败原因可以参见http://wiki.freeswitch.org/wiki/Hangup_causes。

总之，通过上述两个参数就可以在呼叫失败的时候让Dialplan正常往下进行，进而有机会检查上一次呼叫失败的原因，并播放相关的语音提示。

[1] 注意在zh.xml中需要配置正确的TTS引擎，如笔者配置的是“tts-engine="tts_commandline"ttsvoice="Ting-Ting"”。

## 实现呼叫前转业务

在传统的电话系统中，有一项基础的增值业务称为呼叫前转。它的使用方法是：通过拨打一个特定的功能码（一般是“*57*”）登记欲转移到的电话号码，以后所有呼叫都会转移到该号码上。具体来讲，如分机1002是Alice办公室的电话，由于她临时需要到另一个办公室工作，而另一个办公室有一部电话1007，因此，Alice在1002上拨打*57*1007#就可以登记呼叫前转业务，这样如果以后有人呼叫1002，就会自动转移到1007上，这样Alice就不会错过任何电话了。当她从另一个办公室回来时，她可再在1002上拨打#57#取消该业务，以后再有来话1002就会直接振铃了，而不会再发生转移了。

在传统的交换机上，需要为1002分机开通一个权限的，然后该分机才可以拨打*57*或#57#进行登记和取消。当然，我们在这里先不考虑这些权限问题，认为所有用户都有该权限就可以了。

为了实现业务登记，我们先建立以下路由：

```xml
<extension name="call_forward_unconditional_set">
  <condition field="destination_number" expression="^\*57\*([^#]*)#?$">
    <action application="hash" data="insert/${domain_name}-cfwdu/${username}/$1"/>
    <action application="answer"/>
    <action application="playback" data="您登记的业务已经成功.wav"/>
  </condition>
</extension>
```

可以看出，正则表达式“^\*57\*(\[^#\]\*)#?”会匹配“\*57\*1007#”，并将电话号码存储在变量$1中。这里，考虑到有些话机无法输入末尾的#号键（有些话机会认为按#表示号码输入完毕，因而送给FreeSWITCH的被叫号码不包含#号），我们通过正则表达式中的“?”把它标志为可选的。也就是说，如果用户拨打“\*57\*1007”也会匹配到这里。

在电话到达后，我们使用hash [1]App将该信息存储在系统内存中的一个哈希表中。hash的参数是以“/”隔开的几项：insert表示向哈希表中插入数据；\${domain_name}-cfwdu表示一个域（realm），该域是我们自己定义的，其中的cfwdu是无条件呼叫前转（Call Forward Unconditional）的英文简写形式，用于标志我们这里的呼叫前转业务；\${username}是一个键（key），在本例子中，它就是主叫用户1002；$1是该键的值（value），在此它等于1007。

当然，登记成功后，我们不会忘记使用playback播放一个友好的语音提示。

通过下面Dialplan Extension，可以在1002拨打#57#时将登记的信息删除：

```xml
<extension name="call_forward_unconditional_unset">
  <condition field="destination_number" expression="^#57#?$">
    <action application="hash" data="delete/${domain_name}-cfwdu/${username}"/>
    <action application="answer"/>
    <action application="playback" data="您登记的业务已经取消.wav"/>
  </condition>
</extension>
```

同样，我们也不要求被叫号码最后必须有#号，就算没有上面的正则表达式也会匹配#57。可以看出，hash App的参数由insert换成了delete，表示我们要删除一个键。

在实现了登记的删除后，我们就在正常的路由中进行检查了。来看下面的Dialplan设置：

```xml
<extension name="call_forward_unconditional_check" continue="true">
  <condition>
    <action application="info" data=""/>
    <action application="set" inline="true"
        data="cfwdu=${hash(select/${domain_name}-cfwdu/${destination_number})}"/>
  </condition>
</extension>
```

上述Dialplan定义了一个绝对的条件（因为<condition>标签没有其他属性），因而它总是会被匹配到。在电话路由到这里后，我们先使用info App在日志中打印一些调试信息，以方便查找问题。然后，通过set App设置一个cfwdu变量，该变量的值是从哈希表中使用select取出的。如果用*57*进行了登记，则表示它就有值，否则就是一个空字符串。在此，如果有人拨打1002，则这里哈希表的键就是以\${destination_number}标志的，即1002。

注意，此处的inline="true"参数非常关键。有了它，这一行的set命令在Dialplan解析的阶段就会执行，这样到后面我们才能根据该变量来进行后续的条件判断。

在此，我们也可以用下面的hash API命令进行检查（192.168.7.5是笔者电脑上${domain_name}的值）：

```
freeswitch> hash select/192.168.7.5-cfwdu/1002
1007
```

可以看出，我们确定可以在域192.168.7.5-cfwdu中通过1002这个键找到1007这个值（当然，前提是1002已经拨打过“\*57\*1007#”进行登记）。

然后，继续向下路由，直到下面的Dialplan Extension：

```xml
<extension name="call_forward_unconditional_check2" continue="true">
  <condition field="${cfwdu}" expression="^10[01][0-9]">
    <action application="bridge" data="user/${cfwdu}"/>
  </condition>
</extension>
```

该Extension检查的条件是cfwdu这个变量的值（就是我们上一步中set的），如果它的值匹配一个分机号（登记后它将匹配1007），我们就执行bridge，它的参数在本例中将是user/1007，因而电话就“转移”到分机1007上去了。如果不匹配，Dialplan就会继续向下执行，跟没有登记是一样的。

<center>图12-4　Blink RFC4579会议界面</center>

此外，我们在本例中仅实现了无条件呼叫前转，对于其他转移方式，如遇忙转移和无应答转移等，可以根据本节的内容配合我们在上一节中讲到的方法进行实现。具体的实现方法留给读者自行练习，在此不再赘述。

[1] 用于在FreeSWITCH中使用内存中的哈稀表存储数据，参见http://wiki.freeswitch.org/wiki/Mod_hash。

## 小结

本章我们首先通过一些实例讲解了FreeSWITCH中最基本的用户、IVR及时间相关的Dialplan的配置，涵盖了最基本的配置、Application和路由相关的知识。其次，我们通过录音和放音的例子讲解了FreeSWITCH的文件接口，帮助大家了解了FreeSWITCH所支持的各种文件格式。再次，对于我们中国人来讲，在FreeSWITCH中能否使用中文语音提示肯定是大家最关心的问题，对此我们通过一些例子说明了各种实现方法。然后，我们介绍了TTS技术以及如何使用中文的TTS。通过使用TTS，可以快速设置语音提示和IVR等（至少省了录音的环节），而且我们在这里讲起来也更直观一些。最后，我们通过讲解呼叫失败后的处理以及呼叫前转的实现两个例子进一步讲解了Dialplan的配置、各种App的灵活运用等，并顺便讲了FreeSWITCH中用于临时及持久化存储的hash以及db等相关内容。

通过这些实际的例子，希望读者能加深对各种配置文件的认识，并能熟练掌握这里介绍的配置步骤，举一反三，进而对其他类似的模块和配置也能很快入手。

